var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); //@TODO Estas variaveis ate a classe sao para remover\n\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Choropleth */ 5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        console.log(\"Gisplay Class constructor\");\n        window.profiling = true;\n        window.maps = new Array();\n        window.mapcount = 0;\n\n        //WebGL API\n        window._vertexcount = 0;\n        window._tricount = 0;\n        return this;\n    }\n\n    _createClass(Gisplay, [{\n        key: \"makeChoropleth\",\n        value: function makeChoropleth(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            /*console.log(options)*/\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            this.makeMap(gismap, options); //options.defaultid);\n        }\n    }, {\n        key: \"makeDotMap\",\n        value: function makeDotMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new DotMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeProportionalSymbolsMap\",\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new PSymbolsMap(bgmap, geometry, options);\n            this.makeMap(gismap);\n        }\n    }, {\n        key: \"makeChangeMap\",\n        value: function makeChangeMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new ChangeMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeChorochromaticMap\",\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new ChorochromaticMap(bgmap, geometry, options);\n            this.makeMap(gismap, options.defaultid);\n        }\n    }, {\n        key: \"makeMap\",\n        value: function makeMap(gismap, options) {\n            var _this = this;\n\n            var defaultid = options.defaultid;\n            setTimeout(function (console) {\n                /*alert(this.profiling);*/\n                var start = 0;\n                if (_this.profiling == true) start = Date.now();\n                defaultid = defaultid != null ? defaultid : 1;\n                if (gismap.colorscheme == undefined) gismap.colorscheme = gismap.defaults(defaultid).colorScheme;\n                if (gismap.classbreaks == undefined) {\n                    if (gismap.numberofclasses == undefined) {\n                        gismap.numberofclasses = gismap.defaults(defaultid).numberOfClasses;\n                    }\n                    gismap.preProcessData(gismap.geometry, gismap.numberofclasses, gismap.algorithm, gismap.colorscheme);\n                }\n\n                //gismap.processData(gismap.geometry);\n                gismap.loadGeoJSON(gismap.geometry);\n                var start2 = 0;\n                if (_this.profiling == true) {\n                    start2 = Date.now();\n                    window.console.log(\"Tempo de processamento do dados (segundos): \" + (start2 - start) / 1000);\n                }\n                gismap.draw();\n\n                var end = 0;\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log(\"Tempo de desenho do mapa (segundos): \" + (end - start2) / 1000);\n                }\n                if (options.legend != false) gismap.buildLegend();\n                if (options.loader != false) {\n                    gismap.loader();\n                }\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log(\"Tempo total (segundos): \" + (end - _this.startTimeStamp) / 1000);\n                }\n            }, 1);\n        }\n    }, {\n        key: \"changemapDefaults\",\n        value: function changemapDefaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5LmpzPzA1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy9AVE9ETyBFc3RhcyB2YXJpYXZlaXMgYXRlIGEgY2xhc3NlIHNhbyBwYXJhIHJlbW92ZXJcclxuaW1wb3J0IHtDaG9yb3BsZXRofSBmcm9tICcuL01hcHMvQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogR2lzcGxheSBBUEkgd2l0aCBvbmUgbWV0aG9kIGZvciBlYWNoIG1hcCBhdmFpbGFibGUuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgR2lzcGxheSB7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiR2lzcGxheSBDbGFzcyBjb25zdHJ1Y3RvclwiKTtcclxuICAgICAgICB3aW5kb3cucHJvZmlsaW5nID0gdHJ1ZTtcclxuICAgICAgICB3aW5kb3cubWFwcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHdpbmRvdy5tYXBjb3VudCA9IDA7XHJcblxyXG4gICAgICAgIC8vV2ViR0wgQVBJXHJcbiAgICAgICAgd2luZG93Ll92ZXJ0ZXhjb3VudCA9IDA7XHJcbiAgICAgICAgd2luZG93Ll90cmljb3VudCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZUNob3JvcGxldGgoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIC8qY29uc29sZS5sb2cob3B0aW9ucykqL1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7Ly9vcHRpb25zLmRlZmF1bHRpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZURvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IERvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMuZGVmYXVsdGlkKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbWFrZVByb3BvcnRpb25hbFN5bWJvbHNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBQU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXApO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBtYWtlQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucy5kZWZhdWx0aWQpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBtYWtlQ2hvcm9jaHJvbWF0aWNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb2Nocm9tYXRpY01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMuZGVmYXVsdGlkKTtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlTWFwKGdpc21hcCwgb3B0aW9ucykge1xyXG4gICAgICAgIGxldCAgZGVmYXVsdGlkID0gb3B0aW9ucy5kZWZhdWx0aWQ7XHJcbiAgICAgICAgc2V0VGltZW91dChjb25zb2xlID0+IHtcclxuICAgICAgICAgICAgLyphbGVydCh0aGlzLnByb2ZpbGluZyk7Ki9cclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHRpZCA9IGRlZmF1bHRpZCAhPSBudWxsID8gZGVmYXVsdGlkIDogMTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jb2xvcnNjaGVtZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBnaXNtYXAuY29sb3JzY2hlbWUgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5jb2xvclNjaGVtZTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jbGFzc2JyZWFrcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnaXNtYXAubnVtYmVyb2ZjbGFzc2VzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdpc21hcC5udW1iZXJvZmNsYXNzZXMgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnaXNtYXAucHJlUHJvY2Vzc0RhdGEoZ2lzbWFwLmdlb21ldHJ5LCBnaXNtYXAubnVtYmVyb2ZjbGFzc2VzLCBnaXNtYXAuYWxnb3JpdGhtLCBnaXNtYXAuY29sb3JzY2hlbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dpc21hcC5wcm9jZXNzRGF0YShnaXNtYXAuZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICBnaXNtYXAubG9hZEdlb0pTT04oZ2lzbWFwLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0MiA9IDA7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydDIgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRvIGRhZG9zIChzZWd1bmRvcyk6ICR7KHN0YXJ0MiAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ2lzbWFwLmRyYXcoKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBlbmQgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgZGVzZW5obyBkbyBtYXBhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0MikgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZCAhPSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIGdpc21hcC5idWlsZExlZ2VuZCgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGdpc21hcC5sb2FkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gdG90YWwgKHNlZ3VuZG9zKTogJHsoZW5kIC0gdGhpcy5zdGFydFRpbWVTdGFtcCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgY2hhbmdlbWFwRGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L0dpc3BsYXkuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFEQTtBQUNBOzs7QUFDQTs7O0FBR0E7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/Gisplay/Aesthetic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Aesthetic = exports.Aesthetic = function () {\n    function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n        _classCallCheck(this, Aesthetic);\n\n        this.id = id;\n        this.fillColor = fcolor;\n        this.strokeColor = stroke;\n        this.range = range;\n        this._attr = attr;\n        this.pointSize = pointsize == null ? 1.0 : parseFloat(pointsize);\n        this._features = new Array();\n        this._allFeatures = null;\n        this.enabled = true;\n        this.outer = false;\n        return this;\n    }\n\n    _createClass(Aesthetic, [{\n        key: 'addFeature',\n        value: function addFeature(id, properties, triangles, borders, points) {\n            this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n        }\n    }, {\n        key: 'getAttr',\n        value: function getAttr() {\n            return this._attr;\n        }\n    }, {\n        key: 'checkProperty',\n        value: function checkProperty(value) {\n            if (this.range == null) return true;else {\n                if (typeof value === 'number') {\n\n                    return (this.range[0] == null || value >= this.range[0]) && (this.range[1] == null || value < this.range[1] || value <= this.range[1] && this.outer == true);\n                } else return value == this.range[0];\n            }\n        }\n    }, {\n        key: 'addGroupedFeature',\n        value: function addGroupedFeature(id, triangles, borders, points) {\n            if (this._allFeatures == null) {\n                this._allFeatures = new Array();\n                this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n            } else {\n                var cursor = 0; //TODO\n                //this._allFeatures[0]._properties.push(properties);\n                this._allFeatures[cursor].push(new _Feature.Feature(id, null, triangles, borders, points));\n                //this._allFeatures[cursor]._triangles.concat(triangles);\n                //this._allFeatures[cursor]._borders.concat(borders);\n            }\n        }\n    }, {\n        key: 'enableDisable',\n        value: function enableDisable() {\n            this.enabled = !this.enabled;\n            return this.enabled;\n        }\n    }]);\n\n    return Aesthetic;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9BZXN0aGV0aWMuanM/NTllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ZlYXR1cmV9IGZyb20gJy4vRmVhdHVyZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgQWVzdGhldGljIHtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IoaWQsIGF0dHIsIGZjb2xvciwgc3Ryb2tlLCBwb2ludHNpemUsIHJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBzdHJva2U7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIHRoaXMuX2F0dHIgPSBhdHRyO1xyXG4gICAgICAgIHRoaXMucG9pbnRTaXplID0gcG9pbnRzaXplID09IG51bGwgPyAxLjAgOiBwYXJzZUZsb2F0KHBvaW50c2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEF0dHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHI7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmdlID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMucmFuZ2VbMF0gPT0gbnVsbCB8fCB2YWx1ZSA+PSB0aGlzLnJhbmdlWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICh0aGlzLnJhbmdlWzFdID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlIDwgdGhpcy5yYW5nZVsxXSB8fCAodmFsdWUgPD0gdGhpcy5yYW5nZVsxXSAmJiB0aGlzLm91dGVyID09IHRydWUpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT0gdGhpcy5yYW5nZVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEdyb3VwZWRGZWF0dXJlKGlkLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbGxGZWF0dXJlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSAwOyAvL1RPRE9cclxuICAgICAgICAgICAgLy90aGlzLl9hbGxGZWF0dXJlc1swXS5fcHJvcGVydGllcy5wdXNoKHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlc1tjdXJzb3JdLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxsRmVhdHVyZXNbY3Vyc29yXS5fdHJpYW5nbGVzLmNvbmNhdCh0cmlhbmdsZXMpO1xyXG4gICAgICAgICAgICAvL3RoaXMuX2FsbEZlYXR1cmVzW2N1cnNvcl0uX2JvcmRlcnMuY29uY2F0KGJvcmRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVEaXNhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9BZXN0aGV0aWMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Feature.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n/**\r\n * \r\n */\nvar Feature = exports.Feature = function Feature(id, properties, triangles, borders, points) {\n    _classCallCheck(this, Feature);\n\n    this._id = id;\n    this._properties = properties;\n    this._triangles = triangles;\n    this._borders = borders;\n    this._points = points;\n    return this;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9GZWF0dXJlLmpzP2ZiNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbnRlcm1lZGlhdGUgQVBJXHJcbi8qKlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcclxuICAgICAgICB0aGlzLl9ib3JkZXJzID0gYm9yZGVycztcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9GZWF0dXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/Gisplay/Legend.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Legend = exports.Legend = function () {\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        this.title = title;\n        this.init(id);\n        return this;\n    }\n\n    _createClass(Legend, [{\n        key: 'insertLegend',\n        value: function insertLegend(map) {\n            this.legendDiv.appendChild(this.table);\n            map.getContainer().appendChild(this.legendDiv);\n        }\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 2);\n        }\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 1);\n        }\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (currentaes.outer == false) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n            value.appendChild(text);\n\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n            colorDiv.style['backgroundColor'] = rgbc;\n            if (type == 1) {\n                //polygon\n                colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                colorDiv.style.width = 80; //(mapCanvas.width / 10);\n                if (currentaes.strokeColor != null && currentaes != undefined) colorDiv.style['borderColor'] = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type == 2) {\n                //point\n                var size = void 0;\n                if (currentaes.pointSize != null) {\n                    size = Math.max(currentaes.pointSize, 5);\n                } else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (Gisplay.profiling == true) var start = Date.now();\n                if (mapobj.legendToggle != false) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade == true) {\n                        this.className += \" _gisplayfade\";\n                    } else {\n                        this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                }\n                if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                mapobj.draw();\n                if (Gisplay.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                }\n            };\n\n            this.table.appendChild(row);\n        }\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberof = 5;\n            if (mapobj.aesthetics.length > 5) numberof = mapobj.aesthetics.length;\n            var strcolor = '';\n            for (var i = 0; i < numberof; i++) {\n                var color = mapobj.fcolor(i / numberof).rgb();\n                strcolor += ',rgba(' + Math.round(color[0]) + ',' + Math.round(color[1]) + ',' + Math.round(color[2]) + ',' + mapobj.alpha + ')';\n            }\n            strcolor += ') ';\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor;\n\n            valueDiv.style.height = 25; //(mapCanvas.height / 10);\n            valueDiv.style.width = 130; //(mapCanvas.width / 10);\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            value2.colSpan = 2;\n\n            var divleft = document.createElement('div');\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n    }, {\n        key: 'init',\n        value: function init(id, classname) {\n            //console.log(\"id == \" + id);\n            var mapCanvas = document.getElementById('mapCanvas' + id);\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) {\n                this.legendDiv.className = classname;\n            } else {\n                this.legendDiv.className = '_gisplaylegendBR';\n            }\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n            //thcolor.style.width = 100;\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numberof) {\n            if (this.lastdiv == undefined) {\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else {\n                this.firstInsertion = false;\n            }\n\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + 1 + ')';\n            var strokecolor = void 0;\n\n            if (currentaes.strokeColor != null && currentaes != undefined) strokecolor = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numberof - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (this.firstInsertion == false && i == numberof - 1 || numberof == 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numberof - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(round(propvalue));\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgbc;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.maxpointsize - mapobj.minpointsize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (Gisplay.profiling == true) var start = Date.now();\n                    if (mapobj.legendToggle != false) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade == true) {\n                            this.className += \" _gisplayfade\";\n                        } else {\n                            this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                        }\n                    }\n                    if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                    mapobj.draw();\n                    if (Gisplay.profiling == true) {\n                        var end = Date.now();\n                        window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                    }\n                    if (!e) var e = window.event;\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n                current.appendChild(colorDiv);\n                if ( /*i!= (numberof-1) &&*/this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n            if (this.firstInsertion == true) {\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9MZWdlbmQuanM/Yzg0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgTGVnZW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKGlkLCB0aXRsZSkge1xyXG4gICAgICAgIHRoaXMudGl0bGUgPSB0aXRsZTtcclxuICAgICAgICB0aGlzLmluaXQoaWQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydExlZ2VuZChtYXApIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZERpdi5hcHBlbmRDaGlsZCh0aGlzLnRhYmxlKTtcclxuICAgICAgICBtYXAuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQodGhpcy5sZWdlbmREaXYpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFBvaW50Um93KGN1cnJlbnRhZXMsIG1hcG9iaikge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0Um93KGN1cnJlbnRhZXMsIG1hcG9iaiwgMik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UG9seWdvblJvdyhjdXJyZW50YWVzLCBtYXBvYmopIHtcclxuICAgICAgICB0aGlzLmluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIHR5cGUpIHtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIGxldCB0ZXh0O1xyXG4gICAgICAgIGlmICh0eXBlb2YgY3VycmVudGFlcy5yYW5nZVswXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29uc3QgbWluaW5wdXQgPSBjdXJyZW50YWVzLnJhbmdlWzBdICE9IG51bGwgPyBjdXJyZW50YWVzLnJhbmdlWzBdIDogbWFwb2JqLm1pbjtcclxuICAgICAgICAgICAgY29uc3QgbWF4aW5wdXQgPSBjdXJyZW50YWVzLnJhbmdlWzFdICE9IG51bGwgPyBjdXJyZW50YWVzLnJhbmdlWzFdIDogbWFwb2JqLm1heDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMub3V0ZXIgPT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske21pbmlucHV0fSwgJHttYXhpbnB1dH1bYCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgWyR7bWluaW5wdXR9LCAke21heGlucHV0fV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VycmVudGFlcy5yYW5nZVswXSk7XHJcbiAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQodGV4dCk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29sb3JEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzNdfSlgO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSA9IHJnYmM7XHJcbiAgICAgICAgaWYgKHR5cGUgPT0gMSkgey8vcG9seWdvblxyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSAyNTsvLyhtYXBDYW52YXMuaGVpZ2h0IC8gMTApO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IDgwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMuc3Ryb2tlQ29sb3IgIT0gbnVsbCAmJiBjdXJyZW50YWVzICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlWydib3JkZXJDb2xvciddID0gYHJnYmEoJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzBdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMV19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclsyXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzNdfSlgO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlyZWN0YW5nbGUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09IDIpIHsvL3BvaW50XHJcbiAgICAgICAgICAgIGxldCBzaXplO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudGFlcy5wb2ludFNpemUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRhZXMucG9pbnRTaXplLCA1KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBzaXplID0gMjU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5Y2lyY2xlJztcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBjb2xvci5hcHBlbmRDaGlsZChjb2xvckRpdik7XHJcblxyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZChjb2xvcik7XHJcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuXHJcblxyXG5cclxuICAgICAgICByb3cub25jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKEdpc3BsYXkucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9GYWRlID0gIWN1cnJlbnRhZXMuZW5hYmxlRGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvRmFkZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsKGN1cnJlbnRhZXMpO1xyXG4gICAgICAgICAgICBtYXBvYmouZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAoR2lzcGxheS5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkZSBmaWx0cmFnZW0gcGVsYSBsZWdlbmRhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRHcmFkaWVudChtYXBvYmosIGxlZnQsIG1pZGRsZSwgcmlnaHQpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCB2YWx1ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgIHZhbHVlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGxldCBudW1iZXJvZiA9IDU7XHJcbiAgICAgICAgaWYgKG1hcG9iai5hZXN0aGV0aWNzLmxlbmd0aCA+IDUpXHJcbiAgICAgICAgICAgIG51bWJlcm9mID0gbWFwb2JqLmFlc3RoZXRpY3MubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdHJjb2xvciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyb2Y7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG1hcG9iai5mY29sb3IoaSAvIG51bWJlcm9mKS5yZ2IoKTtcclxuICAgICAgICAgICAgc3RyY29sb3IgKz0gYCxyZ2JhKCR7TWF0aC5yb3VuZChjb2xvclswXSl9LCR7TWF0aC5yb3VuZChjb2xvclsxXSl9LCR7TWF0aC5yb3VuZChjb2xvclsyXSl9LCR7bWFwb2JqLmFscGhhfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJjb2xvciArPSAnKSAnO1xyXG4gICAgICAgIHZhbHVlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBgLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCR7c3RyY29sb3J9YDtcclxuXHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICB2YWx1ZURpdi5zdHlsZS53aWR0aCA9IDEzMDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgdmFsdWUyLmNvbFNwYW4gPSAyO1xyXG5cclxuICAgICAgICBjb25zdCBkaXZsZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgbGVmdHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWZ0KTtcclxuICAgICAgICBjb25zdCBkaXZtaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZtaWQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtaWRkbGUpO1xyXG4gICAgICAgIGNvbnN0IGRpdnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0dGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJpZ2h0KTtcclxuXHJcblxyXG5cclxuICAgICAgICBkaXZsZWZ0LmFwcGVuZENoaWxkKGxlZnR0ZXh0KTtcclxuICAgICAgICBkaXZtaWQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgZGl2cmlnaHQuYXBwZW5kQ2hpbGQocmlnaHR0ZXh0KTtcclxuICAgICAgICB2YWx1ZTIuYXBwZW5kQ2hpbGQoZGl2bGVmdCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdm1pZCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdnJpZ2h0KTtcclxuICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZCh2YWx1ZURpdik7XHJcbiAgICAgICAgcm93Mi5hcHBlbmRDaGlsZCh2YWx1ZTIpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93Mik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdChpZCwgY2xhc3NuYW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImlkID09IFwiICsgaWQpO1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApO1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaWYgKGNsYXNzbmFtZSAhPSB1bmRlZmluZWQgJiYgY2xhc3NuYW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5bGVnZW5kQlInO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZ2VuZERpdi5pZCA9IGBsZWdlbmREaXYke2lkfWA7XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLnRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICB0aGlzLnRhYmxlLnN0eWxlLnpJbmRleCA9IFwiMjAwMFwiO1xyXG4gICAgICAgIGNvbnN0IHRodmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIGNvbnN0IHRoY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIHRoY29sb3Iuc3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIC8vdGhjb2xvci5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRoY29sb3IpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdGl0bGVyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIHRpdGxldGQuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgdGl0bGV0ZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICB0aXRsZXRkLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGl0bGUpO1xyXG4gICAgICAgIHRpdGxldGQuYXBwZW5kQ2hpbGQodGl0bGV0ZXh0KTtcclxuICAgICAgICB0aXRsZXJvdy5hcHBlbmRDaGlsZCh0aXRsZXRkKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRpdGxlcm93KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyhjdXJyZW50YWVzLCBtYXBvYmosIG51bWJlcm9mKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdGRpdiA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgICAgICB2YWx1ZS5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgdGhpcy5maXJzdEluc2VydGlvbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHsgdGhpcy5maXJzdEluc2VydGlvbiA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwkezF9KWA7XHJcbiAgICAgICAgbGV0IHN0cm9rZWNvbG9yO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudGFlcy5zdHJva2VDb2xvciAhPSBudWxsICYmIGN1cnJlbnRhZXMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclswXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzFdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMl19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclszXX0pYDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0cm9rZWNvbG9yID0gYHJnYmEoJHswfSwkezB9LCR7MH0sJHsxfSlgO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gbnVtYmVyb2YgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGxldCBwcm9wdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0SW5zZXJ0aW9uID09IGZhbHNlICYmIGkgPT0gKG51bWJlcm9mIC0gMSkgfHwgbnVtYmVyb2YgPT0gMSlcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IGN1cnJlbnRhZXMucmFuZ2VbMV07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IG1hcG9iai5taW4gKyBpIC8gKG51bWJlcm9mIC0gMSkgKiAobWFwb2JqLm1heCAtIG1hcG9iai5taW4pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJvdW5kKHByb3B2YWx1ZSkpO1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJnYmM7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheXByb3BvcnRpb25hbGNpcmNsZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJvcmRlckNvbG9yID0gc3Ryb2tlY29sb3I7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBwb2ludHNpemUgPSAoKG1hcG9iai5tYXhwb2ludHNpemUgLSBtYXBvYmoubWlucG9pbnRzaXplKSAvIChtYXBvYmoubWF4IC0gbWFwb2JqLm1pbikpICogKHByb3B2YWx1ZSAtIG1hcG9iai5taW4pO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgodGVtcHBvaW50c2l6ZSwgNy41KTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5pbmhlcml0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb2xvckRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChHaXNwbGF5LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvRmFkZSA9ICFjdXJyZW50YWVzLmVuYWJsZURpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9GYWRlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbChjdXJyZW50YWVzKTtcclxuICAgICAgICAgICAgICAgIG1hcG9iai5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoR2lzcGxheS5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIGZpbHRyYWdlbSBwZWxhIGxlZ2VuZGEgKHNlZ3VuZG9zKTogJHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZSkgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuICAgICAgICAgICAgaWYgKC8qaSE9IChudW1iZXJvZi0xKSAmJiovIHRoaXMubGFzdGRpdiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdi5hcHBlbmRDaGlsZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdiA9IGNvbG9yRGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RkaXYgPSBjb2xvckRpdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RJbnNlcnRpb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTGVnZW5kLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n    function BGMapWrapper(map) {\n        _classCallCheck(this, BGMapWrapper);\n\n        console.log(\"BGMapWrapper constructor?\");\n        this.map = map;\n        return this;\n    }\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.map.getContainer();\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.map.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //mapCanvas.style.zIndex = \"2\";\n\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.map.getZoom();\n        }\n    }, {\n        key: 'getLngBound',\n        value: function getLngBound() {\n            return this.map.getBounds().getNorthWest().lng;\n        }\n    }, {\n        key: 'getLatBound',\n        value: function getLatBound() {\n            return this.map.getBounds().getNorthWest().lat;\n        }\n    }, {\n        key: 'onEvent',\n        value: function onEvent(eventstr, eventfunction) {\n            this.map.on(eventstr, eventfunction);\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            if (this.loaderDiv === undefined) this.createLoader(this.map);else {\n                if (this.loaderDiv.style.display == 'none') this.loaderDiv.style.display = 'flex';else {\n                    this.loaderDiv.style.display = 'none';\n                }\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');\n                } else {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n                }\n            }\n        }\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n\n            /*outerDiv.style = ' opacity: 0.5; background-color: grey; justify-content: center; display: flex;';\r\n            outerDiv.style.position = 'absolute';\r\n            outerDiv.style.zIndex = '999999999';*/\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            this.loaderDiv = outerDiv;\n\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcz9lMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5leHBvcnQgY2xhc3MgQkdNYXBXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQkdNYXBXcmFwcGVyIGNvbnN0cnVjdG9yP1wiKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRDb250YWluZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldENvbnRhaW5lcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcyhpZCkge1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIG1hcENhbnZhcy5pZCA9IGBtYXBDYW52YXMke2lkfWA7XHJcbiAgICAgICAgbWFwQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHJcbiAgICAgICAgY29uc3QgbWFwRGl2ID0gdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCk7XHJcbiAgICAgICAgbWFwQ2FudmFzLmhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgbWFwQ2FudmFzLndpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIC8vbWFwQ2FudmFzLnN0eWxlLnpJbmRleCA9IFwiMlwiO1xyXG5cclxuICAgICAgICAvL2Nhc2UgbWFwYm94XHJcbiAgICAgICAgbWFwRGl2Lmluc2VydEJlZm9yZShtYXBDYW52YXMsIG1hcERpdi5maXJzdENoaWxkLm5leHRTaWJsaW5nKTtcclxuXHJcbiAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7aWR9YCk7XHJcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcclxuICAgIH1cclxuXHJcbiAgICBnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TG5nQm91bmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxuZztcclxuICAgIH1cclxuXHJcbiAgICBnZXRMYXRCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkubGF0O1xyXG4gICAgfVxyXG5cclxuICAgIG9uRXZlbnQoZXZlbnRzdHIsIGV2ZW50ZnVuY3Rpb24pIHtcclxuICAgICAgICB0aGlzLm1hcC5vbihldmVudHN0ciwgZXZlbnRmdW5jdGlvbik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRlckRpdiA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUxvYWRlcih0aGlzLm1hcCk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlckRpdi5zdHlsZS5kaXNwbGF5ID09ICdub25lJylcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5pbmNsdWRlcygnX2dpc3BsYXloaWRkZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lID0gdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5aGlkZGVuKD8hXFxTKS9nLCAnX2dpc3BsYXlMb2FkZXJPdXRlckRpdicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lID0gdGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5TG9hZGVyT3V0ZXJEaXYoPyFcXFMpL2csICdfZ2lzcGxheWhpZGRlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUxvYWRlcigpIHtcclxuICAgICAgICBjb25zdCBvdXRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbnN0IGlubmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaW5uZXJEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5bG9hZGVyJztcclxuXHJcbiAgICAgICAgY29uc3QgbWFwRGl2ID0gdGhpcy5nZXRDb250YWluZXIoKTtcclxuXHJcbiAgICAgICAgLypvdXRlckRpdi5zdHlsZSA9ICcgb3BhY2l0eTogMC41OyBiYWNrZ3JvdW5kLWNvbG9yOiBncmV5OyBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjsgZGlzcGxheTogZmxleDsnO1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS56SW5kZXggPSAnOTk5OTk5OTk5JzsqL1xyXG4gICAgICAgIG91dGVyRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheUxvYWRlck91dGVyRGl2JztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS5oZWlnaHQgPSBtYXBEaXYub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLndpZHRoID0gbWFwRGl2Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgIG91dGVyRGl2LmFwcGVuZENoaWxkKGlubmVyRGl2KTtcclxuICAgICAgICB0aGlzLmxvYWRlckRpdiA9IG91dGVyRGl2O1xyXG5cclxuICAgICAgICBtYXBEaXYucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUob3V0ZXJEaXYsIG1hcERpdik7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQkdNYXBXcmFwcGVyLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/Maps/Choropleth.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 6);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    function Choropleth(bgmap, geometry, options) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, options));\n\n        _this.aesthetics = new Array();\n        _this.geometry = geometry;\n        _this.loadOptions(options, bgmap);\n        _this.id = 0; //mapcount++;\n        _this.type = 'CP';\n        maps.push(_this);\n        _this.initialize();\n        /*return this;*/\n        return _this;\n    }\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            //console.log(\"Choropleth drawaaa() called\");\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawTriangles(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            //console.log(\"Choropleth buildLegend() called\");\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPolygonRow(this.aesthetics[a], this);\n            }\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            //console.log(\"Choropleth defaults() called\");\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanM/ZjhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSAnLi4vTGVnZW5kJztcclxuXHJcbi8qKlxyXG4gKiBDaG9yb3BsZXRoIGltcGxlbWVudGF0aW9uIDA2LzAzXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9wbGV0aCBleHRlbmRzIE1hcCB7XHJcbiAgICBcclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSAwOy8vbWFwY291bnQrKztcclxuICAgICAgICB0aGlzLnR5cGUgPSAnQ1AnO1xyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAvKnJldHVybiB0aGlzOyovXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBkcmF3YWFhKCkgY2FsbGVkXCIpO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VHJpYW5nbGVzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBidWlsZExlZ2VuZCgpIGNhbGxlZFwiKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhIGluIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2x5Z29uUm93KHRoaXMuYWVzdGhldGljc1thXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNob3JvcGxldGggZGVmYXVsdHMoKSBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3doaXRlJywgJ3llbGxvdycsICdvcmFuZ2UnLCAncmVkJ107XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWJlck9mQ2xhc3NlcyA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/Gisplay/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 4);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 1);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \r\n * ES5 libraries can be used either with \r\n * 1)import if they are just functions or in the case of rtree and ktree a \r\n * webpack loader is needed \"script-loader\"\" can do that.\r\n * 2) Added as <script> tag on index.html file\r\n * The former as choosen.\r\nimport chroma from '../../lib/chroma.min';\r\nimport earcut from '../../lib/earcut'\r\nimport {PolygonLookup} from '../../lib/rtree';\r\n*/\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available.\r\n */\nvar Map = exports.Map = function () {\n    function Map(type, geometry, options) {\n        _classCallCheck(this, Map);\n\n        console.log(\"Map constructor called -> super()\");\n        /* return this;*/ //@TODO Remove isnt doing anything? or is it saving the 3 parameters?\n    }\n\n    _createClass(Map, [{\n        key: 'program',\n        value: function program() {\n            this._webgl.program = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram = [];\n            this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();\n\n            var source_code = this.generateShaders();\n\n            var vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);\n            var fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);\n\n            this._webgl.gl.attachShader(this._webgl.program, vertex_shader);\n            this._webgl.gl.attachShader(this._webgl.program, fragment_shader);\n\n            this._webgl.gl.linkProgram(this._webgl.program);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'shader',\n        value: function shader(type, source_code, _webgl) {\n            //Added HERE by Rui\n            var shader = _webgl.gl.createShader(type);\n\n            _webgl.gl.shaderSource(shader, source_code);\n            _webgl.gl.compileShader(shader);\n\n            console.log(\"shader \" + (type.valueOf() == 35633 ? \"vertex\" : \"fragment\") + \": \" + _webgl.gl.getShaderInfoLog(shader));\n\n            return shader;\n        }\n    }, {\n        key: 'generateShaders',\n        value: function generateShaders() {\n            //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=\n            //general\n\n            var vertexSourceCode = \" attribute vec4 vertexCoord; \";\n            vertexSourceCode += \"\\n\tattribute float aPointSize; \";\n            vertexSourceCode += \"\\n\tuniform mat4 projection; \";\n            vertexSourceCode += \"\\n\tattribute float a_opacity; \";\n            vertexSourceCode += \"\\n\tvarying float v_opacity; \";\n            //vertexSourceCode+= \"\\n\tvarying vec4 u_color; \" ; //delete\n            vertexSourceCode += \"\\n\tvoid main() {\";\n            vertexSourceCode += \"\\n\t\tgl_Position = (projection * vertexCoord); \";\n            vertexSourceCode += \"\\n\t\tgl_PointSize = aPointSize; v_opacity = a_opacity; \";\n            vertexSourceCode += \"\\n}\";\n\n            var fragmentSourceCode = \"precision mediump float;\";\n            fragmentSourceCode += \"\\n\t\tuniform vec4 u_color;\"; //uniform\n            fragmentSourceCode += \"\\n\t\tvarying float v_opacity; \";\n            fragmentSourceCode += \"\\n \t\tuniform float isPoint;\";\n            fragmentSourceCode += \"\\n\t\tvoid main(){\";\n            fragmentSourceCode += \"\\n\t\t\tfloat border = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat radius = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat centerDist = length(gl_PointCoord - 0.5);\";\n            fragmentSourceCode += \"\\n\t\t\tfloat alpha;\";\n            fragmentSourceCode += \"\\n\t\t\tif (u_color[3] == -1.0){\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  v_opacity * step(centerDist, radius);\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\telse{\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  u_color[3] * step(centerDist, radius);\";\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\tif(isPoint == 1.0 ){\";\n            fragmentSourceCode += \"\\n\t\t\tif (alpha < 0.1) discard;\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}\";\n            fragmentSourceCode += \"\\n \t\t\telse\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\";\n            fragmentSourceCode += \"\\n\t\t}\";\n\n            return { vertex: vertexSourceCode, fragment: fragmentSourceCode };\n        }\n    }, {\n        key: 'addAesthetic',\n        value: function addAesthetic(aes) {\n            this.aesthetics.push(aes);\n        }\n    }, {\n        key: 'setAesthetic',\n        value: function setAesthetic(id, aes) {\n            for (var i = 0; i < aesthetics.length; i++) {\n                if (id == aesthetics[i].id) {\n                    aesthetics[i] = aes;\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            //legendDiv.style.height = 200;//(mapCanvas.height / 10);\n            legendDiv.style.width = 250; //(mapCanvas.width / 10);\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            //thvalue.style.width = 125;\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var currentaes = _step.value;\n\n                    //if(currentaes._features.length > 0 || currentaes._allFeatures.length > 0){\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    //console.log(rgbc);\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                    colorDiv.style.width = 80; //(mapCanvas.width / 10);\n\n\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n\n                    table.appendChild(row);\n                    //}\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.map.getContainer().appendChild(legendDiv);\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n\n            var aesarray = [];\n            var values = [];\n            var strings = [];\n            var breaks = void 0;\n            var fcolor = void 0;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (geojson.features[g].properties[this.attr] != null && typeof geojson.features[g].properties[this.attr] == 'number') {\n                    values.push(geojson.features[g].properties[this.attr]);\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);\n                } else if (!strings.includes(geojson.features[g].properties[this.attr])) strings.push(geojson.features[g].properties[this.attr]);\n            }\n            if (values.length > 0) {\n                //quantitative\n                if (this.breaks == undefined) {\n                    if (numberOf > 1) breaks = this.calcClassBreaks(values, algorithm, numberOf);else breaks = [this.min, this.max];\n                } else {\n                    breaks = this.breaks;\n                }\n                if (breaks.length > 2) {\n                    fcolor = chroma.scale(colorscheme).colors(breaks.length - 1);\n                    for (var i = 0; i < breaks.length - 1; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        if (i != breaks.length - 2) {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                        } else {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    color = chroma(colorscheme[0]).rgb();\n                    var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n                    aes.outer = true;\n                    aesarray.push(aes);\n                }\n            } else {\n                //qualitative\n                if (strings.length > 0) {\n                    breaks = strings;\n                    if (typeof colorscheme === 'string') {\n                        //string\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    } else {\n                        //array\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    }\n                    for (var i = 0; i < breaks.length; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);\n                        aesarray.push(aes);\n                    }\n                }\n            }\n\n            this.aesthetics = aesarray;\n            //return aesarray;\n\n        }\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(values, algorithm, numberOf) {\n            var breaks = void 0;\n            switch (algorithm) {\n                case 'equidistant':\n                    breaks = chroma.limits(values, 'e', numberOf);\n                    break;\n\n                case 'quantile':\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n\n                case 'k-means':\n                    breaks = chroma.limits(values, 'k', numberOf);\n                    break;\n\n                default:\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n            }\n            return breaks;\n        }\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var flag = false;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {\n                    this.aesthetics[i].addFeature(id, properties, triangles, borders, points);\n                    flag = true;\n                }\n            }\n            if (!flag) {\n                //TODO\n                //console.log(\"TODO: feature does not fit into any of the aesthetics defined.\\n Value: \" + properties[this.attr]);\n            }\n        }\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(idaes, triangles, borders, points) {\n\n            this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);\n        }\n    }, {\n        key: 'draw',\n        value: function draw() {\n\n            alert(\"draw() not implemented\");\n        }\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n\n            if (polygon.geometry.type == \"Polygon\") {\n                var outsidepolygon = polygon.geometry.coordinates[0];\n\n                var insidepolygons = [];\n                for (var k = 1; k < polygon.geometry.coordinates.length; k++) {\n                    //todo inside polygon\n                    //insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                }\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                    _vertexcount += (outsidepolygon.length + 1) / 2;\n                    //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                }\n\n                var triangles_vert = earcut(tempVerts);\n                _tricount += triangles_vert.length / 3;\n                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                var polyarray = [];\n                for (var i = 0; i < polygon.geometry.coordinates.length; i++) {\n\n                    var outsidepolygon = polygon.geometry.coordinates[i][0];\n\n                    var insidepolygons = [];\n                    for (var k = 1; k < polygon.geometry.coordinates[i].length; k++) {\n                        //todo inside polygon\n                        insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                    }\n                    var tempVerts = new Array();\n                    _vertexcount += outsidepolygon.length;\n                    for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                        tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n\n                        //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                    }\n\n                    var triangles_vert = earcut(tempVerts);\n\n                    //var temp = earcut.flatten(polygon.geometry.coordinates[i]);\n                    //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);\n                    _tricount += triangles_vert.length / 3;\n                    polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n                    //console.log(polyarray);\n                }\n\n                return polyarray;\n            }\n        }\n    }, {\n        key: 'processData',\n        value: function processData(geojson) {\n\n            this.loadGeoJSON(geojson);\n        }\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(id, geometry, properties) {\n            var gl = this._webgl.gl;\n            if (this.minuend != undefined && this.subtrahend != undefined && typeof properties[this.minuend] == 'number' && properties[this.subtrahend] != undefined && typeof properties[this.subtrahend] == 'number' && properties[this.subtrahend] != undefined) {\n                properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];\n            }\n\n            if (geometry.type == \"Polygon\" || geometry.type == \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentBorders = [];\n                var currentTriangles = [];\n                var bufferT = [];\n                var bufferB = [];\n\n                for (var j = 0; j < polygons.length; j++) {\n                    var trianglespolygon = polygons[j].triangles;\n                    var border = polygons[j].vertex;\n                    currentTriangles[j] = new Array();\n                    currentBorders[j] = new Array();\n                    for (var h = 0; h < trianglespolygon.length; h++) {\n                        var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);\n                        currentTriangles[j].push(pixel.x, pixel.y);\n\n                        if (h == trianglespolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[j].itemSize = 2;\n                            bufferT[j].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var y = 0; y < border.length; y += 2) {\n                        var pixel = this.latLongToPixelXY(border[y], border[y + 1]);\n                        currentBorders[j].push(pixel.x, pixel.y);\n\n                        if (y == border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentBorders[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferB[j].itemSize = 2;\n                            bufferB[j].numItems = vertArray.length / 2;\n                        }\n                    }\n                }\n                //polygon\n                this.insertFeature(id, properties, bufferT, bufferB, []);\n            } else if (geometry.type == \"Point\" && this.dynamic == true) {\n                //dum\n                var currentPoints = [];\n                currentPoints[0] = new Array();\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                currentPoints[0].push(pixel.x, pixel.y);\n                var bufferP = [];\n                bufferP.push(gl.createBuffer());\n\n                var vertArray = new Float32Array(currentPoints[0]);\n\n                gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                bufferP[0].itemSize = 2;\n                bufferP[0].numItems = vertArray.length / 2;\n\n                this.insertFeature(id, properties, [], [], bufferP);\n\n                if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type == \"Point\" && this.dynamic == false) {\n                //debugger;\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                if (this.tempPoints == null || this.tempPoints == undefined) {\n                    this.tempPoints = new Array();\n                    for (var a = 0; a < this.aesthetics.length; a++) {\n                        this.tempPoints[a] = [];\n                    }\n                }\n\n                var aesarrays = this.fitFeature(properties);\n                for (var y = 0; y < aesarrays.length; y++) {\n                    this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);\n                }\n\n                if (this.treepoints == null) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempPoints != null) {\n                for (var t = 0; t < this.tempPoints.length; t++) {\n                    if (this.tempPoints[t].length > 0) {\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        var vertArray = new Float32Array(this.tempPoints[t]);\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(t, [], [], bufferP);\n                    }\n                }\n            }\n            //console.log(geojson)\n            if (this.treepoints != null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons == true) this.rtree = new PolygonLookup(geojson);\n            //console.log(\"@Rui LOOK I WAS REMOVED\");\n        }\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                geojson.features[g].properties['_gisplayid'] = g;\n                var geometry = geojson.features[g].geometry;\n                var properties = geojson.features[g].properties;\n                this.createAndInsertFeature(g, geometry, properties);\n            }\n            this.buildTrees(geojson);\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.map.createCanvas(this.id);\n\n            //init webgl properties\n            this._webgl = {\n                gl: null,\n                program: null,\n                projection: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            this._webgl.projection = new Float32Array(16);\n            this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n            this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'getNumberOfFeatures',\n        value: function getNumberOfFeatures() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                count += this.aesthetics[i]._features.length;\n            }\n            return count;\n        }\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            // scaling x and y, which is just scaling first two rows of matrix\n            matrix[0] *= scaleX;\n            matrix[1] *= scaleX;\n            matrix[2] *= scaleX;\n            matrix[3] *= scaleX;\n\n            matrix[4] *= scaleY;\n            matrix[5] *= scaleY;\n            matrix[6] *= scaleY;\n            matrix[7] *= scaleY;\n        }\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            // translation is in last row of matrix\n            matrix[12] += matrix[0] * tx + matrix[4] * ty;\n            matrix[13] += matrix[1] * tx + matrix[5] * ty;\n            matrix[14] += matrix[2] * tx + matrix[6] * ty;\n            matrix[15] += matrix[3] * tx + matrix[7] * ty;\n        }\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n\n            return pixel;\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._borders.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length && this.dynamic == true; i++) {\n                for (var y = 0; y < aes._features[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                    //1);\n                }\n            }\n\n            for (var i = 0; this.dynamic == false && aes._allFeatures != null && i < aes._allFeatures.length; i++) {\n                for (var y = 0; y < aes._allFeatures[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);\n                    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);\t\n                    //1);\n                }\n            }\n        }\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n\n            for (var i = 0; i < aes._features.length; i++) {\n                var ucolor = void 0;\n                var color = void 0;\n                var diff = aes._features[i]._properties[this.attr];\n                if (diff == 0) color = aes.fillColor(0.5).rgb();else {\n                    if (diff > 0) {\n                        color = aes.fillColor(0.5 + diff / this.max / 2).rgb();\n                    } else {\n                        color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                }\n                ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];\n\n                gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawProporcionalPoints',\n        value: function drawProporcionalPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);\n\n            if (this.dynamic == true) {\n                for (var i in aes._features) {\n                    for (var y in aes._features[i]._points) {\n\n                        gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n                        var propvalue = parseFloat(aes._features[i]._properties[this.attr]);\n                        var temppointsize = (this.maxpointsize - this.minpointsize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n                        var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n                        gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n                        gl.enableVertexAttribArray(vertexCoordLocation);\n                        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                        //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                        //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                        gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                        //1);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            this.max = null;\n            this.min = null;\n            this.createCanvas();\n            this.program();\n            var mappos = void 0;\n            for (var i = 0; i < maps.length; i++) {\n                if (maps[i].id == this.id) mappos = i;\n            }this.map.onEvent('move', function () {\n                console.log(\"@Rui: mudar o profiling do window para outra coisa?\");\n                if (window.profiling == true) var start = Date.now();\n                maps[mappos].draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de Zoom/Pan (segundos):' + (end - start) / 1000);\n                }\n            });\n\n            this.setupOnclick(mappos);\n        }\n    }, {\n        key: 'setupOnclick',\n        value: function setupOnclick(mappos) {\n            console.log(\"@Rui: profiling mudar de window para? | Rtree e KdTree\");\n            maps[mappos].map.onEvent('click', function (e) {\n                if (window.profiling == true) var start = Date.now();\n                var lat = e.latlng.lat;\n                var lon = e.latlng.lng;\n\n                if (maps[mappos].rtree != undefined) {\n                    var bool = maps[0].rtree.search(lon, lat);\n                    if (bool == undefined) return;else {\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s); //todo\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n                if (maps[mappos].kdtree != undefined) {\n\n                    var nearest = maps[mappos].kdtree.nearest({ lat: lat, lon: lon }, 1, 128 / 2 ** (map.getZoom() * 2));\n                    if (nearest.length <= 0) return;else {\n                        var bool = nearest[0][0];\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s);\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de um click (segundos): ' + (end - start) / 1000);\n                }\n            });\n        }\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var result = [];\n            for (var a = 0; a < this.aesthetics.length; a++) {\n                if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true) result.push(a);\n            }\n            return result;\n        }\n    }, {\n        key: 'loadOptions',\n        value: function loadOptions(options, bgmap) {\n            if (options.customMapService == true) this.map = bgmap;else this.map = new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (options.loader != false) this.loader();\n\n            if (options.showPropertiesOnClick == true) {\n                this.showPropertiesOnClick = null;\n                //append on bgmap object\n            } else if (options.showPropertiesOnClick == false) {\n                //nada\n            } else if (options.showPropertiesOnClick != undefined) {\n                this.showPropertiesOnClick = options.showPropertiesOnClick;\n            }\n            this.alpha = options.alpha != undefined ? options.alpha : 0.8;\n            this.interactive = options.interactive == undefined ? true : !options.interactive;\n            this.attr = options.attr;\n            this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;\n            this.maxfeatures = options.maxFeatures;\n            this.breaks = options.classBreaks;\n            this.colorscheme = options.colorScheme;\n            this.numberofclasses = options.numberOfClasses;\n            this.algorithm = options.classBreaksMethod;\n            this.legendOnClickCall = options.legendOnClickFunction;\n            this.mapOnClickCall = options.mapOnClickFunction;\n            this.minuend = options.minuend;\n            this.subtrahend = options.subtrahend;\n            this.legendTitle = options.legendTitle != undefined ? options.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n            this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            this.map.loader();\n        }\n    }, {\n        key: 'drawHeatPoints',\n        value: function drawHeatPoints(aes) {\n            var gl = this._webgl.gl;\n\n            if (gl == null) return;\n            gl.useProgram(this._webgl.heatmapProgram[0]);\n            var matrixProjection = new Float32Array(16);\n\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n\n            gl.blendFunc(gl.ONE, gl.ONE);\n\n            var currentZoom = map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'position');\n            var deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'delta');\n            var intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'intensity');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'aPointSize');\n\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            gl.enableVertexAttribArray(vertexCoordLocation);\n            gl.enableVertexAttribArray(deltaLocation);\n            gl.enableVertexAttribArray(intensityLoc);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);\n            gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);\n            gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);\n            gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);\n\n            console.log(aes._allFeatures[0]._points[0].numItems);\n            gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);\n\n            gl.useProgram(this._webgl.heatmapProgram[1]);\n\n            gl.disable(gl.BLEND);\n\n            //console.log(\"fase 1 concluida\");\n\n            var canvas = document.getElementById('mapCanvas' + this.id);\n\n            var source = gl.createTexture();\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, source);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n\n            function isPowerOf2(value) {\n                return (value & value - 1) == 0;\n            };\n\n            function steupTextureFilteringAndMips(width, height, gl) {\n                if (isPowerOf2(width) && isPowerOf2(height)) {\n                    // the dimensions are power of 2 so generate mips and turn on \n                    // tri-linear filtering.\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                } else {\n                    // at least one of the dimensions is not a power of 2 so set the filtering\n                    // so WebGL will render it.\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n            };\n\n            steupTextureFilteringAndMips(canvas.width, canvas.height, gl);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            var vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n            var buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            var positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], 'position');\n            var sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], 'source');\n            gl.enableVertexAttribArray(positionLoc);\n            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.uniform1i(sourceLoc, 0);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            gl.disableVertexAttribArray(positionLoc);\n            //defaults to general program\n            //console.log(\"fase 2 concluida\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'getNumberOfPolygons',\n        value: function getNumberOfPolygons() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                for (var z = 0; z < this.aesthetics[i]._features.length; z++) {\n                    count += this.aesthetics[i]._features[z]._triangles.length;\n                }\n            }\n            return count;\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL01hcC5qcz8xZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJHTWFwV3JhcHBlciB9IGZyb20gJy4vQkdNYXBXcmFwcGVyJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKiBcclxuICogRVM1IGxpYnJhcmllcyBjYW4gYmUgdXNlZCBlaXRoZXIgd2l0aCBcclxuICogMSlpbXBvcnQgaWYgdGhleSBhcmUganVzdCBmdW5jdGlvbnMgb3IgaW4gdGhlIGNhc2Ugb2YgcnRyZWUgYW5kIGt0cmVlIGEgXHJcbiAqIHdlYnBhY2sgbG9hZGVyIGlzIG5lZWRlZCBcInNjcmlwdC1sb2FkZXJcIlwiIGNhbiBkbyB0aGF0LlxyXG4gKiAyKSBBZGRlZCBhcyA8c2NyaXB0PiB0YWcgb24gaW5kZXguaHRtbCBmaWxlXHJcbiAqIFRoZSBmb3JtZXIgYXMgY2hvb3Nlbi5cclxuaW1wb3J0IGNocm9tYSBmcm9tICcuLi8uLi9saWIvY2hyb21hLm1pbic7XHJcbmltcG9ydCBlYXJjdXQgZnJvbSAnLi4vLi4vbGliL2VhcmN1dCdcclxuaW1wb3J0IHtQb2x5Z29uTG9va3VwfSBmcm9tICcuLi8uLi9saWIvcnRyZWUnO1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgdGhlIE1hcCBjbGFzcyB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG1hcC5cclxuICogRWFjaCBtYXAgaGFzIGEgZ3JvdXAgb2YgZnVuY3Rpb25zIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXAgY29uc3RydWN0b3IgY2FsbGVkIC0+IHN1cGVyKClcIilcclxuICAgICAgICAvKiByZXR1cm4gdGhpczsqLyAvL0BUT0RPIFJlbW92ZSBpc250IGRvaW5nIGFueXRoaW5nPyBvciBpcyBpdCBzYXZpbmcgdGhlIDMgcGFyYW1ldGVycz9cclxuICAgIH1cclxuXHJcbiAgICBwcm9ncmFtKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2dyYW0gPSB0aGlzLl93ZWJnbC5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW0gPSBbXTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlX2NvZGUgPSB0aGlzLmdlbmVyYXRlU2hhZGVycygpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuVkVSVEVYX1NIQURFUiwgc291cmNlX2NvZGUudmVydGV4LCB0aGlzLl93ZWJnbCk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuRlJBR01FTlRfU0hBREVSLCBzb3VyY2VfY29kZS5mcmFnbWVudCwgdGhpcy5fd2ViZ2wpO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5hdHRhY2hTaGFkZXIodGhpcy5fd2ViZ2wucHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3dlYmdsLnByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmxpbmtQcm9ncmFtKHRoaXMuX3dlYmdsLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wucHJvZ3JhbSk7XHJcblxyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzaGFkZXIodHlwZSwgc291cmNlX2NvZGUsIF93ZWJnbCkgeyAvL0FkZGVkIEhFUkUgYnkgUnVpXHJcbiAgICAgICAgdmFyIHNoYWRlciA9IF93ZWJnbC5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcblxyXG4gICAgICAgIF93ZWJnbC5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2VfY29kZSk7XHJcbiAgICAgICAgX3dlYmdsLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzaGFkZXIgXCIgKyAodHlwZS52YWx1ZU9mKCkgPT0gMzU2MzMgPyBcInZlcnRleFwiIDogXCJmcmFnbWVudFwiKSArIFwiOiBcIiArIF93ZWJnbC5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG5cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlU2hhZGVycygpIHsgLy9BZGRlZCBIRVJFIGJ5IFJ1aSBAVE9ETyBSZWZhY3RvciB0byB1c2UgRVM2IGBgIGluc3RlYWQgb2YgKz1cclxuICAgICAgICAvL2dlbmVyYWxcclxuXHJcbiAgICAgICAgbGV0IHZlcnRleFNvdXJjZUNvZGUgPSBcIiBhdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb29yZDsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0YXR0cmlidXRlIGZsb2F0IGFQb2ludFNpemU7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRhdHRyaWJ1dGUgZmxvYXQgYV9vcGFjaXR5OyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHR2YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgLy92ZXJ0ZXhTb3VyY2VDb2RlKz0gXCJcXG5cdHZhcnlpbmcgdmVjNCB1X2NvbG9yOyBcIiA7IC8vZGVsZXRlXHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0dm9pZCBtYWluKCkge1wiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0Z2xfUG9zaXRpb24gPSAocHJvamVjdGlvbiAqIHZlcnRleENvb3JkKTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0XHRnbF9Qb2ludFNpemUgPSBhUG9pbnRTaXplOyB2X29wYWNpdHkgPSBhX29wYWNpdHk7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG59XCI7XHJcblxyXG4gICAgICAgIGxldCBmcmFnbWVudFNvdXJjZUNvZGUgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR1bmlmb3JtIHZlYzQgdV9jb2xvcjtcIjsvL3VuaWZvcm1cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0dmFyeWluZyBmbG9hdCB2X29wYWNpdHk7IFwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcbiBcdFx0dW5pZm9ybSBmbG9hdCBpc1BvaW50O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR2b2lkIG1haW4oKXtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCBib3JkZXIgPSAwLjU7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgcmFkaXVzID0gMC41O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGZsb2F0IGNlbnRlckRpc3QgPSBsZW5ndGgoZ2xfUG9pbnRDb29yZCAtIDAuNSk7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgYWxwaGE7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0aWYgKHVfY29sb3JbM10gPT0gLTEuMCl7XCI7ICAgLy91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRhbHBoYSA9ICB2X29wYWNpdHkgKiBzdGVwKGNlbnRlckRpc3QsIHJhZGl1cyk7XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0fVwiOy8vdW5uZWNlc3Nhcnk/P1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGVsc2V7XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRhbHBoYSA9ICB1X2NvbG9yWzNdICogc3RlcChjZW50ZXJEaXN0LCByYWRpdXMpO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdH1cIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRpZihpc1BvaW50ID09IDEuMCApe1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGlmIChhbHBoYSA8IDAuMSkgZGlzY2FyZDtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodV9jb2xvclswXSwgdV9jb2xvclsxXSwgdV9jb2xvclsyXSwgYWxwaGEpO31cIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG4gXHRcdFx0ZWxzZVwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yWzBdLCB1X2NvbG9yWzFdLCB1X2NvbG9yWzJdLCB1X2NvbG9yWzNdKTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0fVwiO1xyXG5cclxuICAgICAgICByZXR1cm4geyB2ZXJ0ZXg6IHZlcnRleFNvdXJjZUNvZGUsIGZyYWdtZW50OiBmcmFnbWVudFNvdXJjZUNvZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBZXN0aGV0aWMoYWVzKSB7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzLnB1c2goYWVzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRBZXN0aGV0aWMoaWQsIGFlcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaWQgPT0gYWVzdGhldGljc1tpXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgYWVzdGhldGljc1tpXSA9IGFlcztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcbiAgICAgICAgY29uc3QgbGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbGVnZW5kRGl2LmlkID0gYGxlZ2VuZERpdiR7dGhpcy5pZH1gO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgLy9sZWdlbmREaXYuc3R5bGUuaGVpZ2h0ID0gMjAwOy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLndpZHRoID0gMjUwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYm90dG9tID0gMjA7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLnJpZ2h0ID0gMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSAnYmxhY2snO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXIgPSAnc29saWQnO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xyXG4gICAgICAgIGNvbnN0IHRodmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIGNvbnN0IHRoY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIC8vdGh2YWx1ZS5zdHlsZS53aWR0aCA9IDEyNTtcclxuICAgICAgICB0YWJsZS5zdHlsZS56SW5kZXggPSBcIjIwMDBcIjtcclxuICAgICAgICB0aGNvbG9yLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRoY29sb3IpO1xyXG4gICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHRodmFsdWUpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50YWVzIG9mIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICAvL2lmKGN1cnJlbnRhZXMuX2ZlYXR1cmVzLmxlbmd0aCA+IDAgfHwgY3VycmVudGFlcy5fYWxsRmVhdHVyZXMubGVuZ3RoID4gMCl7XHJcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBwdGV4dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcclxuICAgICAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VycmVudGFlcy5yYW5nZVswXSA9PT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske2N1cnJlbnRhZXMucmFuZ2VbMF19LCAke2N1cnJlbnRhZXMucmFuZ2VbMV19W2ApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3VycmVudGFlcy5yYW5nZVswXSk7XHJcbiAgICAgICAgICAgIHB0ZXh0LmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZChwdGV4dCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzNdfSlgO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKHJnYmMpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ10gPSByZ2JjO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSAyNTsvLyhtYXBDYW52YXMuaGVpZ2h0IC8gMTApO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IDgwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgY29sb3IuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG5cclxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNvbG9yKTtcclxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuXHJcbiAgICAgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgICAgIC8vfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgbGVnZW5kRGl2LmFwcGVuZENoaWxkKHRhYmxlKTtcclxuICAgICAgICB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChsZWdlbmREaXYpO1xyXG4gICAgfVxyXG5cclxuICAgIHByZVByb2Nlc3NEYXRhKGdlb2pzb24sIG51bWJlck9mLCBhbGdvcml0aG0sIGNvbG9yc2NoZW1lKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGFlc2FycmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IFtdO1xyXG4gICAgICAgIGxldCBicmVha3M7XHJcbiAgICAgICAgbGV0IGZjb2xvcjtcclxuICAgICAgICBmb3IgKGxldCBnID0gMDsgZyA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoICYmICh0aGlzLm1heGZlYXR1cmVzID09IHVuZGVmaW5lZCB8fCBnIDwgdGhpcy5tYXhmZWF0dXJlcyk7IGcrKykge1xyXG4gICAgICAgICAgICBpZiAoZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0gIT0gbnVsbCAmJiB0eXBlb2YgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0gPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5tYXgsIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBpZiAoIXN0cmluZ3MuaW5jbHVkZXMoZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pKVxyXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3MucHVzaChnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoID4gMCkgey8vcXVhbnRpdGF0aXZlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJyZWFrcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChudW1iZXJPZiA+IDEpXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtzID0gdGhpcy5jYWxjQ2xhc3NCcmVha3ModmFsdWVzLCBhbGdvcml0aG0sIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBicmVha3MgPSBbdGhpcy5taW4sIHRoaXMubWF4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IHRoaXMuYnJlYWtzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChicmVha3MubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgICAgICAgZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKS5jb2xvcnMoYnJlYWtzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmVha3MubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY2hyb21hKGZjb2xvcltpXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT0gYnJlYWtzLmxlbmd0aCAtIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgdGhpcy5hbHBoYV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1tpXSwgYnJlYWtzW2kgKyAxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgdGhpcy5hbHBoYV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1tpXSwgYnJlYWtzW2kgKyAxXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZXMub3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb2xvciA9IGNocm9tYShjb2xvcnNjaGVtZVswXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzWzBdLCBicmVha3NbMV1dKTtcclxuICAgICAgICAgICAgICAgIGFlcy5vdXRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGVsc2Ugey8vcXVhbGl0YXRpdmVcclxuICAgICAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gc3RyaW5ncztcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sb3JzY2hlbWUgPT09ICdzdHJpbmcnKSB7Ly9zdHJpbmdcclxuICAgICAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhicmVha3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgeyAvL2FycmF5XHJcbiAgICAgICAgICAgICAgICAgICAgZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKS5jb2xvcnMoYnJlYWtzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyZWFrcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGNocm9tYShmY29sb3JbaV0pLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIDFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFtzdHJpbmdzW2ldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBhZXNhcnJheTtcclxuICAgICAgICAvL3JldHVybiBhZXNhcnJheTtcclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNhbGNDbGFzc0JyZWFrcyh2YWx1ZXMsIGFsZ29yaXRobSwgbnVtYmVyT2YpIHtcclxuICAgICAgICBsZXQgYnJlYWtzO1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VxdWlkaXN0YW50JzpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAnZScsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAncXVhbnRpbGUnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdxJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdrLW1lYW5zJzpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAnaycsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAncScsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnJlYWtzO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmNoZWNrUHJvcGVydHkocHJvcGVydGllc1t0aGlzLmFlc3RoZXRpY3NbaV0uZ2V0QXR0cigpXSkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZXN0aGV0aWNzW2ldLmFkZEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRPRE86IGZlYXR1cmUgZG9lcyBub3QgZml0IGludG8gYW55IG9mIHRoZSBhZXN0aGV0aWNzIGRlZmluZWQuXFxuIFZhbHVlOiBcIiArIHByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEdyb3VwZWRGZWF0dXJlKGlkYWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG5cclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3NbaWRhZXNdLmFkZEdyb3VwZWRGZWF0dXJlKG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpIHtcclxuXHJcbiAgICAgICAgYWxlcnQoXCJkcmF3KCkgbm90IGltcGxlbWVudGVkXCIpO1xyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3NQb2x5Z29uKHBvbHlnb24pIHtcclxuXHJcbiAgICAgICAgaWYgKHBvbHlnb24uZ2VvbWV0cnkudHlwZSA9PSBcIlBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB2YXIgb3V0c2lkZXBvbHlnb24gPSBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xyXG5cclxuICAgICAgICAgICAgdmFyIGluc2lkZXBvbHlnb25zID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgLy90b2RvIGluc2lkZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAvL2luc2lkZXBvbHlnb25zLnB1c2gocG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tpXVtrXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHRlbXBWZXJ0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBvdXQgPSAwOyBvdXQgPCBvdXRzaWRlcG9seWdvbi5sZW5ndGggLSAxOyBvdXQrKykge1xyXG4gICAgICAgICAgICAgICAgdGVtcFZlcnRzLnB1c2gob3V0c2lkZXBvbHlnb25bb3V0XVswXSwgb3V0c2lkZXBvbHlnb25bb3V0XVsxXSk7XHJcbiAgICAgICAgICAgICAgICBfdmVydGV4Y291bnQgKz0gKG91dHNpZGVwb2x5Z29uLmxlbmd0aCArIDEpIC8gMjtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJsb246IFwiICsgb3V0c2lkZXBvbHlnb25bb3V0XVswXSArIFwiIGxhdDogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICB2YXIgdHJpYW5nbGVzX3ZlcnQgPSBlYXJjdXQodGVtcFZlcnRzKTtcclxuICAgICAgICAgICAgX3RyaWNvdW50ICs9ICh0cmlhbmdsZXNfdmVydC5sZW5ndGggLyAzKTtcclxuICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0ZXg6IHRlbXBWZXJ0cyB9KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgZWxzZSBpZiAocG9seWdvbi5nZW9tZXRyeS50eXBlID09IFwiTXVsdGlQb2x5Z29uXCIpIHtcclxuICAgICAgICAgICAgdmFyIHBvbHlhcnJheSA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgb3V0c2lkZXBvbHlnb24gPSBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBpbnNpZGVwb2x5Z29ucyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy90b2RvIGluc2lkZSBwb2x5Z29uXHJcbiAgICAgICAgICAgICAgICAgICAgaW5zaWRlcG9seWdvbnMucHVzaChwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2tdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZhciB0ZW1wVmVydHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXhjb3VudCArPSBvdXRzaWRlcG9seWdvbi5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBvdXQgPSAwOyBvdXQgPCBvdXRzaWRlcG9seWdvbi5sZW5ndGggLSAxOyBvdXQrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRlbXBWZXJ0cy5wdXNoKG91dHNpZGVwb2x5Z29uW291dF1bMF0sIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwibG9uOiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMF0gKyBcIiBsYXQ6IFwiICsgb3V0c2lkZXBvbHlnb25bb3V0XVsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgdHJpYW5nbGVzX3ZlcnQgPSBlYXJjdXQodGVtcFZlcnRzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL3ZhciB0ZW1wID0gZWFyY3V0LmZsYXR0ZW4ocG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAvL3ZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wLnZlcnRpY2VzLCB0ZW1wLmhvbGVzLCB0ZW1wLmRpbWVuc2lvbnMpO1xyXG4gICAgICAgICAgICAgICAgX3RyaWNvdW50ICs9ICh0cmlhbmdsZXNfdmVydC5sZW5ndGggLyAzKTtcclxuICAgICAgICAgICAgICAgIHBvbHlhcnJheS5wdXNoKHsgdHJpYW5nbGVzOiB0cmlhbmdsZXNfdmVydCwgdmVydGV4OiB0ZW1wVmVydHMgfSk7XHJcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKHBvbHlhcnJheSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcG9seWFycmF5O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc0RhdGEoZ2VvanNvbikge1xyXG5cclxuICAgICAgICB0aGlzLmxvYWRHZW9KU09OKGdlb2pzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUFuZEluc2VydEZlYXR1cmUoaWQsIGdlb21ldHJ5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAodGhpcy5taW51ZW5kICE9IHVuZGVmaW5lZCAmJiB0aGlzLnN1YnRyYWhlbmQgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwcm9wZXJ0aWVzW3RoaXMubWludWVuZF0gPT0gJ251bWJlcidcclxuICAgICAgICAgICAgJiYgcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdID09ICdudW1iZXInXHJcbiAgICAgICAgICAgICYmIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvcGVydGllc1t0aGlzLmF0dHJdID0gcHJvcGVydGllc1t0aGlzLm1pbnVlbmRdIC0gcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2x5Z29uXCIgfHwgZ2VvbWV0cnkudHlwZSA9PSBcIk11bHRpUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUG9seWdvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29ucyA9IHRoaXMucHJvY2Vzc1BvbHlnb24oeyBnZW9tZXRyeSwgcHJvcGVydGllcyB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCb3JkZXJzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmlhbmdsZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyVCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJCID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvbHlnb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlhbmdsZXNwb2x5Z29uID0gcG9seWdvbnNbal0udHJpYW5nbGVzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyID0gcG9seWdvbnNbal0udmVydGV4O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFRyaWFuZ2xlc1tqXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJvcmRlcnNbal0gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgdHJpYW5nbGVzcG9seWdvbi5sZW5ndGg7IGgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShib3JkZXJbdHJpYW5nbGVzcG9seWdvbltoXSAqIDJdLCBib3JkZXJbdHJpYW5nbGVzcG9seWdvbltoXSAqIDIgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyaWFuZ2xlc1tqXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA9PSB0cmlhbmdsZXNwb2x5Z29uLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyVC5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRUcmlhbmdsZXNbal0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJUW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyVFtqXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclRbal0ubnVtSXRlbXMgPSB2ZXJ0QXJyYXkubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYm9yZGVyLmxlbmd0aDsgeSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGJvcmRlclt5XSwgYm9yZGVyW3kgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJvcmRlcnNbal0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT0gYm9yZGVyLmxlbmd0aCAtIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQi5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRCb3JkZXJzW2pdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyQltqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJbal0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCW2pdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvL3BvbHlnb25cclxuICAgICAgICAgICAgdGhpcy5pbnNlcnRGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCBidWZmZXJULCBidWZmZXJCLCBbXSk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PSBcIlBvaW50XCIgJiYgdGhpcy5keW5hbWljID09IHRydWUpIHtcclxuICAgICAgICAgICAgLy9kdW1cclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzWzBdID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xyXG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzWzBdLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclAgPSBbXTtcclxuICAgICAgICAgICAgYnVmZmVyUC5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgIHZhciB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRQb2ludHNbMF0pO1xyXG5cclxuICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJQWzBdKTtcclxuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgYnVmZmVyUFswXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgIGJ1ZmZlclBbMF0ubnVtSXRlbXMgPSB2ZXJ0QXJyYXkubGVuZ3RoIC8gMjtcclxuXHJcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgW10sIFtdLCBidWZmZXJQKTtcclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVwb2ludHMgPT0gbnVsbCB8fCB0aGlzLnRyZWVwb2ludHMgPT0gdW5kZWZpbmVkKSB0aGlzLnRyZWVwb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy50cmVlcG9pbnRzLnB1c2goeyBsb246IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBsYXQ6IGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBwcm9wZXJ0aWVzIH0pO1xyXG5cclxuXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09IFwiUG9pbnRcIiAmJiB0aGlzLmR5bmFtaWMgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy9kZWJ1Z2dlcjtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHMgPT0gbnVsbCB8fCB0aGlzLnRlbXBQb2ludHMgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBQb2ludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW1wUG9pbnRzW2FdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFlc2FycmF5cyA9IHRoaXMuZml0RmVhdHVyZShwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXNhcnJheXMubGVuZ3RoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVtcFBvaW50c1thZXNhcnJheXNbeV1dLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVwb2ludHMgPT0gbnVsbCkgdGhpcy50cmVlcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cy5wdXNoKHsgbG9uOiBnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgbGF0OiBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSwgcHJvcGVydGllcyB9KTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkVHJlZXMoZ2VvanNvbikge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMudGVtcFBvaW50cyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHQgPSAwOyB0IDwgdGhpcy50ZW1wUG9pbnRzLmxlbmd0aDsgdCsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50ZW1wUG9pbnRzW3RdLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBidWZmZXJQID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUC5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnRlbXBQb2ludHNbdF0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnbC5mc2l6ZSA9IHZlcnRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyUFswXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJQWzBdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgICAgICAgICBidWZmZXJQWzBdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRHcm91cGVkRmVhdHVyZSh0LCBbXSwgW10sIGJ1ZmZlclApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKGdlb2pzb24pXHJcbiAgICAgICAgaWYgKHRoaXMudHJlZXBvaW50cyAhPSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmtkdHJlZSA9IG5ldyBrZFRyZWUodGhpcy50cmVlcG9pbnRzLCAoYSwgYikgPT4gKGEubG9uIC0gYi5sb24pICoqIDIgKyAoYS5sYXQgLSBiLmxhdCkgKiogMiwgW1wibG9uXCIsIFwibGF0XCIsIFwicHJvcGVydGllc1wiXSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUG9seWdvbnMgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5ydHJlZSA9IG5ldyBQb2x5Z29uTG9va3VwKGdlb2pzb24pO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQFJ1aSBMT09LIEkgV0FTIFJFTU9WRURcIik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEdlb0pTT04oZ2VvanNvbikge1xyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggJiYgKHRoaXMubWF4ZmVhdHVyZXMgPT0gdW5kZWZpbmVkIHx8IGcgPCB0aGlzLm1heGZlYXR1cmVzKTsgZysrKSB7XHJcbiAgICAgICAgICAgIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1snX2dpc3BsYXlpZCddID0gZztcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ddLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEluc2VydEZlYXR1cmUoZywgZ2VvbWV0cnksIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1aWxkVHJlZXMoZ2VvanNvbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLm1hcC5jcmVhdGVDYW52YXModGhpcy5pZCk7XHJcblxyXG4gICAgICAgIC8vaW5pdCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wgPSB7XHJcbiAgICAgICAgICAgIGdsOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5wcm9qZWN0aW9uLnNldChbMiAvIGNhbnZhcy53aWR0aCwgMCwgMCwgMCwgMCwgLTIgLyBjYW52YXMuaGVpZ2h0LCAwLCAwLCAwLCAwLCAwLCAwLCAtMSwgMSwgMCwgMV0pO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5vZmZzZXRXaWR0aCwgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5kaXNhYmxlKHRoaXMuX3dlYmdsLmdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBnZXROdW1iZXJPZkZlYXR1cmVzKCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY291bnQgKz0gdGhpcy5hZXN0aGV0aWNzW2ldLl9mZWF0dXJlcy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICBzY2FsZVByb2plY3Rpb24obWF0cml4LCBzY2FsZVgsIHNjYWxlWSkge1xyXG4gICAgICAgIC8vIHNjYWxpbmcgeCBhbmQgeSwgd2hpY2ggaXMganVzdCBzY2FsaW5nIGZpcnN0IHR3byByb3dzIG9mIG1hdHJpeFxyXG4gICAgICAgIG1hdHJpeFswXSAqPSBzY2FsZVg7XHJcbiAgICAgICAgbWF0cml4WzFdICo9IHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMl0gKj0gc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFszXSAqPSBzY2FsZVg7XHJcblxyXG4gICAgICAgIG1hdHJpeFs0XSAqPSBzY2FsZVk7XHJcbiAgICAgICAgbWF0cml4WzVdICo9IHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbNl0gKj0gc2NhbGVZO1xyXG4gICAgICAgIG1hdHJpeFs3XSAqPSBzY2FsZVk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXgsIHR4LCB0eSkge1xyXG4gICAgICAgIC8vIHRyYW5zbGF0aW9uIGlzIGluIGxhc3Qgcm93IG9mIG1hdHJpeFxyXG4gICAgICAgIG1hdHJpeFsxMl0gKz0gbWF0cml4WzBdICogdHggKyBtYXRyaXhbNF0gKiB0eTtcclxuICAgICAgICBtYXRyaXhbMTNdICs9IG1hdHJpeFsxXSAqIHR4ICsgbWF0cml4WzVdICogdHk7XHJcbiAgICAgICAgbWF0cml4WzE0XSArPSBtYXRyaXhbMl0gKiB0eCArIG1hdHJpeFs2XSAqIHR5O1xyXG4gICAgICAgIG1hdHJpeFsxNV0gKz0gbWF0cml4WzNdICogdHggKyBtYXRyaXhbN10gKiB0eTtcclxuICAgIH1cclxuXHJcbiAgICBsYXRMb25nVG9QaXhlbFhZKGxvbmdpdHVkZSwgbGF0aXR1ZGUpIHtcclxuICAgICAgICBjb25zdCBwaV8xODAgPSBNYXRoLlBJIC8gMTgwLjA7XHJcbiAgICAgICAgY29uc3QgcGlfNCA9IE1hdGguUEkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHNpbkxhdGl0dWRlID0gTWF0aC5zaW4obGF0aXR1ZGUgKiBwaV8xODApO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsWSA9ICgwLjUgLSBNYXRoLmxvZygoMSArIHNpbkxhdGl0dWRlKSAvICgxIC0gc2luTGF0aXR1ZGUpKSAvIChwaV80KSkgKiAyNTY7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxYID0gKChsb25naXR1ZGUgKyAxODApIC8gMzYwKSAqIDI1NjtcclxuXHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSB7IHg6IHBpeGVsWCwgeTogcGl4ZWxZIH07XHJcblxyXG4gICAgICAgIHJldHVybiBwaXhlbDtcclxuICAgIH1cclxuXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1RyaWFuZ2xlcyhhZXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUG9pbnRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnaXNQb2ludCcpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihpc1BvaW50TG9jYXRpb24sIDAuMCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICd2ZXJ0ZXhDb29yZCcpO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzNdKTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXMuX2ZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlc1t5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29vcmRMb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvb3JkTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiAyLCAwKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29sb3JMb2NhdGlvbik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBkcmF3Qm9yZGVycyhhZXMpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAncHJvamVjdGlvbicpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvamVjdGlvbkxvY2F0aW9uLCBmYWxzZSwgbWF0cml4UHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdhUG9pbnRTaXplJyk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliMWYodmVydGV4U2l6ZUxvY2F0aW9uLCBwb2ludFNpemUpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiAgRHJhdyBQb2x5Z29ucycgSW50ZXJpb3JcclxuICAgICAgICAgKiAgKiovXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk51bWVybyBkZSBCdWZmZXJzOiBcIiwgYnVmZmVycy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtNGYodmVydGV4Q29sb3JMb2NhdGlvbiwgYWVzLnN0cm9rZUNvbG9yWzBdIC8gMjU1LCBhZXMuc3Ryb2tlQ29sb3JbMV0gLyAyNTUsIGFlcy5zdHJva2VDb2xvclsyXSAvIDI1NSwgYWVzLnN0cm9rZUNvbG9yWzNdKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXMuX2ZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgYWVzLl9mZWF0dXJlc1tpXS5fYm9yZGVycy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORV9MT09QLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzW3ldLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdQb2ludHMoYWVzKSB7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHJcbiAgICAgICAgLy9nbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAvL2dsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNC4wICsgYWVzLnBvaW50U2l6ZSwgYWVzLnBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAncHJvamVjdGlvbicpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvamVjdGlvbkxvY2F0aW9uLCBmYWxzZSwgbWF0cml4UHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdhUG9pbnRTaXplJyk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliMWYodmVydGV4U2l6ZUxvY2F0aW9uLCBwb2ludFNpemUpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzNdKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoICYmIHRoaXMuZHluYW1pYyA9PSB0cnVlOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgLy8xKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyB0aGlzLmR5bmFtaWMgPT0gZmFsc2UgJiYgYWVzLl9hbGxGZWF0dXJlcyAhPSBudWxsICYmIGkgPCBhZXMuX2FsbEZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fYWxsRmVhdHVyZXNbaV0uX3BvaW50c1t5XSk7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29vcmRMb2NhdGlvbik7XHJcbiAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvb3JkTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiAyLCAwKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydGV4Q29sb3JMb2NhdGlvbik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgIC8vZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRV9TVFJJUCwgMCwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldLm51bUl0ZW1zLTIpO1x0XHJcbiAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3Q29udGludW91c1BvbHlnb25zKGFlcykge1xyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgLy9nbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIC8vZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUG9pbnRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnaXNQb2ludCcpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihpc1BvaW50TG9jYXRpb24sIDAuMCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICd2ZXJ0ZXhDb29yZCcpO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXMuX2ZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCB1Y29sb3I7XHJcbiAgICAgICAgICAgIGxldCBjb2xvcjtcclxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGFlcy5fZmVhdHVyZXNbaV0uX3Byb3BlcnRpZXNbdGhpcy5hdHRyXTtcclxuICAgICAgICAgICAgaWYgKGRpZmYgPT0gMClcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUpLnJnYigpO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgKyBkaWZmIC8gdGhpcy5tYXggLyAyKS5yZ2IoKTtcclxuXHJcblxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvciA9IGFlcy5maWxsQ29sb3IoMC41IC0gZGlmZiAvIHRoaXMubWluIC8gMikucmdiKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHVjb2xvciA9IFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXTtcclxuXHJcbiAgICAgICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCB1Y29sb3JbMF0gLyAyNTUsIHVjb2xvclsxXSAvIDI1NSwgdWNvbG9yWzJdIC8gMjU1LCB0aGlzLmFscGhhKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1Byb3BvcmNpb25hbFBvaW50cyhhZXMpIHtcclxuXHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAoZ2wgPT0gbnVsbCkgcmV0dXJuO1xyXG4gICAgICAgIGNvbnN0IG1hdHJpeFByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuXHJcblxyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuXHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHByb2plY3Rpb25Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAncHJvamVjdGlvbicpO1xyXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYocHJvamVjdGlvbkxvY2F0aW9uLCBmYWxzZSwgbWF0cml4UHJvamVjdGlvbik7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICd2ZXJ0ZXhDb29yZCcpO1xyXG5cclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4Q29sb3JMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCBcInVfY29sb3JcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGlzUG9pbnRMb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnaXNQb2ludCcpO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xZihpc1BvaW50TG9jYXRpb24sIDEuMCk7XHJcblxyXG4gICAgICAgIC8qKiBcclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiAgRHJhdyBQb2x5Z29ucycgSW50ZXJpb3JcclxuICAgICAgICAgKiAgKiovXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIk51bWVybyBkZSBCdWZmZXJzOiBcIiwgYnVmZmVycy5sZW5ndGgpO1xyXG5cclxuICAgICAgICBnbC51bmlmb3JtNGYodmVydGV4Q29sb3JMb2NhdGlvbiwgYWVzLmZpbGxDb2xvclswXSAvIDI1NSwgYWVzLmZpbGxDb2xvclsxXSAvIDI1NSwgYWVzLmZpbGxDb2xvclsyXSAvIDI1NSwgdGhpcy5hbHBoYSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWMgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgaW4gYWVzLl9mZWF0dXJlcykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB5IGluIGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50cykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wdmFsdWUgPSBwYXJzZUZsb2F0KGFlcy5fZmVhdHVyZXNbaV0uX3Byb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcHBvaW50c2l6ZSA9ICgodGhpcy5tYXhwb2ludHNpemUgLSB0aGlzLm1pbnBvaW50c2l6ZSkgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpICogKHByb3B2YWx1ZSAtIHRoaXMubWluKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDQuMCArIHRlbXBwb2ludHNpemUgKiBjdXJyZW50Wm9vbSAvIDQsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdhUG9pbnRTaXplJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliMWYodmVydGV4U2l6ZUxvY2F0aW9uLCBwb2ludFNpemUpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvb3JkTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiAyLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzW3ldLm51bUl0ZW1zKTtcclxuICAgICAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLm1heCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5taW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtKCk7XHJcbiAgICAgICAgbGV0IG1hcHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChtYXBzW2ldLmlkID09IHRoaXMuaWQpXHJcbiAgICAgICAgICAgICAgICBtYXBwb3MgPSBpO1xyXG4gICAgICAgIHRoaXMubWFwLm9uRXZlbnQoJ21vdmUnLFxyXG4gICAgICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkBSdWk6IG11ZGFyIG8gcHJvZmlsaW5nIGRvIHdpbmRvdyBwYXJhIG91dHJhIGNvaXNhP1wiKVxyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkZSBab29tL1BhbiAoc2VndW5kb3MpOiR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNldHVwT25jbGljayhtYXBwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwT25jbGljayhtYXBwb3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkBSdWk6IHByb2ZpbGluZyBtdWRhciBkZSB3aW5kb3cgcGFyYT8gfCBSdHJlZSBlIEtkVHJlZVwiKVxyXG4gICAgICAgIG1hcHNbbWFwcG9zXS5tYXAub25FdmVudCgnY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGUubGF0bG5nLmxhdDtcclxuICAgICAgICAgICAgY29uc3QgbG9uID0gZS5sYXRsbmcubG5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5ydHJlZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib29sID0gbWFwc1swXS5ydHJlZS5zZWFyY2gobG9uLCBsYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvb2wgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljay5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7bWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpICsgMV19OiAke2Jvb2wucHJvcGVydGllc1ttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYm9vbC5wcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0gIT0gXCJfZ2lzcGxheWlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7a2V5c1tpXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW2tleXNbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uaW50ZXJhY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQocyk7Ly90b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQgJiYgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbChib29sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLmtkdHJlZSAhPSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0ID0gbWFwc1ttYXBwb3NdLmtkdHJlZS5uZWFyZXN0KHsgbGF0LCBsb24gfSwgMSwgMTI4IC8gKCgyICoqIChtYXAuZ2V0Wm9vbSgpICogMikpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdC5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9vbCA9IG5lYXJlc3RbMF1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhib29sLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXSAhPSBcIl9naXNwbGF5aWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5pbnRlcmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZCAmJiBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsKGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIHVtIGNsaWNrIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZml0RmVhdHVyZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1thXS5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbdGhpcy5hZXN0aGV0aWNzW2FdLmdldEF0dHIoKV0pID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmN1c3RvbU1hcFNlcnZpY2UgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBiZ21hcDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IEJHTWFwV3JhcHBlcihiZ21hcCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVyICE9IGZhbHNlKVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlcigpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dQcm9wZXJ0aWVzT25DbGljayA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vYXBwZW5kIG9uIGJnbWFwIG9iamVjdFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvL25hZGFcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID0gb3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxwaGEgOiAwLjg7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuaW50ZXJhY3RpdmUgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICFvcHRpb25zLmludGVyYWN0aXZlO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IG9wdGlvbnMuYXR0cjtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLm1lbW9yeVNhdmVyID09IHVuZGVmaW5lZCA/IGZhbHNlIDogIW9wdGlvbnMubWVtb3J5U2F2ZXI7XHJcbiAgICAgICAgdGhpcy5tYXhmZWF0dXJlcyA9IG9wdGlvbnMubWF4RmVhdHVyZXM7XHJcbiAgICAgICAgdGhpcy5icmVha3MgPSBvcHRpb25zLmNsYXNzQnJlYWtzO1xyXG4gICAgICAgIHRoaXMuY29sb3JzY2hlbWUgPSBvcHRpb25zLmNvbG9yU2NoZW1lO1xyXG4gICAgICAgIHRoaXMubnVtYmVyb2ZjbGFzc2VzID0gb3B0aW9ucy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmNsYXNzQnJlYWtzTWV0aG9kO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT25DbGlja0NhbGwgPSBvcHRpb25zLmxlZ2VuZE9uQ2xpY2tGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLm1hcE9uQ2xpY2tDYWxsID0gb3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5taW51ZW5kID0gb3B0aW9ucy5taW51ZW5kO1xyXG4gICAgICAgIHRoaXMuc3VidHJhaGVuZCA9IG9wdGlvbnMuc3VidHJhaGVuZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZFRpdGxlID0gb3B0aW9ucy5sZWdlbmRUaXRsZSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmxlZ2VuZFRpdGxlIDogKHRoaXMuYXR0ciAhPSB1bmRlZmluZWQgPyB0aGlzLmF0dHIgOiBgJHt0aGlzLm1pbnVlbmR9IC0gJHt0aGlzLnN1YnRyYWhlbmR9YCk7XHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkxlZ2VuZEl0ZW1zID0gb3B0aW9ucy5udW1iZXJPZkxlZ2VuZEl0ZW1zICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVtYmVyT2ZMZWdlbmRJdGVtcyA6IDI7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMubWFwLmxvYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdIZWF0UG9pbnRzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnZGVsdGEnKTtcclxuICAgICAgICBjb25zdCBpbnRlbnNpdHlMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ2ludGVuc2l0eScpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnYVBvaW50U2l6ZScpO1xyXG5cclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbHRhTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGludGVuc2l0eUxvYyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDAgKiAyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbHRhTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCAyICogNCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbnRlbnNpdHlMb2MsIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCA0ICogNCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuXHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0pO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImZhc2UgMSBjb25jbHVpZGFcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzb3VyY2UpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY2FudmFzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb3dlck9mMih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3RldXBUZXh0dXJlRmlsdGVyaW5nQW5kTWlwcyh3aWR0aCwgaGVpZ2h0LCBnbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQb3dlck9mMih3aWR0aCkgJiYgaXNQb3dlck9mMihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGltZW5zaW9ucyBhcmUgcG93ZXIgb2YgMiBzbyBnZW5lcmF0ZSBtaXBzIGFuZCB0dXJuIG9uIFxyXG4gICAgICAgICAgICAgICAgLy8gdHJpLWxpbmVhciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgbm90IGEgcG93ZXIgb2YgMiBzbyBzZXQgdGhlIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gc28gV2ViR0wgd2lsbCByZW5kZXIgaXQuXHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgICAgIHN0ZXVwVGV4dHVyZUZpbHRlcmluZ0FuZE1pcHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCBnbCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMV0pO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0sICdwb3NpdGlvbicpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xaShzb3VyY2VMb2MsIDApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuXHJcblxyXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvYyk7XHJcbiAgICAgICAgLy9kZWZhdWx0cyB0byBnZW5lcmFsIHByb2dyYW1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmFzZSAyIGNvbmNsdWlkYVwiKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROdW1iZXJPZlBvbHlnb25zKCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzW3pdLl90cmlhbmdsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBOzs7Ozs7Ozs7OztBQVdBOzs7O0FBSUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdEJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUEyQkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMURBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQTJEQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBSUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv2.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./Gisplay/Gisplay */ 0);\n\nmodule.exports = {\n    createBGMap: function createBGMap() {\n\n        console.log(\"Start gisplayv2. TESTE workflow2.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        //var data = new Array();\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            //new Choropleth(map, null,options);\n\n            var data = JSON.parse(reader.result);\n            //console.log(data);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            /* console.log(window.map)\r\n             console.log(map)*/\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n}; /**\r\n    * This file is the entry point for the Gisplay API\r\n    *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZ2lzcGxheXYyLmpzPzVlMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBHaXNwbGF5IEFQSVxyXG4gKi9cclxuaW1wb3J0IHtHaXNwbGF5fSBmcm9tICcuL0dpc3BsYXkvR2lzcGxheSdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY3JlYXRlQkdNYXA6IGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydCBnaXNwbGF5djIuIFRFU1RFIHdvcmtmbG93Mi5cIik7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5zdHJlZXRzJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydENob3JvcGxldGg6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJ3aGl0ZVwiLCBcInllbGxvd1wiLCBcIm9yYW5nZVwiLCBcInJlZFwiXVxyXG4gICAgICAgICAgICAsIG51bWJlck9mQ2xhc3NlczogNFxyXG4gICAgICAgICAgICAsIGF0dHI6ICdmMydcclxuICAgICAgICAgICAgLCBsZWdlbmRUaXRsZTogJ0ZhdGFscydcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vdmFyIGRhdGEgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vbmV3IENob3JvcGxldGgobWFwLCBudWxsLG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKGRhdGEpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YXJlYWR0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGRlIGxlaXR1cmEgZG8gZmljaGVpcm86IFwiICsgKGRhdGFyZWFkdGltZXN0YW1wIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgIC8qIGNvbnNvbGUubG9nKHdpbmRvdy5tYXApXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1hcCkqL1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VDaG9yb3BsZXRoKHdpbmRvdy5tYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGdpc3BsYXk6IFwiICsgKERhdGUubm93KCkgLSBkYXRhcmVhZHRpbWVzdGFtcCkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gdG90YWw6IFwiICsgKERhdGUubm93KCkgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH1cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9naXNwbGF5djIuanMiXSwibWFwcGluZ3MiOiI7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBOzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);