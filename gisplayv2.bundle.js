var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 12);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/Gisplay/Legend.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents the Map Legend. 15/03\r\n */\nvar Legend = exports.Legend = function () {\n    /**\r\n     * Creates an instance of Legend class.\r\n     * @param {number} id -  The id of the legend.\r\n     * @param {string} title - The title for the legend.\r\n     * \r\n     * @memberOf Legend\r\n     */\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        /**\r\n         * Title of the Gisplay map Legend.\r\n         * @type {string}\r\n         */\n        this.title = title;\n        this.init(id);\n        return this; //@Rui Remove this\n    }\n\n    /**\r\n     * Appends the legend div element to the map container.\r\n     * @param {*} map \r\n     */\n\n\n    _createClass(Legend, [{\n        key: 'insertLegend',\n        value: function insertLegend(map) {\n            this.legendDiv.appendChild(this.table);\n            map.getContainer().appendChild(this.legendDiv);\n        }\n\n        /**\r\n         * Inserts one row for the Aesthetic object.\r\n         * @param {Aesthetic} currentaes - The Aesthetic object \r\n         * @param {*} mapobj \r\n         */\n\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 2);\n        }\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 1);\n        }\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (currentaes.outer == false) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n            value.appendChild(text);\n\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n            colorDiv.style['backgroundColor'] = rgbc;\n            if (type == 1) {\n                //polygon\n                colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                colorDiv.style.width = 80; //(mapCanvas.width / 10);\n                if (currentaes.strokeColor != null && currentaes != undefined) colorDiv.style['borderColor'] = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type == 2) {\n                //point\n                var size = void 0;\n                if (currentaes.pointSize != null) {\n                    size = Math.max(currentaes.pointSize, 5);\n                } else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (window.profiling == true) var start = Date.now();\n                if (mapobj.legendToggle != false) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade == true) {\n                        this.className += \" _gisplayfade\";\n                    } else {\n                        this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                }\n                if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                mapobj.draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                }\n            };\n\n            this.table.appendChild(row);\n        }\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberof = 5;\n            if (mapobj.aesthetics.length > 5) numberof = mapobj.aesthetics.length;\n            var strcolor = '';\n            for (var i = 0; i < numberof; i++) {\n                var color = mapobj.fcolor(i / numberof).rgb();\n                strcolor += ',rgba(' + Math.round(color[0]) + ',' + Math.round(color[1]) + ',' + Math.round(color[2]) + ',' + mapobj.alpha + ')';\n            }\n            strcolor += ') ';\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor;\n\n            valueDiv.style.height = 25; //(mapCanvas.height / 10);\n            valueDiv.style.width = 130; //(mapCanvas.width / 10);\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            value2.colSpan = 2;\n\n            var divleft = document.createElement('div');\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n    }, {\n        key: 'init',\n        value: function init(id, classname) {\n            //console.log(\"id == \" + id);\n            var mapCanvas = document.getElementById('mapCanvas' + id);\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) {\n                this.legendDiv.className = classname;\n            } else {\n                this.legendDiv.className = '_gisplaylegendBR';\n            }\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n            //thcolor.style.width = 100;\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numberof) {\n            if (this.lastdiv == undefined) {\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else {\n                this.firstInsertion = false;\n            }\n\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + 1 + ')';\n            var strokecolor = void 0;\n\n            if (currentaes.strokeColor != null && currentaes != undefined) strokecolor = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numberof - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (this.firstInsertion == false && i == numberof - 1 || numberof == 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numberof - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(this.round(propvalue));\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgbc;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.maxpointsize - mapobj.minpointsize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (window.profiling == true) var start = Date.now();\n                    if (mapobj.legendToggle != false) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade == true) {\n                            this.className += \" _gisplayfade\";\n                        } else {\n                            this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                        }\n                    }\n                    if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                    mapobj.draw();\n                    if (window.profiling == true) {\n                        var end = Date.now();\n                        window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                    }\n                    if (!e) var e = window.event;\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n                current.appendChild(colorDiv);\n                if ( /*i!= (numberof-1) &&*/this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n            if (this.firstInsertion == true) {\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n    }, {\n        key: 'round',\n        value: function round(value, exp) {\n            //@Rui Added cuz its used by insertProportionalSymbols\n            if (typeof exp === 'undefined' || +exp === 0) return Math.round(value);\n\n            value = +value;\n            exp = +exp;\n\n            if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) return NaN;\n\n            // Shift\n            value = value.toString().split('e');\n            value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] + exp : exp)));\n\n            // Shift back\n            value = value.toString().split('e');\n            return +(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp));\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9MZWdlbmQuanM/Yzg0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBNYXAgTGVnZW5kLiAxNS8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExlZ2VuZCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTGVnZW5kIGNsYXNzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gIFRoZSBpZCBvZiB0aGUgbGVnZW5kLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIGZvciB0aGUgbGVnZW5kLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgTGVnZW5kXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCB0aXRsZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRpdGxlIG9mIHRoZSBHaXNwbGF5IG1hcCBMZWdlbmQuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgdGhpcy5pbml0KGlkKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy9AUnVpIFJlbW92ZSB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlbmRzIHRoZSBsZWdlbmQgZGl2IGVsZW1lbnQgdG8gdGhlIG1hcCBjb250YWluZXIuXHJcbiAgICAgKiBAcGFyYW0geyp9IG1hcCBcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0TGVnZW5kKG1hcCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2LmFwcGVuZENoaWxkKHRoaXMudGFibGUpO1xyXG4gICAgICAgIG1hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZERpdik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIG9uZSByb3cgZm9yIHRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtBZXN0aGV0aWN9IGN1cnJlbnRhZXMgLSBUaGUgQWVzdGhldGljIG9iamVjdCBcclxuICAgICAqIEBwYXJhbSB7Kn0gbWFwb2JqIFxyXG4gICAgICovXHJcbiAgICBpbnNlcnRQb2ludFJvdyhjdXJyZW50YWVzLCBtYXBvYmopIHtcclxuICAgICAgICB0aGlzLmluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFBvbHlnb25Sb3coY3VycmVudGFlcywgbWFwb2JqKSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCB0eXBlKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBsZXQgdGV4dDtcclxuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRhZXMucmFuZ2VbMF0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbmlucHV0ID0gY3VycmVudGFlcy5yYW5nZVswXSAhPSBudWxsID8gY3VycmVudGFlcy5yYW5nZVswXSA6IG1hcG9iai5taW47XHJcbiAgICAgICAgICAgIGNvbnN0IG1heGlucHV0ID0gY3VycmVudGFlcy5yYW5nZVsxXSAhPSBudWxsID8gY3VycmVudGFlcy5yYW5nZVsxXSA6IG1hcG9iai5tYXg7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLm91dGVyID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHttaW5pbnB1dH0sICR7bWF4aW5wdXR9W2ApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske21pbmlucHV0fSwgJHttYXhpbnB1dH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnRhZXMucmFuZ2VbMF0pO1xyXG4gICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHRleHQpO1xyXG5cclxuICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclszXX0pYDtcclxuICAgICAgICBjb2xvckRpdi5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ10gPSByZ2JjO1xyXG4gICAgICAgIGlmICh0eXBlID09IDEpIHsvL3BvbHlnb25cclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLnN0cm9rZUNvbG9yICE9IG51bGwgJiYgY3VycmVudGFlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb2xvckRpdi5zdHlsZVsnYm9yZGVyQ29sb3InXSA9IGByZ2JhKCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclswXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzFdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMl19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclszXX0pYDtcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5cmVjdGFuZ2xlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7Ly9wb2ludFxyXG4gICAgICAgICAgICBsZXQgc2l6ZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMucG9pbnRTaXplICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChjdXJyZW50YWVzLnBvaW50U2l6ZSwgNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDI1O1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWNpcmNsZSc7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgY29sb3IuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG5cclxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY29sb3IpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcblxyXG4gICAgICAgIHJvdy5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKG1hcG9iai5sZWdlbmRUb2dnbGUgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvRmFkZSA9ICFjdXJyZW50YWVzLmVuYWJsZURpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0b0ZhZGUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lICs9IFwiIF9naXNwbGF5ZmFkZVwiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheWZhZGUoPyFcXFMpL2csICcnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsICE9IG51bGwgJiYgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbChjdXJyZW50YWVzKTtcclxuICAgICAgICAgICAgbWFwb2JqLmRyYXcoKTtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkZSBmaWx0cmFnZW0gcGVsYSBsZWdlbmRhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRHcmFkaWVudChtYXBvYmosIGxlZnQsIG1pZGRsZSwgcmlnaHQpIHtcclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCB2YWx1ZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgIHZhbHVlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGxldCBudW1iZXJvZiA9IDU7XHJcbiAgICAgICAgaWYgKG1hcG9iai5hZXN0aGV0aWNzLmxlbmd0aCA+IDUpXHJcbiAgICAgICAgICAgIG51bWJlcm9mID0gbWFwb2JqLmFlc3RoZXRpY3MubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdHJjb2xvciA9ICcnO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyb2Y7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IG1hcG9iai5mY29sb3IoaSAvIG51bWJlcm9mKS5yZ2IoKTtcclxuICAgICAgICAgICAgc3RyY29sb3IgKz0gYCxyZ2JhKCR7TWF0aC5yb3VuZChjb2xvclswXSl9LCR7TWF0aC5yb3VuZChjb2xvclsxXSl9LCR7TWF0aC5yb3VuZChjb2xvclsyXSl9LCR7bWFwb2JqLmFscGhhfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdHJjb2xvciArPSAnKSAnO1xyXG4gICAgICAgIHZhbHVlRGl2LnN0eWxlLmJhY2tncm91bmQgPSBgLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCR7c3RyY29sb3J9YDtcclxuXHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICB2YWx1ZURpdi5zdHlsZS53aWR0aCA9IDEzMDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdzIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgdmFsdWUyLmNvbFNwYW4gPSAyO1xyXG5cclxuICAgICAgICBjb25zdCBkaXZsZWZ0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS50ZXh0QWxpZ24gPSAnbGVmdCc7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgbGVmdHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWZ0KTtcclxuICAgICAgICBjb25zdCBkaXZtaWQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZtaWQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtaWRkbGUpO1xyXG4gICAgICAgIGNvbnN0IGRpdnJpZ2h0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUudGV4dEFsaWduID0gJ3JpZ2h0JztcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0dGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJpZ2h0KTtcclxuXHJcblxyXG5cclxuICAgICAgICBkaXZsZWZ0LmFwcGVuZENoaWxkKGxlZnR0ZXh0KTtcclxuICAgICAgICBkaXZtaWQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgZGl2cmlnaHQuYXBwZW5kQ2hpbGQocmlnaHR0ZXh0KTtcclxuICAgICAgICB2YWx1ZTIuYXBwZW5kQ2hpbGQoZGl2bGVmdCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdm1pZCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdnJpZ2h0KTtcclxuICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZCh2YWx1ZURpdik7XHJcbiAgICAgICAgcm93Mi5hcHBlbmRDaGlsZCh2YWx1ZTIpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93Mik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdChpZCwgY2xhc3NuYW1lKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImlkID09IFwiICsgaWQpO1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApO1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgaWYgKGNsYXNzbmFtZSAhPSB1bmRlZmluZWQgJiYgY2xhc3NuYW1lICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gY2xhc3NuYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmREaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5bGVnZW5kQlInO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlZ2VuZERpdi5pZCA9IGBsZWdlbmREaXYke2lkfWA7XHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICB0aGlzLnRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICB0aGlzLnRhYmxlLnN0eWxlLnpJbmRleCA9IFwiMjAwMFwiO1xyXG4gICAgICAgIGNvbnN0IHRodmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIGNvbnN0IHRoY29sb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0aCcpO1xyXG4gICAgICAgIHRoY29sb3Iuc3R5bGUuYWxpZ24gPSBcImNlbnRlclwiO1xyXG4gICAgICAgIC8vdGhjb2xvci5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRoY29sb3IpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGh2YWx1ZSk7XHJcbiAgICAgICAgY29uc3QgdGl0bGVyb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIHRpdGxldGQuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgdGl0bGV0ZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICB0aXRsZXRkLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIGNvbnN0IHRpdGxldGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMudGl0bGUpO1xyXG4gICAgICAgIHRpdGxldGQuYXBwZW5kQ2hpbGQodGl0bGV0ZXh0KTtcclxuICAgICAgICB0aXRsZXJvdy5hcHBlbmRDaGlsZCh0aXRsZXRkKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRpdGxlcm93KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyhjdXJyZW50YWVzLCBtYXBvYmosIG51bWJlcm9mKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFzdGRpdiA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgICAgICB2YWx1ZS5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICAgICAgdGhpcy5maXJzdEluc2VydGlvbiA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHsgdGhpcy5maXJzdEluc2VydGlvbiA9IGZhbHNlOyB9XHJcblxyXG4gICAgICAgIGNvbnN0IHJnYmMgPSBgcmdiYSgke2N1cnJlbnRhZXMuZmlsbENvbG9yWzBdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzFdfSwke2N1cnJlbnRhZXMuZmlsbENvbG9yWzJdfSwkezF9KWA7XHJcbiAgICAgICAgbGV0IHN0cm9rZWNvbG9yO1xyXG5cclxuICAgICAgICBpZiAoY3VycmVudGFlcy5zdHJva2VDb2xvciAhPSBudWxsICYmIGN1cnJlbnRhZXMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclswXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzFdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMl19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclszXX0pYDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHN0cm9rZWNvbG9yID0gYHJnYmEoJHswfSwkezB9LCR7MH0sJHsxfSlgO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gbnVtYmVyb2YgLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGxldCBwcm9wdmFsdWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0SW5zZXJ0aW9uID09IGZhbHNlICYmIGkgPT0gKG51bWJlcm9mIC0gMSkgfHwgbnVtYmVyb2YgPT0gMSlcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IGN1cnJlbnRhZXMucmFuZ2VbMV07XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHByb3B2YWx1ZSA9IG1hcG9iai5taW4gKyBpIC8gKG51bWJlcm9mIC0gMSkgKiAobWFwb2JqLm1heCAtIG1hcG9iai5taW4pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRoaXMucm91bmQocHJvcHZhbHVlKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmdiYztcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5cHJvcG9ydGlvbmFsY2lyY2xlJztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSBzdHJva2Vjb2xvcjtcclxuICAgICAgICAgICAgY29uc3QgdGVtcHBvaW50c2l6ZSA9ICgobWFwb2JqLm1heHBvaW50c2l6ZSAtIG1hcG9iai5taW5wb2ludHNpemUpIC8gKG1hcG9iai5tYXggLSBtYXBvYmoubWluKSkgKiAocHJvcHZhbHVlIC0gbWFwb2JqLm1pbik7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1heCh0ZW1wcG9pbnRzaXplLCA3LjUpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmluaGVyaXQgPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICAgIGNvbG9yRGl2Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hcG9iai5sZWdlbmRUb2dnbGUgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b0ZhZGUgPSAhY3VycmVudGFlcy5lbmFibGVEaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvRmFkZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lICs9IFwiIF9naXNwbGF5ZmFkZVwiO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheWZhZGUoPyFcXFMpL2csICcnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsICE9IG51bGwgJiYgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwoY3VycmVudGFlcyk7XHJcbiAgICAgICAgICAgICAgICBtYXBvYmouZHJhdygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIGZpbHRyYWdlbSBwZWxhIGxlZ2VuZGEgKHNlZ3VuZG9zKTogJHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghZSkgdmFyIGUgPSB3aW5kb3cuZXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuICAgICAgICAgICAgaWYgKC8qaSE9IChudW1iZXJvZi0xKSAmJiovIHRoaXMubGFzdGRpdiAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdi5hcHBlbmRDaGlsZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdiA9IGNvbG9yRGl2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RkaXYgPSBjb2xvckRpdjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RJbnNlcnRpb24gPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgcm91bmQodmFsdWUsIGV4cCkgey8vQFJ1aSBBZGRlZCBjdXogaXRzIHVzZWQgYnkgaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9sc1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXhwID09PSAndW5kZWZpbmVkJyB8fCArZXhwID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XHJcblxyXG4gICAgICAgIHZhbHVlID0gK3ZhbHVlO1xyXG4gICAgICAgIGV4cCA9ICtleHA7XHJcblxyXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkgfHwgISh0eXBlb2YgZXhwID09PSAnbnVtYmVyJyAmJiBleHAgJSAxID09PSAwKSlcclxuICAgICAgICAgICAgcmV0dXJuIE5hTjtcclxuXHJcbiAgICAgICAgLy8gU2hpZnRcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcclxuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQoKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gKyBleHApIDogZXhwKSkpO1xyXG5cclxuICAgICAgICAvLyBTaGlmdCBiYWNrXHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCdlJyk7XHJcbiAgICAgICAgcmV0dXJuICsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdIC0gZXhwKSA6IC1leHApKTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9MZWdlbmQuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0FBR0E7QUFDQTs7Ozs7OztBQU9BO0FBQUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/Gisplay/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 7);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available. There is only one map yet(maybe there will be two if we want to compare two).\r\n */\nvar Map = exports.Map = function () {\n    function Map(type, geometry, options) {\n        _classCallCheck(this, Map);\n\n        console.log(\"Map constructor called -> super()\");\n    }\n\n    _createClass(Map, [{\n        key: 'program',\n        value: function program() {\n            this._webgl.program = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram = [];\n            this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();\n\n            var source_code = this.generateShaders();\n\n            var vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);\n            var fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);\n\n            this._webgl.gl.attachShader(this._webgl.program, vertex_shader);\n            this._webgl.gl.attachShader(this._webgl.program, fragment_shader);\n\n            this._webgl.gl.linkProgram(this._webgl.program);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'shader',\n        value: function shader(type, source_code, _webgl) {\n            //Added HERE by Rui\n            var shader = _webgl.gl.createShader(type);\n\n            _webgl.gl.shaderSource(shader, source_code);\n            _webgl.gl.compileShader(shader);\n\n            console.log(\"shader \" + (type.valueOf() == 35633 ? \"vertex\" : \"fragment\") + \": \" + _webgl.gl.getShaderInfoLog(shader));\n\n            return shader;\n        }\n    }, {\n        key: 'generateShaders',\n        value: function generateShaders() {\n            //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=\n            //general\n\n            var vertexSourceCode = \" attribute vec4 vertexCoord; \";\n            vertexSourceCode += \"\\n\tattribute float aPointSize; \";\n            vertexSourceCode += \"\\n\tuniform mat4 projection; \";\n            vertexSourceCode += \"\\n\tattribute float a_opacity; \";\n            vertexSourceCode += \"\\n\tvarying float v_opacity; \";\n            //vertexSourceCode+= \"\\n\tvarying vec4 u_color; \" ; //delete\n            vertexSourceCode += \"\\n\tvoid main() {\";\n            vertexSourceCode += \"\\n\t\tgl_Position = (projection * vertexCoord); \";\n            vertexSourceCode += \"\\n\t\tgl_PointSize = aPointSize; v_opacity = a_opacity; \";\n            vertexSourceCode += \"\\n}\";\n\n            var fragmentSourceCode = \"precision mediump float;\";\n            fragmentSourceCode += \"\\n\t\tuniform vec4 u_color;\"; //uniform\n            fragmentSourceCode += \"\\n\t\tvarying float v_opacity; \";\n            fragmentSourceCode += \"\\n \t\tuniform float isPoint;\";\n            fragmentSourceCode += \"\\n\t\tvoid main(){\";\n            fragmentSourceCode += \"\\n\t\t\tfloat border = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat radius = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat centerDist = length(gl_PointCoord - 0.5);\";\n            fragmentSourceCode += \"\\n\t\t\tfloat alpha;\";\n            fragmentSourceCode += \"\\n\t\t\tif (u_color[3] == -1.0){\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  v_opacity * step(centerDist, radius);\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\telse{\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  u_color[3] * step(centerDist, radius);\";\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\tif(isPoint == 1.0 ){\";\n            fragmentSourceCode += \"\\n\t\t\tif (alpha < 0.1) discard;\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}\";\n            fragmentSourceCode += \"\\n \t\t\telse\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\";\n            fragmentSourceCode += \"\\n\t\t}\";\n\n            return { vertex: vertexSourceCode, fragment: fragmentSourceCode };\n        }\n    }, {\n        key: 'addAesthetic',\n        value: function addAesthetic(aes) {\n            this.aesthetics.push(aes);\n        }\n    }, {\n        key: 'setAesthetic',\n        value: function setAesthetic(id, aes) {\n            for (var i = 0; i < aesthetics.length; i++) {\n                if (id == aesthetics[i].id) {\n                    aesthetics[i] = aes;\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            //legendDiv.style.height = 200;//(mapCanvas.height / 10);\n            legendDiv.style.width = 250; //(mapCanvas.width / 10);\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            //thvalue.style.width = 125;\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var currentaes = _step.value;\n\n                    //if(currentaes._features.length > 0 || currentaes._allFeatures.length > 0){\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    //console.log(rgbc);\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                    colorDiv.style.width = 80; //(mapCanvas.width / 10);\n\n\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n\n                    table.appendChild(row);\n                    //}\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.map.getContainer().appendChild(legendDiv);\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n\n            var aesarray = [];\n            var values = [];\n            var strings = [];\n            var breaks = void 0;\n            var fcolor = void 0;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (geojson.features[g].properties[this.attr] != null && typeof geojson.features[g].properties[this.attr] == 'number') {\n                    values.push(geojson.features[g].properties[this.attr]);\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);\n                } else if (!strings.includes(geojson.features[g].properties[this.attr])) strings.push(geojson.features[g].properties[this.attr]);\n            }\n            if (values.length > 0) {\n                //quantitative\n                if (this.breaks == undefined) {\n                    if (numberOf > 1) breaks = this.calcClassBreaks(values, algorithm, numberOf);else breaks = [this.min, this.max];\n                } else {\n                    breaks = this.breaks;\n                }\n                if (breaks.length > 2) {\n                    fcolor = chroma.scale(colorscheme).colors(breaks.length - 1);\n                    for (var i = 0; i < breaks.length - 1; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        if (i != breaks.length - 2) {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                        } else {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    color = chroma(colorscheme[0]).rgb();\n                    var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n                    aes.outer = true;\n                    aesarray.push(aes);\n                }\n            } else {\n                //qualitative\n                if (strings.length > 0) {\n                    breaks = strings;\n                    if (typeof colorscheme === 'string') {\n                        //string\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    } else {\n                        //array\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    }\n                    for (var i = 0; i < breaks.length; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);\n                        aesarray.push(aes);\n                    }\n                }\n            }\n\n            this.aesthetics = aesarray;\n            //return aesarray;\n        }\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(values, algorithm, numberOf) {\n            var breaks = void 0;\n            switch (algorithm) {\n                case 'equidistant':\n                    breaks = chroma.limits(values, 'e', numberOf);\n                    break;\n\n                case 'quantile':\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n\n                case 'k-means':\n                    breaks = chroma.limits(values, 'k', numberOf);\n                    break;\n\n                default:\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n            }\n            return breaks;\n        }\n\n        /**\r\n         * \r\n         * @param {JSON} geojson \r\n         */\n\n    }, {\n        key: 'processData',\n        value: function processData(geojson) {\n            this.loadGeoJSON(geojson);\n        }\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                geojson.features[g].properties['_gisplayid'] = g;\n                var geometry = geojson.features[g].geometry;\n                var properties = geojson.features[g].properties;\n                this.createAndInsertFeature(g, geometry, properties);\n            }\n            this.buildTrees(geojson);\n        }\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(id, geometry, properties) {\n            var gl = this._webgl.gl;\n            if (this.minuend != undefined && this.subtrahend != undefined && typeof properties[this.minuend] == 'number' && properties[this.subtrahend] != undefined && typeof properties[this.subtrahend] == 'number' && properties[this.subtrahend] != undefined) {\n                properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];\n            }\n\n            if (geometry.type == \"Polygon\" || geometry.type == \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentBorders = [];\n                var currentTriangles = [];\n                var bufferT = [];\n                var bufferB = [];\n\n                for (var j = 0; j < polygons.length; j++) {\n                    var trianglespolygon = polygons[j].triangles;\n                    var border = polygons[j].vertex;\n                    currentTriangles[j] = new Array();\n                    currentBorders[j] = new Array();\n                    for (var h = 0; h < trianglespolygon.length; h++) {\n                        var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);\n                        currentTriangles[j].push(pixel.x, pixel.y);\n\n                        if (h == trianglespolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[j].itemSize = 2;\n                            bufferT[j].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var y = 0; y < border.length; y += 2) {\n                        var pixel = this.latLongToPixelXY(border[y], border[y + 1]);\n                        currentBorders[j].push(pixel.x, pixel.y);\n\n                        if (y == border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentBorders[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferB[j].itemSize = 2;\n                            bufferB[j].numItems = vertArray.length / 2;\n                        }\n                    }\n                }\n                //polygon\n                this.insertFeature(id, properties, bufferT, bufferB, []);\n            } else if (geometry.type == \"Point\" && this.dynamic == true) {\n                //dum\n                var currentPoints = [];\n                currentPoints[0] = new Array();\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                currentPoints[0].push(pixel.x, pixel.y);\n                var bufferP = [];\n                bufferP.push(gl.createBuffer());\n\n                var vertArray = new Float32Array(currentPoints[0]);\n\n                gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                bufferP[0].itemSize = 2;\n                bufferP[0].numItems = vertArray.length / 2;\n\n                this.insertFeature(id, properties, [], [], bufferP);\n\n                if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type == \"Point\" && this.dynamic == false) {\n                //debugger;\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                if (this.tempPoints == null || this.tempPoints == undefined) {\n                    this.tempPoints = new Array();\n                    for (var a = 0; a < this.aesthetics.length; a++) {\n                        this.tempPoints[a] = [];\n                    }\n                }\n\n                var aesarrays = this.fitFeature(properties);\n                for (var y = 0; y < aesarrays.length; y++) {\n                    this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);\n                }\n\n                if (this.treepoints == null) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n            if (polygon.geometry.type == \"Polygon\") {\n                var outsidepolygon = polygon.geometry.coordinates[0];\n\n                var insidepolygons = [];\n                for (var k = 1; k < polygon.geometry.coordinates.length; k++) {\n                    //todo inside polygon\n                    //insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                }\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                    _vertexcount += (outsidepolygon.length + 1) / 2;\n                    //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                }\n\n                var triangles_vert = earcut(tempVerts);\n                _tricount += triangles_vert.length / 3;\n                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                var polyarray = [];\n                for (var i = 0; i < polygon.geometry.coordinates.length; i++) {\n\n                    var outsidepolygon = polygon.geometry.coordinates[i][0];\n\n                    var insidepolygons = [];\n                    for (var k = 1; k < polygon.geometry.coordinates[i].length; k++) {\n                        //todo inside polygon\n                        insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                    }\n                    var tempVerts = new Array();\n                    _vertexcount += outsidepolygon.length;\n                    for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                        tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n\n                        //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                    }\n\n                    var triangles_vert = earcut(tempVerts);\n                    //var temp = earcut.flatten(polygon.geometry.coordinates[i]);\n                    //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);\n                    _tricount += triangles_vert.length / 3;\n                    polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n                    //console.log(polyarray);\n                }\n                return polyarray;\n            }\n        }\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var flag = false;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {\n                    this.aesthetics[i].addFeature(id, properties, triangles, borders, points);\n                    flag = true;\n                }\n            }\n            if (!flag) {\n                //TODO\n                //console.log(\"TODO: feature does not fit into any of the aesthetics defined.\\n Value: \" + properties[this.attr]);\n            }\n        }\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n            return pixel;\n        }\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var result = [];\n            for (var a = 0; a < this.aesthetics.length; a++) {\n                if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true) result.push(a);\n            }\n            return result;\n        }\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempPoints != null) {\n                for (var t = 0; t < this.tempPoints.length; t++) {\n                    if (this.tempPoints[t].length > 0) {\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        var vertArray = new Float32Array(this.tempPoints[t]);\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(t, [], [], bufferP);\n                    }\n                }\n            }\n            //console.log(geojson)\n            if (this.treepoints != null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons == true) this.rtree = new PolygonLookup(geojson);\n        }\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(idaes, triangles, borders, points) {\n            this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.map.createCanvas(this.id);\n\n            //init webgl properties\n            this._webgl = {\n                gl: null,\n                program: null,\n                projection: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            this._webgl.projection = new Float32Array(16);\n            this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n            this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'getNumberOfFeatures',\n        value: function getNumberOfFeatures() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                count += this.aesthetics[i]._features.length;\n            }\n            return count;\n        }\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            // scaling x and y, which is just scaling first two rows of matrix\n            matrix[0] *= scaleX;\n            matrix[1] *= scaleX;\n            matrix[2] *= scaleX;\n            matrix[3] *= scaleX;\n\n            matrix[4] *= scaleY;\n            matrix[5] *= scaleY;\n            matrix[6] *= scaleY;\n            matrix[7] *= scaleY;\n        }\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            // translation is in last row of matrix\n            matrix[12] += matrix[0] * tx + matrix[4] * ty;\n            matrix[13] += matrix[1] * tx + matrix[5] * ty;\n            matrix[14] += matrix[2] * tx + matrix[6] * ty;\n            matrix[15] += matrix[3] * tx + matrix[7] * ty;\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._borders.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length && this.dynamic == true; i++) {\n                for (var y = 0; y < aes._features[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                    //1);\n                }\n            }\n\n            for (var i = 0; this.dynamic == false && aes._allFeatures != null && i < aes._allFeatures.length; i++) {\n                for (var y = 0; y < aes._allFeatures[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);\n                    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);\t\n                    //1);\n                }\n            }\n        }\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n\n            for (var i = 0; i < aes._features.length; i++) {\n                var ucolor = void 0;\n                var color = void 0;\n                var diff = aes._features[i]._properties[this.attr];\n                if (diff == 0) color = aes.fillColor(0.5).rgb();else {\n                    if (diff > 0) {\n                        color = aes.fillColor(0.5 + diff / this.max / 2).rgb();\n                    } else {\n                        color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                }\n                ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];\n\n                gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawProporcionalPoints',\n        value: function drawProporcionalPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);\n\n            if (this.dynamic == true) {\n                for (var i in aes._features) {\n                    for (var y in aes._features[i]._points) {\n\n                        gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n                        var propvalue = parseFloat(aes._features[i]._properties[this.attr]);\n                        var temppointsize = (this.maxpointsize - this.minpointsize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n                        var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n                        gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n                        gl.enableVertexAttribArray(vertexCoordLocation);\n                        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                        //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                        //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                        gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                        //1);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            this.max = null;\n            this.min = null;\n            this.createCanvas();\n            this.program();\n            var mappos = void 0;\n            for (var i = 0; i < maps.length; i++) {\n                if (maps[i].id == this.id) mappos = i;\n            }this.map.onEvent('move', function () {\n                console.log(\"@Rui: mudar o profiling do window para outra coisa?\");\n                if (window.profiling == true) var start = Date.now();\n                maps[mappos].draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de Zoom/Pan (segundos):' + (end - start) / 1000);\n                }\n            });\n\n            this.setupOnclick(mappos);\n        }\n    }, {\n        key: 'setupOnclick',\n        value: function setupOnclick(mappos) {\n            console.log(\"@Rui: profiling mudar de window para? | Rtree e KdTree\");\n            maps[mappos].map.onEvent('click', function (e) {\n                if (window.profiling == true) var start = Date.now();\n                var lat = e.latlng.lat;\n                var lon = e.latlng.lng;\n\n                if (maps[mappos].rtree != undefined) {\n                    var bool = maps[0].rtree.search(lon, lat);\n                    if (bool == undefined) return;else {\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s); //todo\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n                if (maps[mappos].kdtree != undefined) {\n\n                    var nearest = maps[mappos].kdtree.nearest({ lat: lat, lon: lon }, 1, 128 / 2 ** (map.getZoom() * 2));\n                    if (nearest.length <= 0) return;else {\n                        var bool = nearest[0][0];\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s);\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de um click (segundos): ' + (end - start) / 1000);\n                }\n            });\n        }\n    }, {\n        key: 'loadOptions',\n        value: function loadOptions(options, bgmap) {\n            if (options.customMapService == true) this.map = bgmap;else this.map = new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (options.loader != false) this.loader();\n\n            if (options.showPropertiesOnClick == true) {\n                this.showPropertiesOnClick = null;\n                //append on bgmap object\n            } else if (options.showPropertiesOnClick == false) {\n                //nada\n            } else if (options.showPropertiesOnClick != undefined) {\n                this.showPropertiesOnClick = options.showPropertiesOnClick;\n            }\n            this.alpha = options.alpha != undefined ? options.alpha : 0.8;\n            this.interactive = options.interactive == undefined ? true : !options.interactive;\n            this.attr = options.attr;\n            this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;\n            this.maxfeatures = options.maxFeatures;\n            this.breaks = options.classBreaks;\n            this.colorscheme = options.colorScheme;\n            this.numberofclasses = options.numberOfClasses;\n            this.algorithm = options.classBreaksMethod;\n            this.legendOnClickCall = options.legendOnClickFunction;\n            this.mapOnClickCall = options.mapOnClickFunction;\n            this.minuend = options.minuend;\n            this.subtrahend = options.subtrahend;\n            this.legendTitle = options.legendTitle != undefined ? options.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n            this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            this.map.loader();\n        }\n    }, {\n        key: 'getNumberOfPolygons',\n        value: function getNumberOfPolygons() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                for (var z = 0; z < this.aesthetics[i]._features.length; z++) {\n                    count += this.aesthetics[i]._features[z]._triangles.length;\n                }\n            }\n            return count;\n        }\n\n        //STATIC METHODS(should be implemented by sub-classes)\n\n    }, {\n        key: 'draw',\n        value: function draw() {\n            alert(\"draw() not implemented\"); //throw new NotImplementedError();\n        }\n\n        /**\r\n         * @deprecated This was created for Heat Maps. Another idea will probably be used.\r\n         * @param {Aesthetic} aes \r\n         */\n\n    }, {\n        key: 'drawHeatPoints',\n        value: function drawHeatPoints(aes) {\n            var gl = this._webgl.gl;\n\n            if (gl == null) return;\n            gl.useProgram(this._webgl.heatmapProgram[0]);\n            var matrixProjection = new Float32Array(16);\n\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n\n            gl.blendFunc(gl.ONE, gl.ONE);\n\n            var currentZoom = map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'position');\n            var deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'delta');\n            var intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'intensity');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'aPointSize');\n\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            gl.enableVertexAttribArray(vertexCoordLocation);\n            gl.enableVertexAttribArray(deltaLocation);\n            gl.enableVertexAttribArray(intensityLoc);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);\n            gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);\n            gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);\n            gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);\n\n            console.log(aes._allFeatures[0]._points[0].numItems);\n            gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);\n\n            gl.useProgram(this._webgl.heatmapProgram[1]);\n\n            gl.disable(gl.BLEND);\n\n            //console.log(\"fase 1 concluida\");\n\n            var canvas = document.getElementById('mapCanvas' + this.id);\n\n            var source = gl.createTexture();\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, source);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n\n            function isPowerOf2(value) {\n                return (value & value - 1) == 0;\n            };\n\n            function steupTextureFilteringAndMips(width, height, gl) {\n                if (isPowerOf2(width) && isPowerOf2(height)) {\n                    // the dimensions are power of 2 so generate mips and turn on \n                    // tri-linear filtering.\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                } else {\n                    // at least one of the dimensions is not a power of 2 so set the filtering\n                    // so WebGL will render it.\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n            };\n\n            steupTextureFilteringAndMips(canvas.width, canvas.height, gl);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            var vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n            var buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            var positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], 'position');\n            var sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], 'source');\n            gl.enableVertexAttribArray(positionLoc);\n            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.uniform1i(sourceLoc, 0);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            gl.disableVertexAttribArray(positionLoc);\n            //defaults to general program\n            //console.log(\"fase 2 concluida\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL01hcC5qcz8xZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJHTWFwV3JhcHBlciB9IGZyb20gJy4vQkdNYXBXcmFwcGVyJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIGNvbnRhaW5zIHRoZSBNYXAgY2xhc3Mgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBtYXAuXHJcbiAqIEVhY2ggbWFwIGhhcyBhIGdyb3VwIG9mIGZ1bmN0aW9ucyBhdmFpbGFibGUuIFRoZXJlIGlzIG9ubHkgb25lIG1hcCB5ZXQobWF5YmUgdGhlcmUgd2lsbCBiZSB0d28gaWYgd2Ugd2FudCB0byBjb21wYXJlIHR3bykuXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTWFwIGNvbnN0cnVjdG9yIGNhbGxlZCAtPiBzdXBlcigpXCIpXHJcbiAgICB9XHJcblxyXG4gICAgcHJvZ3JhbSgpIHtcclxuICAgICAgICB0aGlzLl93ZWJnbC5wcm9ncmFtID0gdGhpcy5fd2ViZ2wuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtID0gW107XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0gPSB0aGlzLl93ZWJnbC5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0gPSB0aGlzLl93ZWJnbC5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcblxyXG4gICAgICAgIGNvbnN0IHNvdXJjZV9jb2RlID0gdGhpcy5nZW5lcmF0ZVNoYWRlcnMoKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4X3NoYWRlciA9IHRoaXMuc2hhZGVyKHRoaXMuX3dlYmdsLmdsLlZFUlRFWF9TSEFERVIsIHNvdXJjZV9jb2RlLnZlcnRleCwgdGhpcy5fd2ViZ2wpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50X3NoYWRlciA9IHRoaXMuc2hhZGVyKHRoaXMuX3dlYmdsLmdsLkZSQUdNRU5UX1NIQURFUiwgc291cmNlX2NvZGUuZnJhZ21lbnQsIHRoaXMuX3dlYmdsKTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3dlYmdsLnByb2dyYW0sIHZlcnRleF9zaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmF0dGFjaFNoYWRlcih0aGlzLl93ZWJnbC5wcm9ncmFtLCBmcmFnbWVudF9zaGFkZXIpO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5saW5rUHJvZ3JhbSh0aGlzLl93ZWJnbC5wcm9ncmFtKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC51c2VQcm9ncmFtKHRoaXMuX3dlYmdsLnByb2dyYW0pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBzaGFkZXIodHlwZSwgc291cmNlX2NvZGUsIF93ZWJnbCkgeyAvL0FkZGVkIEhFUkUgYnkgUnVpXHJcbiAgICAgICAgdmFyIHNoYWRlciA9IF93ZWJnbC5nbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcblxyXG4gICAgICAgIF93ZWJnbC5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2VfY29kZSk7XHJcbiAgICAgICAgX3dlYmdsLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzaGFkZXIgXCIgKyAodHlwZS52YWx1ZU9mKCkgPT0gMzU2MzMgPyBcInZlcnRleFwiIDogXCJmcmFnbWVudFwiKSArIFwiOiBcIiArIF93ZWJnbC5nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG5cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG5cclxuICAgIGdlbmVyYXRlU2hhZGVycygpIHsgLy9BZGRlZCBIRVJFIGJ5IFJ1aSBAVE9ETyBSZWZhY3RvciB0byB1c2UgRVM2IGBgIGluc3RlYWQgb2YgKz1cclxuICAgICAgICAvL2dlbmVyYWxcclxuXHJcbiAgICAgICAgbGV0IHZlcnRleFNvdXJjZUNvZGUgPSBcIiBhdHRyaWJ1dGUgdmVjNCB2ZXJ0ZXhDb29yZDsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0YXR0cmlidXRlIGZsb2F0IGFQb2ludFNpemU7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdHVuaWZvcm0gbWF0NCBwcm9qZWN0aW9uOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRhdHRyaWJ1dGUgZmxvYXQgYV9vcGFjaXR5OyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHR2YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgLy92ZXJ0ZXhTb3VyY2VDb2RlKz0gXCJcXG5cdHZhcnlpbmcgdmVjNCB1X2NvbG9yOyBcIiA7IC8vZGVsZXRlXHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0dm9pZCBtYWluKCkge1wiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0Z2xfUG9zaXRpb24gPSAocHJvamVjdGlvbiAqIHZlcnRleENvb3JkKTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0XHRnbF9Qb2ludFNpemUgPSBhUG9pbnRTaXplOyB2X29wYWNpdHkgPSBhX29wYWNpdHk7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG59XCI7XHJcblxyXG4gICAgICAgIGxldCBmcmFnbWVudFNvdXJjZUNvZGUgPSBcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR1bmlmb3JtIHZlYzQgdV9jb2xvcjtcIjsvL3VuaWZvcm1cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0dmFyeWluZyBmbG9hdCB2X29wYWNpdHk7IFwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcbiBcdFx0dW5pZm9ybSBmbG9hdCBpc1BvaW50O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR2b2lkIG1haW4oKXtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCBib3JkZXIgPSAwLjU7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgcmFkaXVzID0gMC41O1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGZsb2F0IGNlbnRlckRpc3QgPSBsZW5ndGgoZ2xfUG9pbnRDb29yZCAtIDAuNSk7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgYWxwaGE7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0aWYgKHVfY29sb3JbM10gPT0gLTEuMCl7XCI7ICAgLy91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRhbHBoYSA9ICB2X29wYWNpdHkgKiBzdGVwKGNlbnRlckRpc3QsIHJhZGl1cyk7XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0fVwiOy8vdW5uZWNlc3Nhcnk/P1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGVsc2V7XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRhbHBoYSA9ICB1X2NvbG9yWzNdICogc3RlcChjZW50ZXJEaXN0LCByYWRpdXMpO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdH1cIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRpZihpc1BvaW50ID09IDEuMCApe1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGlmIChhbHBoYSA8IDAuMSkgZGlzY2FyZDtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGdsX0ZyYWdDb2xvciA9IHZlYzQodV9jb2xvclswXSwgdV9jb2xvclsxXSwgdV9jb2xvclsyXSwgYWxwaGEpO31cIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG4gXHRcdFx0ZWxzZVwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yWzBdLCB1X2NvbG9yWzFdLCB1X2NvbG9yWzJdLCB1X2NvbG9yWzNdKTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0fVwiO1xyXG5cclxuICAgICAgICByZXR1cm4geyB2ZXJ0ZXg6IHZlcnRleFNvdXJjZUNvZGUsIGZyYWdtZW50OiBmcmFnbWVudFNvdXJjZUNvZGUgfTtcclxuICAgIH1cclxuXHJcbiAgICBhZGRBZXN0aGV0aWMoYWVzKSB7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzLnB1c2goYWVzKTtcclxuICAgIH1cclxuXHJcbiAgICBzZXRBZXN0aGV0aWMoaWQsIGFlcykge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoaWQgPT0gYWVzdGhldGljc1tpXS5pZCkge1xyXG4gICAgICAgICAgICAgICAgYWVzdGhldGljc1tpXSA9IGFlcztcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIGNvbnN0IG1hcENhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcbiAgICAgICAgY29uc3QgbGVnZW5kRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgbGVnZW5kRGl2LmlkID0gYGxlZ2VuZERpdiR7dGhpcy5pZH1gO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd3aGl0ZSc7XHJcbiAgICAgICAgLy9sZWdlbmREaXYuc3R5bGUuaGVpZ2h0ID0gMjAwOy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLndpZHRoID0gMjUwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYm90dG9tID0gMjA7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLnJpZ2h0ID0gMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYm9yZGVyQ29sb3IgPSAnYmxhY2snO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXIgPSAnc29saWQnO1xyXG5cclxuICAgICAgICBjb25zdCB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XHJcbiAgICAgICAgY29uc3QgdGh2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgY29uc3QgdGhjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgLy90aHZhbHVlLnN0eWxlLndpZHRoID0gMTI1O1xyXG4gICAgICAgIHRhYmxlLnN0eWxlLnpJbmRleCA9IFwiMjAwMFwiO1xyXG4gICAgICAgIHRoY29sb3Iuc3R5bGUud2lkdGggPSAxMDA7XHJcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGhjb2xvcik7XHJcbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGh2YWx1ZSk7XHJcblxyXG5cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRhZXMgb2YgdGhpcy5hZXN0aGV0aWNzKSB7XHJcbiAgICAgICAgICAgIC8vaWYoY3VycmVudGFlcy5fZmVhdHVyZXMubGVuZ3RoID4gMCB8fCBjdXJyZW50YWVzLl9hbGxGZWF0dXJlcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpO1xyXG4gICAgICAgICAgICBsZXQgdGV4dDtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50YWVzLnJhbmdlWzBdID09PSAnbnVtYmVyJylcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgWyR7Y3VycmVudGFlcy5yYW5nZVswXX0sICR7Y3VycmVudGFlcy5yYW5nZVsxXX1bYCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjdXJyZW50YWVzLnJhbmdlWzBdKTtcclxuICAgICAgICAgICAgcHRleHQuYXBwZW5kQ2hpbGQodGV4dCk7XHJcbiAgICAgICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHB0ZXh0KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgY29uc3QgcmdiYyA9IGByZ2JhKCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMF19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMV19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMl19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbM119KWA7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2cocmdiYyk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlWydiYWNrZ3JvdW5kQ29sb3InXSA9IHJnYmM7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IDI1Oy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gODA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBjb2xvci5hcHBlbmRDaGlsZChjb2xvckRpdik7XHJcblxyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY29sb3IpO1xyXG4gICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG5cclxuICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICAgICAgLy99XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZWdlbmREaXYuYXBwZW5kQ2hpbGQodGFibGUpO1xyXG4gICAgICAgIHRoaXMubWFwLmdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKGxlZ2VuZERpdik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJlUHJvY2Vzc0RhdGEoZ2VvanNvbiwgbnVtYmVyT2YsIGFsZ29yaXRobSwgY29sb3JzY2hlbWUpIHtcclxuXHJcbiAgICAgICAgY29uc3QgYWVzYXJyYXkgPSBbXTtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBzdHJpbmdzID0gW107XHJcbiAgICAgICAgbGV0IGJyZWFrcztcclxuICAgICAgICBsZXQgZmNvbG9yO1xyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggJiYgKHRoaXMubWF4ZmVhdHVyZXMgPT0gdW5kZWZpbmVkIHx8IGcgPCB0aGlzLm1heGZlYXR1cmVzKTsgZysrKSB7XHJcbiAgICAgICAgICAgIGlmIChnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSAhPSBudWxsICYmIHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSA9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLm1heCwgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLm1pbiwgZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIGlmICghc3RyaW5ncy5pbmNsdWRlcyhnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSkpXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5ncy5wdXNoKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPiAwKSB7Ly9xdWFudGl0YXRpdmVcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnJlYWtzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG51bWJlck9mID4gMSlcclxuICAgICAgICAgICAgICAgICAgICBicmVha3MgPSB0aGlzLmNhbGNDbGFzc0JyZWFrcyh2YWx1ZXMsIGFsZ29yaXRobSwgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gdGhpcy5icmVha3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJyZWFrcy5sZW5ndGggPiAyKSB7XHJcbiAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhicmVha3MubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyZWFrcy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaSAhPSBicmVha3MubGVuZ3RoIC0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzW2ldLCBicmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCB0aGlzLmFscGhhXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbYnJlYWtzW2ldLCBicmVha3NbaSArIDFdXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFlcy5vdXRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yID0gY2hyb21hKGNvbG9yc2NoZW1lWzBdKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbMF0sIGJyZWFrc1sxXV0pO1xyXG4gICAgICAgICAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxzZSB7Ly9xdWFsaXRhdGl2ZVxyXG4gICAgICAgICAgICBpZiAoc3RyaW5ncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBzdHJpbmdzO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2xvcnNjaGVtZSA9PT0gJ3N0cmluZycpIHsvL3N0cmluZ1xyXG4gICAgICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7IC8vYXJyYXlcclxuICAgICAgICAgICAgICAgICAgICBmY29sb3IgPSBjaHJvbWEuc2NhbGUoY29sb3JzY2hlbWUpLmNvbG9ycyhicmVha3MubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYWtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbG9yID0gY2hyb21hKGZjb2xvcltpXSkucmdiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgMV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW3N0cmluZ3NbaV1dKTtcclxuICAgICAgICAgICAgICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgICAgIC8vcmV0dXJuIGFlc2FycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGNhbGNDbGFzc0JyZWFrcyh2YWx1ZXMsIGFsZ29yaXRobSwgbnVtYmVyT2YpIHtcclxuICAgICAgICBsZXQgYnJlYWtzO1xyXG4gICAgICAgIHN3aXRjaCAoYWxnb3JpdGhtKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2VxdWlkaXN0YW50JzpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAnZScsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgY2FzZSAncXVhbnRpbGUnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdxJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdrLW1lYW5zJzpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAnaycsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IGNocm9tYS5saW1pdHModmFsdWVzLCAncScsIG51bWJlck9mKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnJlYWtzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb2pzb24gXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NEYXRhKGdlb2pzb24pIHtcclxuICAgICAgICB0aGlzLmxvYWRHZW9KU09OKGdlb2pzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRHZW9KU09OKGdlb2pzb24pIHtcclxuICAgICAgICBmb3IgKGxldCBnID0gMDsgZyA8IGdlb2pzb24uZmVhdHVyZXMubGVuZ3RoICYmICh0aGlzLm1heGZlYXR1cmVzID09IHVuZGVmaW5lZCB8fCBnIDwgdGhpcy5tYXhmZWF0dXJlcyk7IGcrKykge1xyXG4gICAgICAgICAgICBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbJ19naXNwbGF5aWQnXSA9IGc7XHJcbiAgICAgICAgICAgIGNvbnN0IGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tnXS5nZW9tZXRyeTtcclxuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllcztcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVBbmRJbnNlcnRGZWF0dXJlKGcsIGdlb21ldHJ5LCBwcm9wZXJ0aWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5idWlsZFRyZWVzKGdlb2pzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUFuZEluc2VydEZlYXR1cmUoaWQsIGdlb21ldHJ5LCBwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl93ZWJnbC5nbDtcclxuICAgICAgICBpZiAodGhpcy5taW51ZW5kICE9IHVuZGVmaW5lZCAmJiB0aGlzLnN1YnRyYWhlbmQgIT0gdW5kZWZpbmVkICYmIHR5cGVvZiBwcm9wZXJ0aWVzW3RoaXMubWludWVuZF0gPT0gJ251bWJlcidcclxuICAgICAgICAgICAgJiYgcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdID09ICdudW1iZXInXHJcbiAgICAgICAgICAgICYmIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcHJvcGVydGllc1t0aGlzLmF0dHJdID0gcHJvcGVydGllc1t0aGlzLm1pbnVlbmRdIC0gcHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2x5Z29uXCIgfHwgZ2VvbWV0cnkudHlwZSA9PSBcIk11bHRpUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFzUG9seWdvbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBwb2x5Z29ucyA9IHRoaXMucHJvY2Vzc1BvbHlnb24oeyBnZW9tZXRyeSwgcHJvcGVydGllcyB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRCb3JkZXJzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUcmlhbmdsZXMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyVCA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJCID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHBvbHlnb25zLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmlhbmdsZXNwb2x5Z29uID0gcG9seWdvbnNbal0udHJpYW5nbGVzO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyID0gcG9seWdvbnNbal0udmVydGV4O1xyXG4gICAgICAgICAgICAgICAgY3VycmVudFRyaWFuZ2xlc1tqXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJvcmRlcnNbal0gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGggPSAwOyBoIDwgdHJpYW5nbGVzcG9seWdvbi5sZW5ndGg7IGgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShib3JkZXJbdHJpYW5nbGVzcG9seWdvbltoXSAqIDJdLCBib3JkZXJbdHJpYW5nbGVzcG9seWdvbltoXSAqIDIgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFRyaWFuZ2xlc1tqXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaCA9PSB0cmlhbmdsZXNwb2x5Z29uLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyVC5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRUcmlhbmdsZXNbal0pO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJUW2pdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHZlcnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyVFtqXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclRbal0ubnVtSXRlbXMgPSB2ZXJ0QXJyYXkubGVuZ3RoIC8gMjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYm9yZGVyLmxlbmd0aDsgeSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGJvcmRlclt5XSwgYm9yZGVyW3kgKyAxXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJvcmRlcnNbal0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHkgPT0gYm9yZGVyLmxlbmd0aCAtIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQi5wdXNoKGdsLmNyZWF0ZUJ1ZmZlcigpKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2ZXJ0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KGN1cnJlbnRCb3JkZXJzW2pdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyQltqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckJbal0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCW2pdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vcG9seWdvblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIGJ1ZmZlclQsIGJ1ZmZlckIsIFtdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2ludFwiICYmIHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vZHVtXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJQID0gW107XHJcbiAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50UG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyUFswXSk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlclBbMF0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICBidWZmZXJQWzBdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIFtdLCBbXSwgYnVmZmVyUCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzID09IG51bGwgfHwgdGhpcy50cmVlcG9pbnRzID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVwb2ludHMucHVzaCh7IGxvbjogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGxhdDogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIHByb3BlcnRpZXMgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09IFwiUG9pbnRcIiAmJiB0aGlzLmR5bmFtaWMgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy9kZWJ1Z2dlcjtcclxuICAgICAgICAgICAgdmFyIHBpeGVsID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKGdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHMgPT0gbnVsbCB8fCB0aGlzLnRlbXBQb2ludHMgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBQb2ludHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgYSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZW1wUG9pbnRzW2FdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFlc2FycmF5cyA9IHRoaXMuZml0RmVhdHVyZShwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXNhcnJheXMubGVuZ3RoOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGVtcFBvaW50c1thZXNhcnJheXNbeV1dLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVwb2ludHMgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVwb2ludHMucHVzaCh7IGxvbjogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGxhdDogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIHByb3BlcnRpZXMgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHByb2Nlc3NQb2x5Z29uKHBvbHlnb24pIHtcclxuICAgICAgICBpZiAocG9seWdvbi5nZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5zaWRlcG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgIC8vaW5zaWRlcG9seWdvbnMucHVzaChwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcFZlcnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChvdXRzaWRlcG9seWdvbltvdXRdWzBdLCBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXhjb3VudCArPSAob3V0c2lkZXBvbHlnb24ubGVuZ3RoICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvbjogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzBdICsgXCIgbGF0OiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB2YXIgdHJpYW5nbGVzX3ZlcnQgPSBlYXJjdXQodGVtcFZlcnRzKTtcclxuICAgICAgICAgICAgX3RyaWNvdW50ICs9ICh0cmlhbmdsZXNfdmVydC5sZW5ndGggLyAzKTtcclxuICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0ZXg6IHRlbXBWZXJ0cyB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKHBvbHlnb24uZ2VvbWV0cnkudHlwZSA9PSBcIk11bHRpUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBwb2x5YXJyYXkgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIG91dHNpZGVwb2x5Z29uID0gcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tpXVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zaWRlcG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAxOyBrIDwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tpXS5sZW5ndGg7IGsrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vdG9kbyBpbnNpZGUgcG9seWdvblxyXG4gICAgICAgICAgICAgICAgICAgIGluc2lkZXBvbHlnb25zLnB1c2gocG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlc1tpXVtrXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgdGVtcFZlcnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBfdmVydGV4Y291bnQgKz0gb3V0c2lkZXBvbHlnb24ubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgb3V0ID0gMDsgb3V0IDwgb3V0c2lkZXBvbHlnb24ubGVuZ3RoIC0gMTsgb3V0KyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChvdXRzaWRlcG9seWdvbltvdXRdWzBdLCBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvbjogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzBdICsgXCIgbGF0OiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgdGVtcCA9IGVhcmN1dC5mbGF0dGVuKHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgLy92YXIgdHJpYW5nbGVzX3ZlcnQgPSBlYXJjdXQodGVtcC52ZXJ0aWNlcywgdGVtcC5ob2xlcywgdGVtcC5kaW1lbnNpb25zKTtcclxuICAgICAgICAgICAgICAgIF90cmljb3VudCArPSAodHJpYW5nbGVzX3ZlcnQubGVuZ3RoIC8gMyk7XHJcbiAgICAgICAgICAgICAgICBwb2x5YXJyYXkucHVzaCh7IHRyaWFuZ2xlczogdHJpYW5nbGVzX3ZlcnQsIHZlcnRleDogdGVtcFZlcnRzIH0pO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhwb2x5YXJyYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5YXJyYXk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmNoZWNrUHJvcGVydHkocHJvcGVydGllc1t0aGlzLmFlc3RoZXRpY3NbaV0uZ2V0QXR0cigpXSkgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZXN0aGV0aWNzW2ldLmFkZEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKTtcclxuICAgICAgICAgICAgICAgIGZsYWcgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZmxhZykge1xyXG4gICAgICAgICAgICAvL1RPRE9cclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlRPRE86IGZlYXR1cmUgZG9lcyBub3QgZml0IGludG8gYW55IG9mIHRoZSBhZXN0aGV0aWNzIGRlZmluZWQuXFxuIFZhbHVlOiBcIiArIHByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGxhdExvbmdUb1BpeGVsWFkobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIGNvbnN0IHBpXzE4MCA9IE1hdGguUEkgLyAxODAuMDtcclxuICAgICAgICBjb25zdCBwaV80ID0gTWF0aC5QSSAqIDQ7XHJcbiAgICAgICAgY29uc3Qgc2luTGF0aXR1ZGUgPSBNYXRoLnNpbihsYXRpdHVkZSAqIHBpXzE4MCk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxZID0gKDAuNSAtIE1hdGgubG9nKCgxICsgc2luTGF0aXR1ZGUpIC8gKDEgLSBzaW5MYXRpdHVkZSkpIC8gKHBpXzQpKSAqIDI1NjtcclxuICAgICAgICBjb25zdCBwaXhlbFggPSAoKGxvbmdpdHVkZSArIDE4MCkgLyAzNjApICogMjU2O1xyXG5cclxuICAgICAgICBjb25zdCBwaXhlbCA9IHsgeDogcGl4ZWxYLCB5OiBwaXhlbFkgfTtcclxuICAgICAgICByZXR1cm4gcGl4ZWw7XHJcbiAgICB9XHJcblxyXG4gICAgZml0RmVhdHVyZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1thXS5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbdGhpcy5hZXN0aGV0aWNzW2FdLmdldEF0dHIoKV0pID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBidWlsZFRyZWVzKGdlb2pzb24pIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMudGVtcFBvaW50cy5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGVtcFBvaW50c1t0XS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy50ZW1wUG9pbnRzW3RdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlclBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0R3JvdXBlZEZlYXR1cmUodCwgW10sIFtdLCBidWZmZXJQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKGdlb2pzb24pXHJcbiAgICAgICAgaWYgKHRoaXMudHJlZXBvaW50cyAhPSBudWxsKVxyXG4gICAgICAgICAgICB0aGlzLmtkdHJlZSA9IG5ldyBrZFRyZWUodGhpcy50cmVlcG9pbnRzLCAoYSwgYikgPT4gKGEubG9uIC0gYi5sb24pICoqIDIgKyAoYS5sYXQgLSBiLmxhdCkgKiogMiwgW1wibG9uXCIsIFwibGF0XCIsIFwicHJvcGVydGllc1wiXSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUG9seWdvbnMgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5ydHJlZSA9IG5ldyBQb2x5Z29uTG9va3VwKGdlb2pzb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEdyb3VwZWRGZWF0dXJlKGlkYWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljc1tpZGFlc10uYWRkR3JvdXBlZEZlYXR1cmUobnVsbCwgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpO1xyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLm1hcC5jcmVhdGVDYW52YXModGhpcy5pZCk7XHJcblxyXG4gICAgICAgIC8vaW5pdCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wgPSB7XHJcbiAgICAgICAgICAgIGdsOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5wcm9qZWN0aW9uLnNldChbMiAvIGNhbnZhcy53aWR0aCwgMCwgMCwgMCwgMCwgLTIgLyBjYW52YXMuaGVpZ2h0LCAwLCAwLCAwLCAwLCAwLCAwLCAtMSwgMSwgMCwgMV0pO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5vZmZzZXRXaWR0aCwgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5kaXNhYmxlKHRoaXMuX3dlYmdsLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE51bWJlck9mRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlUHJvamVjdGlvbihtYXRyaXgsIHNjYWxlWCwgc2NhbGVZKSB7XHJcbiAgICAgICAgLy8gc2NhbGluZyB4IGFuZCB5LCB3aGljaCBpcyBqdXN0IHNjYWxpbmcgZmlyc3QgdHdvIHJvd3Mgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzBdICo9IHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMV0gKj0gc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFsyXSAqPSBzY2FsZVg7XHJcbiAgICAgICAgbWF0cml4WzNdICo9IHNjYWxlWDtcclxuXHJcbiAgICAgICAgbWF0cml4WzRdICo9IHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbNV0gKj0gc2NhbGVZO1xyXG4gICAgICAgIG1hdHJpeFs2XSAqPSBzY2FsZVk7XHJcbiAgICAgICAgbWF0cml4WzddICo9IHNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeCwgdHgsIHR5KSB7XHJcbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgaW4gbGFzdCByb3cgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzEyXSArPSBtYXRyaXhbMF0gKiB0eCArIG1hdHJpeFs0XSAqIHR5O1xyXG4gICAgICAgIG1hdHJpeFsxM10gKz0gbWF0cml4WzFdICogdHggKyBtYXRyaXhbNV0gKiB0eTtcclxuICAgICAgICBtYXRyaXhbMTRdICs9IG1hdHJpeFsyXSAqIHR4ICsgbWF0cml4WzZdICogdHk7XHJcbiAgICAgICAgbWF0cml4WzE1XSArPSBtYXRyaXhbM10gKiB0eCArIG1hdHJpeFs3XSAqIHR5O1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3VHJpYW5nbGVzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdCb3JkZXJzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAwLjApO1xyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuc3Ryb2tlQ29sb3JbMF0gLyAyNTUsIGFlcy5zdHJva2VDb2xvclsxXSAvIDI1NSwgYWVzLnN0cm9rZUNvbG9yWzJdIC8gMjU1LCBhZXMuc3Ryb2tlQ29sb3JbM10pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX0xPT1AsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvaW50cyhhZXMpIHtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA0LjAgKyBhZXMucG9pbnRTaXplLCBhZXMucG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAxLjApO1xyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWVzLl9mZWF0dXJlcy5sZW5ndGggJiYgdGhpcy5keW5hbWljID09IHRydWU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50cy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50c1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuZHluYW1pYyA9PSBmYWxzZSAmJiBhZXMuX2FsbEZlYXR1cmVzICE9IG51bGwgJiYgaSA8IGFlcy5fYWxsRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMtMik7XHRcclxuICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHVjb2xvcjtcclxuICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdO1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSkucmdiKCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSArIGRpZmYgLyB0aGlzLm1heCAvIDIpLnJnYigpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgLSBkaWZmIC8gdGhpcy5taW4gLyAyKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWNvbG9yID0gW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIHVjb2xvclswXSAvIDI1NSwgdWNvbG9yWzFdIC8gMjU1LCB1Y29sb3JbMl0gLyAyNTUsIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlcy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlc1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UHJvcG9yY2lvbmFsUG9pbnRzKGFlcykge1xyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCB0aGlzLmFscGhhKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBhZXMuX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHkgaW4gYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3B2YWx1ZSA9IHBhcnNlRmxvYXQoYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKCh0aGlzLm1heHBvaW50c2l6ZSAtIHRoaXMubWlucG9pbnRzaXplKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSkgKiAocHJvcHZhbHVlIC0gdGhpcy5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNC4wICsgdGVtcHBvaW50c2l6ZSAqIGN1cnJlbnRab29tIC8gNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLm1heCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5taW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtKCk7XHJcbiAgICAgICAgbGV0IG1hcHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChtYXBzW2ldLmlkID09IHRoaXMuaWQpXHJcbiAgICAgICAgICAgICAgICBtYXBwb3MgPSBpO1xyXG4gICAgICAgIHRoaXMubWFwLm9uRXZlbnQoJ21vdmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFJ1aTogbXVkYXIgbyBwcm9maWxpbmcgZG8gd2luZG93IHBhcmEgb3V0cmEgY29pc2E/XCIpXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBtYXBzW21hcHBvc10uZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIFpvb20vUGFuIChzZWd1bmRvcyk6JHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNldHVwT25jbGljayhtYXBwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwT25jbGljayhtYXBwb3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkBSdWk6IHByb2ZpbGluZyBtdWRhciBkZSB3aW5kb3cgcGFyYT8gfCBSdHJlZSBlIEtkVHJlZVwiKVxyXG4gICAgICAgIG1hcHNbbWFwcG9zXS5tYXAub25FdmVudCgnY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGUubGF0bG5nLmxhdDtcclxuICAgICAgICAgICAgY29uc3QgbG9uID0gZS5sYXRsbmcubG5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5ydHJlZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib29sID0gbWFwc1swXS5ydHJlZS5zZWFyY2gobG9uLCBsYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvb2wgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljay5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7bWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpICsgMV19OiAke2Jvb2wucHJvcGVydGllc1ttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYm9vbC5wcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0gIT0gXCJfZ2lzcGxheWlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7a2V5c1tpXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW2tleXNbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uaW50ZXJhY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQocyk7Ly90b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQgJiYgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbChib29sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLmtkdHJlZSAhPSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0ID0gbWFwc1ttYXBwb3NdLmtkdHJlZS5uZWFyZXN0KHsgbGF0LCBsb24gfSwgMSwgMTI4IC8gKCgyICoqIChtYXAuZ2V0Wm9vbSgpICogMikpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdC5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9vbCA9IG5lYXJlc3RbMF1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhib29sLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXSAhPSBcIl9naXNwbGF5aWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5pbnRlcmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZCAmJiBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsKGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIHVtIGNsaWNrIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApIHtcclxuICAgICAgICBpZiAob3B0aW9ucy5jdXN0b21NYXBTZXJ2aWNlID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gYmdtYXA7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICB0aGlzLm1hcCA9IG5ldyBCR01hcFdyYXBwZXIoYmdtYXApO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmxvYWRlciAhPSBmYWxzZSlcclxuICAgICAgICAgICAgdGhpcy5sb2FkZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdGlvbnMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93UHJvcGVydGllc09uQ2xpY2sgPSBudWxsO1xyXG4gICAgICAgICAgICAvL2FwcGVuZCBvbiBiZ21hcCBvYmplY3RcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgLy9uYWRhXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dQcm9wZXJ0aWVzT25DbGljayA9IG9wdGlvbnMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFscGhhID0gb3B0aW9ucy5hbHBoYSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmFscGhhIDogMC44O1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSBvcHRpb25zLmludGVyYWN0aXZlID09IHVuZGVmaW5lZCA/IHRydWUgOiAhb3B0aW9ucy5pbnRlcmFjdGl2ZTtcclxuICAgICAgICB0aGlzLmF0dHIgPSBvcHRpb25zLmF0dHI7XHJcbiAgICAgICAgdGhpcy5keW5hbWljID0gb3B0aW9ucy5tZW1vcnlTYXZlciA9PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFvcHRpb25zLm1lbW9yeVNhdmVyO1xyXG4gICAgICAgIHRoaXMubWF4ZmVhdHVyZXMgPSBvcHRpb25zLm1heEZlYXR1cmVzO1xyXG4gICAgICAgIHRoaXMuYnJlYWtzID0gb3B0aW9ucy5jbGFzc0JyZWFrcztcclxuICAgICAgICB0aGlzLmNvbG9yc2NoZW1lID0gb3B0aW9ucy5jb2xvclNjaGVtZTtcclxuICAgICAgICB0aGlzLm51bWJlcm9mY2xhc3NlcyA9IG9wdGlvbnMubnVtYmVyT2ZDbGFzc2VzO1xyXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gb3B0aW9ucy5jbGFzc0JyZWFrc01ldGhvZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9uQ2xpY2tDYWxsID0gb3B0aW9ucy5sZWdlbmRPbkNsaWNrRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5tYXBPbkNsaWNrQ2FsbCA9IG9wdGlvbnMubWFwT25DbGlja0Z1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMubWludWVuZCA9IG9wdGlvbnMubWludWVuZDtcclxuICAgICAgICB0aGlzLnN1YnRyYWhlbmQgPSBvcHRpb25zLnN1YnRyYWhlbmQ7XHJcbiAgICAgICAgdGhpcy5sZWdlbmRUaXRsZSA9IG9wdGlvbnMubGVnZW5kVGl0bGUgIT0gdW5kZWZpbmVkID8gb3B0aW9ucy5sZWdlbmRUaXRsZSA6ICh0aGlzLmF0dHIgIT0gdW5kZWZpbmVkID8gdGhpcy5hdHRyIDogYCR7dGhpcy5taW51ZW5kfSAtICR7dGhpcy5zdWJ0cmFoZW5kfWApO1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyA9IG9wdGlvbnMubnVtYmVyT2ZMZWdlbmRJdGVtcyAhPSB1bmRlZmluZWQgPyBvcHRpb25zLm51bWJlck9mTGVnZW5kSXRlbXMgOiAyO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRlcigpIHtcclxuICAgICAgICB0aGlzLm1hcC5sb2FkZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROdW1iZXJPZlBvbHlnb25zKCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzW3pdLl90cmlhbmdsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxuXHJcbiAgICAvL1NUQVRJQyBNRVRIT0RTKHNob3VsZCBiZSBpbXBsZW1lbnRlZCBieSBzdWItY2xhc3NlcylcclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgYWxlcnQoXCJkcmF3KCkgbm90IGltcGxlbWVudGVkXCIpOy8vdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgd2FzIGNyZWF0ZWQgZm9yIEhlYXQgTWFwcy4gQW5vdGhlciBpZGVhIHdpbGwgcHJvYmFibHkgYmUgdXNlZC5cclxuICAgICAqIEBwYXJhbSB7QWVzdGhldGljfSBhZXMgXHJcbiAgICAgKi9cclxuICAgIGRyYXdIZWF0UG9pbnRzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnZGVsdGEnKTtcclxuICAgICAgICBjb25zdCBpbnRlbnNpdHlMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ2ludGVuc2l0eScpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnYVBvaW50U2l6ZScpO1xyXG5cclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbHRhTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGludGVuc2l0eUxvYyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDAgKiAyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbHRhTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCAyICogNCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbnRlbnNpdHlMb2MsIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCA0ICogNCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuXHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0pO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImZhc2UgMSBjb25jbHVpZGFcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzb3VyY2UpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY2FudmFzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb3dlck9mMih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3RldXBUZXh0dXJlRmlsdGVyaW5nQW5kTWlwcyh3aWR0aCwgaGVpZ2h0LCBnbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQb3dlck9mMih3aWR0aCkgJiYgaXNQb3dlck9mMihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGltZW5zaW9ucyBhcmUgcG93ZXIgb2YgMiBzbyBnZW5lcmF0ZSBtaXBzIGFuZCB0dXJuIG9uIFxyXG4gICAgICAgICAgICAgICAgLy8gdHJpLWxpbmVhciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgbm90IGEgcG93ZXIgb2YgMiBzbyBzZXQgdGhlIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gc28gV2ViR0wgd2lsbCByZW5kZXIgaXQuXHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBzdGV1cFRleHR1cmVGaWx0ZXJpbmdBbmRNaXBzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCwgZ2wpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDEsIC0xLCAxLCAtMSwgLTEsIDEsIDEsIC0xLCAtMSwgMSwgLTFdKTtcclxuICAgICAgICBjb25zdCBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICBjb25zdCBwb3NpdGlvbkxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzFdLCAncG9zaXRpb24nKTtcclxuICAgICAgICBjb25zdCBzb3VyY2VMb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0sICdzb3VyY2UnKTtcclxuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvYyk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvYywgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcclxuICAgICAgICBnbC51bmlmb3JtMWkoc291cmNlTG9jLCAwKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XHJcblxyXG5cclxuICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2MpO1xyXG4gICAgICAgIC8vZGVmYXVsdHMgdG8gZ2VuZXJhbCBwcm9ncmFtXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImZhc2UgMiBjb25jbHVpZGFcIik7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wucHJvZ3JhbSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9NYXAuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTs7OztBQUlBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyQkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQXVCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0REE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBdURBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/Gisplay/Aesthetic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 6);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class that represents an aesthetic element. There will be one Aesthetic class for each class on the Legend.\r\n * \r\n * @export\r\n * @class Aesthetic\r\n */\nvar Aesthetic = exports.Aesthetic = function () {\n\n  /**\r\n   * Creates an instance of Aesthetic. \r\n   * There will be as many Aesthetic objects as the number of classes on the Legend. \r\n   * @example 1-> {\"id\":0,\"attr\":\"f3\",\"fcolor\":[255,255,255,0.8],\r\n   *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[1,37]}\r\n   * @example 2-> {\"id\":1,\"attr\":\"f3\",\"fcolor\":[255,255,0,0.8],\r\n   *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[37,78]}\r\n   * @param {number} id - The unique id of the Aesthetic object.\r\n   * @param {string} attr - The attribute being mapped on this Aesthetic.\r\n   * @param {number[]} fcolor - The color to fill the Aesthetic element(RGBA).\r\n   * @param {number[]} stroke - Stroke color values(RGBA).\r\n   * @param {number|null} pointsize - Size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n   * @param {number[]} range - The range for this particular Aesthetic element.\r\n   * \r\n   * @memberOf Aesthetic\r\n   */\n  function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n    _classCallCheck(this, Aesthetic);\n\n    /**\r\n     * The unique id of the Aesthetic object. \r\n     * @type {number}\r\n     */\n    this.id = id;\n    /**\r\n     * The attribute being mapped on the Aesthetic.\r\n     * @type {string}\r\n     */\n    this._attr = attr;\n    /**\r\n     * The color to fill the Aesthetic element(RGBA).\r\n     * @type {number[4]}\r\n     */\n    this.fillColor = fcolor;\n    /**\r\n     * Stroke color values(RGBA).\r\n     * @type {number[4]}\r\n     */\n    this.strokeColor = stroke;\n    /**\r\n     * The size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n     * @type {number|null}\r\n     */\n    this.pointSize = pointsize == null ? 1.0 : parseFloat(pointsize);\n    /**\r\n     * The range for this particular Aesthetic element.\r\n     * @type {number[2]}\r\n     */\n    this.range = range;\n    /**\r\n     * This Array will keep track of all Features associated with this Aesthetic object.\r\n     * @type {Array<Feature>}\r\n     */\n    this._features = new Array();\n    /**\r\n     * This Array is used for? \r\n     * @todo\r\n     * @type {Array<Feature>}\r\n     */\n    this._allFeatures = null;\n    /**\r\n     * This particular element will be active or not in the Legend.\r\n     * @type {boolean}\r\n     */\n    this.enabled = true; //Elemento da legenda ativado ou desativado\n    /**\r\n     * Outer of? This is used for what?\r\n     * @type {boolean}\r\n     */\n    this.outer = false;\n    return this; //@TODO remove this\n  }\n\n  /**\r\n   * Adds a new feature to this Aesthetic object.\r\n   * @param {number} id - The Feature id. Each feature will have a different id inside this Aesthetic object.\r\n   * @param {{fx: string, _gisplayid:number}} properties - Properties associated with the Feature.\r\n   * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with the Feature.\r\n   * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with the Feature.\r\n   * @param {number[]} points - The points that belong to the Feature.\r\n   * \r\n   * @memberOf Aesthetic\r\n   */\n\n\n  _createClass(Aesthetic, [{\n    key: 'addFeature',\n    value: function addFeature(id, properties, triangles, borders, points) {\n      this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n    }\n\n    /**\r\n     * Gets this Aesthetic attribute.\r\n     * @returns {Aesthetic._attr} - The string representing the attr of this Aesthetic.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n\n  }, {\n    key: 'getAttr',\n    value: function getAttr() {\n      return this._attr;\n    }\n\n    /**\r\n     * Verifies the existence or not of the property Aesthethic._attr and if it fits inside this Aesthetic range.\r\n     * @param {string} value - The attribute ?.\r\n     * @returns {boolean} - True if there's no range or it is inside the range or ?, otherwise, false.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n\n  }, {\n    key: 'checkProperty',\n    value: function checkProperty(value) {\n      if (this.range == null) return true;else {\n        if (typeof value === 'number') return (this.range[0] == null || value >= this.range[0]) && (this.range[1] == null || value < this.range[1] || value <= this.range[1] && this.outer == true);else return value == this.range[0];\n      }\n    }\n\n    /**\r\n     * Add new grouped feature ? \r\n     * @todo Finish document of this method.\r\n     * @param {number} id \r\n     * @param {null} triangles - Always empty? See line:479 Map.js\r\n     * @param {null} borders - Always empty? See line:479 Map.js \r\n     * @param {{buffer: WebGLBuffer, itemSize: number, numItems: number}} points \r\n     */\n\n  }, {\n    key: 'addGroupedFeature',\n    value: function addGroupedFeature(id, triangles, borders, points) {\n      if (this._allFeatures == null) {\n        this._allFeatures = new Array();\n        this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n      } else {\n        var cursor = 0; //TODO\n        //this._allFeatures[0]._properties.push(properties);\n        this._allFeatures[cursor].push(new _Feature.Feature(id, null, triangles, borders, points));\n        //this._allFeatures[cursor]._triangles.concat(triangles);\n        //this._allFeatures[cursor]._borders.concat(borders);\n      }\n    }\n\n    /**\r\n     * Inverts this Aesthetic element state in the Legend object.\r\n     * If it was enabled it will be disabled or vice-versa.\r\n     * @returns {boolean} Inverse of current enabled value.\r\n     */\n\n  }, {\n    key: 'enableDisable',\n    value: function enableDisable() {\n      this.enabled = !this.enabled;\n      return this.enabled;\n    }\n  }]);\n\n  return Aesthetic;\n}();\n\n/*var obj = {\r\n           i: id,\r\n           a: attr,\r\n           f: fcolor,\r\n           s: stroke,\r\n           p: pointsize,\r\n           r: range\r\n       }\r\n       console.warn(\"Aest called constructor!!! == \" + JSON.stringify(obj));*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9BZXN0aGV0aWMuanM/NTllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi9GZWF0dXJlJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYW4gYWVzdGhldGljIGVsZW1lbnQuIFRoZXJlIHdpbGwgYmUgb25lIEFlc3RoZXRpYyBjbGFzcyBmb3IgZWFjaCBjbGFzcyBvbiB0aGUgTGVnZW5kLlxyXG4gKiBcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQWVzdGhldGljXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWVzdGhldGljIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQWVzdGhldGljLiBcclxuICAgICAqIFRoZXJlIHdpbGwgYmUgYXMgbWFueSBBZXN0aGV0aWMgb2JqZWN0cyBhcyB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb24gdGhlIExlZ2VuZC4gXHJcbiAgICAgKiBAZXhhbXBsZSAxLT4ge1wiaWRcIjowLFwiYXR0clwiOlwiZjNcIixcImZjb2xvclwiOlsyNTUsMjU1LDI1NSwwLjhdLFxyXG4gICAgICogICAgICAgICBcInN0cm9rZVwiOlswLDAsMCwxXSxcInBvaW50c2l6ZVwiOm51bGwsXCJyYW5nZVwiOlsxLDM3XX1cclxuICAgICAqIEBleGFtcGxlIDItPiB7XCJpZFwiOjEsXCJhdHRyXCI6XCJmM1wiLFwiZmNvbG9yXCI6WzI1NSwyNTUsMCwwLjhdLFxyXG4gICAgICogICAgICAgICBcInN0cm9rZVwiOlswLDAsMCwxXSxcInBvaW50c2l6ZVwiOm51bGwsXCJyYW5nZVwiOlszNyw3OF19XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgdW5pcXVlIGlkIG9mIHRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBUaGUgYXR0cmlidXRlIGJlaW5nIG1hcHBlZCBvbiB0aGlzIEFlc3RoZXRpYy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGZjb2xvciAtIFRoZSBjb2xvciB0byBmaWxsIHRoZSBBZXN0aGV0aWMgZWxlbWVudChSR0JBKS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHN0cm9rZSAtIFN0cm9rZSBjb2xvciB2YWx1ZXMoUkdCQSkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBwb2ludHNpemUgLSBTaXplIG9mIHRoZSBBZXN0aGV0aWMgcG9pbnQgdG8gYmUgZHJhd24gKFVzZWQgb25seSBpbiBtYXBzIHRoYXQgcmVxdWlyZSBkb3RzIHRvIGJlIGRyYXduKS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJhbmdlIC0gVGhlIHJhbmdlIGZvciB0aGlzIHBhcnRpY3VsYXIgQWVzdGhldGljIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIGF0dHIsIGZjb2xvciwgc3Ryb2tlLCBwb2ludHNpemUsIHJhbmdlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuaXF1ZSBpZCBvZiB0aGUgQWVzdGhldGljIG9iamVjdC4gXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSBiZWluZyBtYXBwZWQgb24gdGhlIEFlc3RoZXRpYy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2F0dHIgPSBhdHRyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xvciB0byBmaWxsIHRoZSBBZXN0aGV0aWMgZWxlbWVudChSR0JBKS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyWzRdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0cm9rZSBjb2xvciB2YWx1ZXMoUkdCQSkuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcls0XX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gc3Ryb2tlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBBZXN0aGV0aWMgcG9pbnQgdG8gYmUgZHJhd24gKFVzZWQgb25seSBpbiBtYXBzIHRoYXQgcmVxdWlyZSBkb3RzIHRvIGJlIGRyYXduKS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludFNpemUgPSBwb2ludHNpemUgPT0gbnVsbCA/IDEuMCA6IHBhcnNlRmxvYXQocG9pbnRzaXplKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmFuZ2UgZm9yIHRoaXMgcGFydGljdWxhciBBZXN0aGV0aWMgZWxlbWVudC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyWzJdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIEFycmF5IHdpbGwga2VlcCB0cmFjayBvZiBhbGwgRmVhdHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIEFycmF5IGlzIHVzZWQgZm9yPyBcclxuICAgICAgICAgKiBAdG9kb1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGZWF0dXJlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBwYXJ0aWN1bGFyIGVsZW1lbnQgd2lsbCBiZSBhY3RpdmUgb3Igbm90IGluIHRoZSBMZWdlbmQuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTsvL0VsZW1lbnRvIGRhIGxlZ2VuZGEgYXRpdmFkbyBvdSBkZXNhdGl2YWRvXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3V0ZXIgb2Y/IFRoaXMgaXMgdXNlZCBmb3Igd2hhdD9cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vQFRPRE8gcmVtb3ZlIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZmVhdHVyZSB0byB0aGlzIEFlc3RoZXRpYyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgRmVhdHVyZSBpZC4gRWFjaCBmZWF0dXJlIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCBpZCBpbnNpZGUgdGhpcyBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHt7Zng6IHN0cmluZywgX2dpc3BsYXlpZDpudW1iZXJ9fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gdHJpYW5nbGVzIC0gTnVtYmVyIG9mIHRyaWFuZ2xlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIE51bWJlciBvZiBib3JkZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFRoZSBwb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGlzIEFlc3RoZXRpYyBhdHRyaWJ1dGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QWVzdGhldGljLl9hdHRyfSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyIG9mIHRoaXMgQWVzdGhldGljLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGdldEF0dHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyB0aGUgZXhpc3RlbmNlIG9yIG5vdCBvZiB0aGUgcHJvcGVydHkgQWVzdGhldGhpYy5fYXR0ciBhbmQgaWYgaXQgZml0cyBpbnNpZGUgdGhpcyBBZXN0aGV0aWMgcmFuZ2UuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgYXR0cmlidXRlID8uXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZXJlJ3Mgbm8gcmFuZ2Ugb3IgaXQgaXMgaW5zaWRlIHRoZSByYW5nZSBvciA/LCBvdGhlcndpc2UsIGZhbHNlLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGNoZWNrUHJvcGVydHkodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5yYW5nZSA9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgodGhpcy5yYW5nZVswXSA9PSBudWxsIHx8IHZhbHVlID49IHRoaXMucmFuZ2VbMF0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucmFuZ2VbMV0gPT0gbnVsbCB8fCAodmFsdWUgPCB0aGlzLnJhbmdlWzFdIHx8ICh2YWx1ZSA8PSB0aGlzLnJhbmdlWzFdICYmIHRoaXMub3V0ZXIgPT0gdHJ1ZSkpKSk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT0gdGhpcy5yYW5nZVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkIG5ldyBncm91cGVkIGZlYXR1cmUgPyBcclxuICAgICAqIEB0b2RvIEZpbmlzaCBkb2N1bWVudCBvZiB0aGlzIG1ldGhvZC5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCBcclxuICAgICAqIEBwYXJhbSB7bnVsbH0gdHJpYW5nbGVzIC0gQWx3YXlzIGVtcHR5PyBTZWUgbGluZTo0NzkgTWFwLmpzXHJcbiAgICAgKiBAcGFyYW0ge251bGx9IGJvcmRlcnMgLSBBbHdheXMgZW1wdHk/IFNlZSBsaW5lOjQ3OSBNYXAuanMgXHJcbiAgICAgKiBAcGFyYW0ge3tidWZmZXI6IFdlYkdMQnVmZmVyLCBpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gcG9pbnRzIFxyXG4gICAgICovXHJcbiAgICBhZGRHcm91cGVkRmVhdHVyZShpZCwgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWxsRmVhdHVyZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gMDsgLy9UT0RPXHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxsRmVhdHVyZXNbMF0uX3Byb3BlcnRpZXMucHVzaChwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsRmVhdHVyZXNbY3Vyc29yXS5wdXNoKG5ldyBGZWF0dXJlKGlkLCBudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgICAgICAgICAvL3RoaXMuX2FsbEZlYXR1cmVzW2N1cnNvcl0uX3RyaWFuZ2xlcy5jb25jYXQodHJpYW5nbGVzKTtcclxuICAgICAgICAgICAgLy90aGlzLl9hbGxGZWF0dXJlc1tjdXJzb3JdLl9ib3JkZXJzLmNvbmNhdChib3JkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnRzIHRoaXMgQWVzdGhldGljIGVsZW1lbnQgc3RhdGUgaW4gdGhlIExlZ2VuZCBvYmplY3QuXHJcbiAgICAgKiBJZiBpdCB3YXMgZW5hYmxlZCBpdCB3aWxsIGJlIGRpc2FibGVkIG9yIHZpY2UtdmVyc2EuXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSW52ZXJzZSBvZiBjdXJyZW50IGVuYWJsZWQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIGVuYWJsZURpc2FibGUoKSB7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gIXRoaXMuZW5hYmxlZDtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmFibGVkO1xyXG4gICAgfVxyXG59XHJcblxyXG4gLyp2YXIgb2JqID0ge1xyXG4gICAgICAgICAgICBpOiBpZCxcclxuICAgICAgICAgICAgYTogYXR0cixcclxuICAgICAgICAgICAgZjogZmNvbG9yLFxyXG4gICAgICAgICAgICBzOiBzdHJva2UsXHJcbiAgICAgICAgICAgIHA6IHBvaW50c2l6ZSxcclxuICAgICAgICAgICAgcjogcmFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiQWVzdCBjYWxsZWQgY29uc3RydWN0b3IhISEgPT0gXCIgKyBKU09OLnN0cmluZ2lmeShvYmopKTsqL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9BZXN0aGV0aWMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQkE7QUFBQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7OztBQUtBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBT0E7QUFDQTtBQUdBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7Ozs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/Maps/Choropleth.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    function Choropleth(bgmap, geometry, options) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, options));\n\n        _this.aesthetics = new Array();\n        _this.geometry = geometry;\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.type = 'CP';\n        maps.push(_this);\n        _this.initialize();\n        /*return this;*/\n        return _this;\n    }\n\n    //@override\n\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            //console.log(\"Choropleth drawaaa() called\");\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawTriangles(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            //console.log(\"Choropleth buildLegend() called\");\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPolygonRow(this.aesthetics[a], this);\n            }\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            //console.log(\"Choropleth defaults() called\");\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanM/ZjhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXAgfSBmcm9tICcuL01hcCc7XHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9wbGV0aCBpbXBsZW1lbnRhdGlvbiAwNi8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENob3JvcGxldGggZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSBtYXBjb3VudCsrO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDUCc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIC8qcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBkcmF3YWFhKCkgY2FsbGVkXCIpO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VHJpYW5nbGVzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBidWlsZExlZ2VuZCgpIGNhbGxlZFwiKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhIGluIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2x5Z29uUm93KHRoaXMuYWVzdGhldGljc1thXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNob3JvcGxldGggZGVmYXVsdHMoKSBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3doaXRlJywgJ3llbGxvdycsICdvcmFuZ2UnLCAncmVkJ107XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWJlck9mQ2xhc3NlcyA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Choropleth */ 3);\n\nvar _DotMap = __webpack_require__(/*! ./Maps/DotMap */ 10);\n\nvar _ChangeMap = __webpack_require__(/*! ./Maps/ChangeMap */ 8);\n\nvar _ProportionalSymbolsMap = __webpack_require__(/*! ./Maps/ProportionalSymbolsMap */ 11);\n\nvar _ChorochromaticMap = __webpack_require__(/*! ./Maps/ChorochromaticMap */ 9);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API entry point with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n\n    /**\r\n     * Creates an instance of the Gisplay API.\r\n     * \r\n     * @memberOf Gisplay\r\n     */\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        console.log(\"Gisplay Class constructor\");\n        /**\r\n         * TimeStamp at the beginning.\r\n         * @type {number} \r\n         */\n        this.startTimeStamp = 0;\n\n        /**\r\n         * Whether or not it  should profile the API.\r\n         * @type {string} - Whether or not it  should profile the API.\r\n         */\n        window.profiling = true;\n        /**\r\n         * @type {Array} - Array of maps. @WHY?\r\n         */\n        window.maps = new Array();\n        /**\r\n         * @type {number} - The number of maps. @WHY?\r\n         */\n        window.mapcount = 0;\n\n        //WebGL API\n        /**\r\n        * @type {number} - The number of vertices produced. @WHY?\r\n        */\n        window._vertexcount = 0;\n        /**\r\n        * @type {number} - The number of ???. @WHY?\r\n        */\n        window._tricount = 0;\n    }\n\n    /**\r\n     * Creates a map of type Choropleth.\r\n     * @param {Object} bgmap - Background map object be used(atm only MapBox being used).- Background map object be used(atm only MapBox being used).\r\n     * @param {JSON} geometry - The object that contains the data.\r\n     * @param {Object} options - Object that contains user personalization options.\r\n     * \r\n     * @memberOf Gisplay\r\n     */\n\n\n    _createClass(Gisplay, [{\n        key: 'makeChoropleth',\n        value: function makeChoropleth(bgmap, geometry, options) {\n            console.log(bgmap);\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Dot Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeDotMap',\n        value: function makeDotMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _DotMap.DotMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Change Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChangeMap',\n        value: function makeChangeMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChangeMap.ChangeMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Proportional Symbols Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeProportionalSymbolsMap',\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ProportionalSymbolsMap.ProportionalSymbolsMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui add options (n tinha WUT)\n        }\n\n        /**\r\n         * Creates a Chorocromatic Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The object that contains the data.\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChorochromaticMap',\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChorochromaticMap.ChorochromaticMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui .defaultid);\n        }\n\n        /**\r\n         * Function that executes all the process associated with the creation of thematic maps.\r\n         * @todo Should clean up this removing profiling code?\r\n         * @param {Map} gismap - The Gisplay Map to use (Choropleth, DotMap,etc).\r\n         * @param {Object} options - Object that contains user personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeMap',\n        value: function makeMap(gismap, options) {\n            var _this = this;\n\n            var defaultid = options.defaultid != null ? defaultid : 1;\n            setTimeout(function (console) {\n                var start = 0;\n                if (window.profiling == true) start = Date.now();\n                if (gismap.colorscheme == undefined) gismap.colorscheme = gismap.defaults(defaultid).colorScheme;\n                if (gismap.classbreaks == undefined) {\n                    if (gismap.numberofclasses == undefined) {\n                        gismap.numberofclasses = gismap.defaults(defaultid).numberOfClasses;\n                    }\n                    gismap.preProcessData(gismap.geometry, gismap.numberofclasses, gismap.algorithm, gismap.colorscheme);\n                }\n\n                //gismap.processData(gismap.geometry);\n                gismap.loadGeoJSON(gismap.geometry);\n                var start2 = 0;\n                if (window.profiling == true) {\n                    start2 = Date.now();\n                    window.console.log('Tempo de processamento do dados (segundos): ' + (start2 - start) / 1000);\n                }\n                gismap.draw();\n\n                var end = 0;\n                if (window.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo de desenho do mapa (segundos): ' + (end - start2) / 1000);\n                }\n                if (options.legend != false) gismap.buildLegend();\n                if (options.loader != false) {\n                    gismap.loader();\n                }\n                if (window.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo total (segundos): ' + (end - _this.startTimeStamp) / 1000);\n                }\n            }, 1);\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5LmpzPzA1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vTWFwcy9DaG9yb3BsZXRoJztcclxuaW1wb3J0IHsgRG90TWFwIH0gZnJvbSAnLi9NYXBzL0RvdE1hcCc7XHJcbmltcG9ydCB7IENoYW5nZU1hcCB9IGZyb20gJy4vTWFwcy9DaGFuZ2VNYXAnO1xyXG5pbXBvcnQgeyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIH0gZnJvbSAnLi9NYXBzL1Byb3BvcnRpb25hbFN5bWJvbHNNYXAnXHJcbmltcG9ydCB7IENob3JvY2hyb21hdGljTWFwIH0gZnJvbSAnLi9NYXBzL0Nob3JvY2hyb21hdGljTWFwJztcclxuXHJcbi8qKlxyXG4gKiBHaXNwbGF5IEFQSSBlbnRyeSBwb2ludCB3aXRoIG9uZSBtZXRob2QgZm9yIGVhY2ggbWFwIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHaXNwbGF5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIEdpc3BsYXkgQVBJLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkdpc3BsYXkgQ2xhc3MgY29uc3RydWN0b3JcIik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGltZVN0YW1wIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGl0ICBzaG91bGQgcHJvZmlsZSB0aGUgQVBJLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9IC0gV2hldGhlciBvciBub3QgaXQgIHNob3VsZCBwcm9maWxlIHRoZSBBUEkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2luZG93LnByb2ZpbGluZyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fSAtIEFycmF5IG9mIG1hcHMuIEBXSFk/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2luZG93Lm1hcHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgbWFwcy4gQFdIWT9cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cubWFwY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvL1dlYkdMIEFQSVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHR5cGUge251bWJlcn0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHByb2R1Y2VkLiBAV0hZP1xyXG4gICAgICAgICovXHJcbiAgICAgICAgd2luZG93Ll92ZXJ0ZXhjb3VudCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgPz8/LiBAV0hZP1xyXG4gICAgICAgICovXHJcbiAgICAgICAgd2luZG93Ll90cmljb3VudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIG9mIHR5cGUgQ2hvcm9wbGV0aC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS4tIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5XHJcbiAgICAgKi9cclxuICAgIG1ha2VDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGJnbWFwKTtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hvcm9wbGV0aChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIERvdCBNYXAuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYmdtYXAgLSBCYWNrZ3JvdW5kIG1hcCBvYmplY3QgYmUgdXNlZChhdG0gb25seSBNYXBCb3ggYmVpbmcgdXNlZCkuXHJcbiAgICAgKiBAcGFyYW0ge0pTT059IGdlb21ldHJ5IC0gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPYmplY3QgdGhhdCBjb250YWlucyB1c2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlRG90TWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBEb3RNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBDaGFuZ2UgTWFwLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNoYW5nZU1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgUHJvcG9ydGlvbmFsIFN5bWJvbHMgTWFwLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgZGF0YS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZVByb3BvcnRpb25hbFN5bWJvbHNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IFByb3BvcnRpb25hbFN5bWJvbHNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTsgLy9AUnVpIGFkZCBvcHRpb25zIChuIHRpbmhhIFdVVClcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBDaG9yb2Nyb21hdGljIE1hcC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIGRhdGEuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB0aGF0IGNvbnRhaW5zIHVzZXIgcGVyc29uYWxpemF0aW9uIG9wdGlvbnMuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBHaXNwbGF5XHJcbiAgICAgKi9cclxuICAgIG1ha2VDaG9yb2Nocm9tYXRpY01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hvcm9jaHJvbWF0aWNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTsvL0BSdWkgLmRlZmF1bHRpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIGFsbCB0aGUgcHJvY2VzcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNyZWF0aW9uIG9mIHRoZW1hdGljIG1hcHMuXHJcbiAgICAgKiBAdG9kbyBTaG91bGQgY2xlYW4gdXAgdGhpcyByZW1vdmluZyBwcm9maWxpbmcgY29kZT9cclxuICAgICAqIEBwYXJhbSB7TWFwfSBnaXNtYXAgLSBUaGUgR2lzcGxheSBNYXAgdG8gdXNlIChDaG9yb3BsZXRoLCBEb3RNYXAsZXRjKS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHRoYXQgY29udGFpbnMgdXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZU1hcChnaXNtYXAsIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdGlkID0gb3B0aW9ucy5kZWZhdWx0aWQgIT0gbnVsbCA/IGRlZmF1bHRpZCA6IDE7XHJcbiAgICAgICAgc2V0VGltZW91dChjb25zb2xlID0+IHtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jb2xvcnNjaGVtZSA9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBnaXNtYXAuY29sb3JzY2hlbWUgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5jb2xvclNjaGVtZTtcclxuICAgICAgICAgICAgaWYgKGdpc21hcC5jbGFzc2JyZWFrcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnaXNtYXAubnVtYmVyb2ZjbGFzc2VzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdpc21hcC5udW1iZXJvZmNsYXNzZXMgPSBnaXNtYXAuZGVmYXVsdHMoZGVmYXVsdGlkKS5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBnaXNtYXAucHJlUHJvY2Vzc0RhdGEoZ2lzbWFwLmdlb21ldHJ5LCBnaXNtYXAubnVtYmVyb2ZjbGFzc2VzLCBnaXNtYXAuYWxnb3JpdGhtLCBnaXNtYXAuY29sb3JzY2hlbWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvL2dpc21hcC5wcm9jZXNzRGF0YShnaXNtYXAuZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICBnaXNtYXAubG9hZEdlb0pTT04oZ2lzbWFwLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgbGV0IHN0YXJ0MiA9IDA7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0MiA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIHByb2Nlc3NhbWVudG8gZG8gZGFkb3MgKHNlZ3VuZG9zKTogJHsoc3RhcnQyIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBnaXNtYXAuZHJhdygpO1xyXG5cclxuICAgICAgICAgICAgbGV0IGVuZCA9IDA7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIGRlc2VuaG8gZG8gbWFwYSAoc2VndW5kb3MpOiAkeyhlbmQgLSBzdGFydDIpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQgIT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBnaXNtYXAuYnVpbGRMZWdlbmQoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVyICE9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBnaXNtYXAubG9hZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gdG90YWwgKHNlZ3VuZG9zKTogJHsoZW5kIC0gdGhpcy5zdGFydFRpbWVTdGFtcCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgMSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvR2lzcGxheS5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUFRQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!********************************************!*\
  !*** ./src/Gisplay/Maps/GisplayOptions.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class will contain all the options available on the Gisplay API.\r\n */\nvar GisplayOptions =\n\n/**\r\n * Creates a new Options object. User options take precedence over default options.\r\n * @param {Object} userOptions - The user defined options\r\n * @param {string} userOptions.attr -  The attribute to be mapped.\r\n * @param {string[]} [userOptions.colorScheme] -  The color scheme to be used.\r\n * @param {number} [userOptions.numberofclasses] -  Number of classes to be used on the map Legend.\r\n * @param {string} [userOptions.algorithm=quantile] -  Algorithm to be used by the API to calculate classes intervals. \r\n * @param {number[]} [userOptions.classBreaks=undefined] - Class intervals.\r\n * @param {boolean} [userOptions.interactive=true] - Show pop-up when the user clicks on a Feature.\r\n * @param {boolean} [userOptions.showPropertiesOnClick=null] - Show pop-up when the user clicks on a Feature.\r\n */\nexports.GisplayOptions = function GisplayOptions(userOptions) {\n  _classCallCheck(this, GisplayOptions);\n\n  /**\r\n   * The attribute to be mapped.\r\n   * @type {string} \r\n   */\n  this.attr = userOptions.attr;\n  /**\r\n   * Array of colors to be used by the API. \r\n   * @type {string[]}\r\n   */\n  this.colorscheme = userOptions.colorScheme;\n  /**\r\n   * Number of classes to be used on the map Legend. This option should be used when the user wants the API\r\n   * to calculate the classes (aka ranges) using the given number.\r\n   * @type{number}\r\n   */\n  this.numberofclasses = userOptions.numberOfClasses;\n  /**\r\n   * Algorithm to be used by the API to calculate classes intervals. \r\n   * Available options are 'quantile', 'equidistant', 'k-means'.\r\n   * @type {string}\r\n   */\n  this.algorithm = userOptions.algorithm || 'quantile';\n  /**\r\n   * Class intervals. If this is defined then numberOfClasses and classBreakMethod are ignored.\r\n   * @type {number[]}\r\n   */\n  this.classBreaks = userOptions.classBreaks || undefined; //undefined n era preciso\n  /**\r\n   * When we click on a feature that is on the map, show properties of said Feature or not.\r\n   * @type {boolean}\r\n   */\n  this.interactive = userOptions.interactive || true;\n  /**\r\n   * Properties and description to be shown when the user clicks on a Feature.\r\n   * @todo NOT USED? \r\n   * @type {string[]}\r\n   */\n  this.showPropertiesOnClick = options.showPropertiesOnClick || null;\n\n  /**\r\n   * Alpha to be used in WebGL.\r\n   * 0 means fully transparent <-> 1 fully opaque.\r\n   * @type {number}\r\n   */\n  this.alpha = userOptions.alpha != undefined ? userOptions.alpha : 0.8;\n  /**\r\n   * \r\n   */\n  this.dynamic = userOptions.memorySaver == undefined ? false : !userOptions.memorySaver;\n  this.maxfeatures = userOptions.maxFeatures;\n\n  this.algorithm = userOptions.classBreaksMethod;\n  this.legendOnClickCall = userOptions.legendOnClickFunction;\n  this.mapOnClickCall = userOptions.mapOnClickFunction;\n  this.minuend = userOptions.minuend;\n  this.subtrahend = userOptions.subtrahend;\n  this.legendTitle = userOptions.legendTitle != undefined ? userOptions.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n  this.numberOfLegendItems = userOptions.numberOfLegendItems != undefined ? userOptions.numberOfLegendItems : 2;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0dpc3BsYXlPcHRpb25zLmpzPzdkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiXHJcbi8qKlxyXG4gKiBUaGlzIGNsYXNzIHdpbGwgY29udGFpbiBhbGwgdGhlIG9wdGlvbnMgYXZhaWxhYmxlIG9uIHRoZSBHaXNwbGF5IEFQSS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHaXNwbGF5T3B0aW9ucyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE9wdGlvbnMgb2JqZWN0LiBVc2VyIG9wdGlvbnMgdGFrZSBwcmVjZWRlbmNlIG92ZXIgZGVmYXVsdCBvcHRpb25zLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHVzZXJPcHRpb25zIC0gVGhlIHVzZXIgZGVmaW5lZCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXNlck9wdGlvbnMuYXR0ciAtICBUaGUgYXR0cmlidXRlIHRvIGJlIG1hcHBlZC5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFt1c2VyT3B0aW9ucy5jb2xvclNjaGVtZV0gLSAgVGhlIGNvbG9yIHNjaGVtZSB0byBiZSB1c2VkLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt1c2VyT3B0aW9ucy5udW1iZXJvZmNsYXNzZXNdIC0gIE51bWJlciBvZiBjbGFzc2VzIHRvIGJlIHVzZWQgb24gdGhlIG1hcCBMZWdlbmQuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3VzZXJPcHRpb25zLmFsZ29yaXRobT1xdWFudGlsZV0gLSAgQWxnb3JpdGhtIHRvIGJlIHVzZWQgYnkgdGhlIEFQSSB0byBjYWxjdWxhdGUgY2xhc3NlcyBpbnRlcnZhbHMuIFxyXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gW3VzZXJPcHRpb25zLmNsYXNzQnJlYWtzPXVuZGVmaW5lZF0gLSBDbGFzcyBpbnRlcnZhbHMuXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1c2VyT3B0aW9ucy5pbnRlcmFjdGl2ZT10cnVlXSAtIFNob3cgcG9wLXVwIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3VzZXJPcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljaz1udWxsXSAtIFNob3cgcG9wLXVwIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgRmVhdHVyZS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodXNlck9wdGlvbnMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYXR0cmlidXRlIHRvIGJlIG1hcHBlZC5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfSBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF0dHIgPSB1c2VyT3B0aW9ucy5hdHRyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFycmF5IG9mIGNvbG9ycyB0byBiZSB1c2VkIGJ5IHRoZSBBUEkuIFxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmdbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbG9yc2NoZW1lID0gdXNlck9wdGlvbnMuY29sb3JTY2hlbWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIGNsYXNzZXMgdG8gYmUgdXNlZCBvbiB0aGUgbWFwIExlZ2VuZC4gVGhpcyBvcHRpb24gc2hvdWxkIGJlIHVzZWQgd2hlbiB0aGUgdXNlciB3YW50cyB0aGUgQVBJXHJcbiAgICAgICAgICogdG8gY2FsY3VsYXRlIHRoZSBjbGFzc2VzIChha2EgcmFuZ2VzKSB1c2luZyB0aGUgZ2l2ZW4gbnVtYmVyLlxyXG4gICAgICAgICAqIEB0eXBle251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm51bWJlcm9mY2xhc3NlcyA9IHVzZXJPcHRpb25zLm51bWJlck9mQ2xhc3NlcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGdvcml0aG0gdG8gYmUgdXNlZCBieSB0aGUgQVBJIHRvIGNhbGN1bGF0ZSBjbGFzc2VzIGludGVydmFscy4gXHJcbiAgICAgICAgICogQXZhaWxhYmxlIG9wdGlvbnMgYXJlICdxdWFudGlsZScsICdlcXVpZGlzdGFudCcsICdrLW1lYW5zJy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWxnb3JpdGhtID0gdXNlck9wdGlvbnMuYWxnb3JpdGhtIHx8ICdxdWFudGlsZSc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2xhc3MgaW50ZXJ2YWxzLiBJZiB0aGlzIGlzIGRlZmluZWQgdGhlbiBudW1iZXJPZkNsYXNzZXMgYW5kIGNsYXNzQnJlYWtNZXRob2QgYXJlIGlnbm9yZWQuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcltdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2xhc3NCcmVha3MgPSB1c2VyT3B0aW9ucy5jbGFzc0JyZWFrcyB8fCB1bmRlZmluZWQ7IC8vdW5kZWZpbmVkIG4gZXJhIHByZWNpc29cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHdlIGNsaWNrIG9uIGEgZmVhdHVyZSB0aGF0IGlzIG9uIHRoZSBtYXAsIHNob3cgcHJvcGVydGllcyBvZiBzYWlkIEZlYXR1cmUgb3Igbm90LlxyXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW50ZXJhY3RpdmUgPSB1c2VyT3B0aW9ucy5pbnRlcmFjdGl2ZSB8fCB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFByb3BlcnRpZXMgYW5kIGRlc2NyaXB0aW9uIHRvIGJlIHNob3duIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIGEgRmVhdHVyZS5cclxuICAgICAgICAgKiBAdG9kbyBOT1QgVVNFRD8gXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ1tdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID0gb3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgfHwgbnVsbDtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbHBoYSB0byBiZSB1c2VkIGluIFdlYkdMLlxyXG4gICAgICAgICAqIDAgbWVhbnMgZnVsbHkgdHJhbnNwYXJlbnQgPC0+IDEgZnVsbHkgb3BhcXVlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbHBoYSA9IHVzZXJPcHRpb25zLmFscGhhICE9IHVuZGVmaW5lZCA/IHVzZXJPcHRpb25zLmFscGhhIDogMC44O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHluYW1pYyA9IHVzZXJPcHRpb25zLm1lbW9yeVNhdmVyID09IHVuZGVmaW5lZCA/IGZhbHNlIDogIXVzZXJPcHRpb25zLm1lbW9yeVNhdmVyO1xyXG4gICAgICAgIHRoaXMubWF4ZmVhdHVyZXMgPSB1c2VyT3B0aW9ucy5tYXhGZWF0dXJlcztcclxuXHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSB1c2VyT3B0aW9ucy5jbGFzc0JyZWFrc01ldGhvZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZE9uQ2xpY2tDYWxsID0gdXNlck9wdGlvbnMubGVnZW5kT25DbGlja0Z1bmN0aW9uO1xyXG4gICAgICAgIHRoaXMubWFwT25DbGlja0NhbGwgPSB1c2VyT3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5taW51ZW5kID0gdXNlck9wdGlvbnMubWludWVuZDtcclxuICAgICAgICB0aGlzLnN1YnRyYWhlbmQgPSB1c2VyT3B0aW9ucy5zdWJ0cmFoZW5kO1xyXG4gICAgICAgIHRoaXMubGVnZW5kVGl0bGUgPSB1c2VyT3B0aW9ucy5sZWdlbmRUaXRsZSAhPSB1bmRlZmluZWQgPyB1c2VyT3B0aW9ucy5sZWdlbmRUaXRsZSA6ICh0aGlzLmF0dHIgIT0gdW5kZWZpbmVkID8gdGhpcy5hdHRyIDogYCR7dGhpcy5taW51ZW5kfSAtICR7dGhpcy5zdWJ0cmFoZW5kfWApO1xyXG4gICAgICAgIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyA9IHVzZXJPcHRpb25zLm51bWJlck9mTGVnZW5kSXRlbXMgIT0gdW5kZWZpbmVkID8gdXNlck9wdGlvbnMubnVtYmVyT2ZMZWdlbmRJdGVtcyA6IDI7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9HaXNwbGF5T3B0aW9ucy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQUZBO0FBYUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7Ozs7QUFLQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQU1BOzs7OztBQUtBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Feature.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n\n/**\r\n * This class represents a Feature. Each feature belongs to one Aesthetic element.\r\n * \r\n * @exports Feature\r\n * @class Feature\r\n */\nvar Feature =\n/**\r\n * Creates an instance of Feature.\r\n * @example 1-> {\"id\":0,\"properties\":{\"f1\":\"Alabama\",\"f2\":\"Autauga\",\"f3\":150,\"_gisplayid\":0},\r\n                 \"triangles\":[{\"itemSize\":2,\"numItems\":417}],\"borders\":[{\"itemSize\":2,\"numItems\":141}],\"points\":[]}\r\n * @param {number} id - This Feature id.\r\n * @param {{fx: string, _gisplayid:number}} properties - Properties associated with this Feature.  \r\n * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with this Feature. \r\n * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with this Feature.\r\n * @param {number[]} points - The points that belong to this Feature.\r\n * \r\n * @memberOf Feature\r\n */\nexports.Feature = function Feature(id, properties, triangles, borders, points) {\n  _classCallCheck(this, Feature);\n\n  /**\r\n   * This Feature id.\r\n   * @type {number} \r\n   */\n  this._id = id;\n  /**\r\n   * Properties associated with this Feature.  \r\n   * @type {{fx: string, _gisplayid:number}}  \r\n   */\n  this._properties = properties;\n  /**\r\n   * Number of triangles associated with this Feature.\r\n   * @type {{itemSize: number, numItems: number}}\r\n   */\n  this._triangles = triangles;\n  /**\r\n   * Number of borders associated with this Feature.\r\n   * @type {{itemSize: number, numItems: number}}\r\n   */\n  this._borders = borders;\n  /**\r\n   * The points that belong to this Feature.\r\n   * @type {number[]}\r\n   */\n  this._points = points;\n  return this; // @Rui Remover this\n};\n/* if (window.count == 0) {\r\n           var obj = {\r\n               i: id,\r\n               prs: properties,\r\n               ts: triangles,\r\n               bs: borders,\r\n               pts: points,\r\n           }\r\n           window.count++;\r\n           console.log(JSON.stringify(obj))\r\n       }*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9GZWF0dXJlLmpzP2ZiNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbnRlcm1lZGlhdGUgQVBJXHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgRmVhdHVyZS4gRWFjaCBmZWF0dXJlIGJlbG9uZ3MgdG8gb25lIEFlc3RoZXRpYyBlbGVtZW50LlxyXG4gKiBcclxuICogQGV4cG9ydHMgRmVhdHVyZVxyXG4gKiBAY2xhc3MgRmVhdHVyZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZlYXR1cmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEZlYXR1cmUuXHJcbiAgICAgKiBAZXhhbXBsZSAxLT4ge1wiaWRcIjowLFwicHJvcGVydGllc1wiOntcImYxXCI6XCJBbGFiYW1hXCIsXCJmMlwiOlwiQXV0YXVnYVwiLFwiZjNcIjoxNTAsXCJfZ2lzcGxheWlkXCI6MH0sXHJcbiAgICAgICAgICAgICAgICAgICAgIFwidHJpYW5nbGVzXCI6W3tcIml0ZW1TaXplXCI6MixcIm51bUl0ZW1zXCI6NDE3fV0sXCJib3JkZXJzXCI6W3tcIml0ZW1TaXplXCI6MixcIm51bUl0ZW1zXCI6MTQxfV0sXCJwb2ludHNcIjpbXX1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoaXMgRmVhdHVyZSBpZC5cclxuICAgICAqIEBwYXJhbSB7e2Z4OiBzdHJpbmcsIF9naXNwbGF5aWQ6bnVtYmVyfX0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS4gIFxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHRyaWFuZ2xlcyAtIE51bWJlciBvZiB0cmlhbmdsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS4gXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIE51bWJlciBvZiBib3JkZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBUaGUgcG9pbnRzIHRoYXQgYmVsb25nIHRvIHRoaXMgRmVhdHVyZS5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBGZWF0dXJlIGlkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBGZWF0dXJlLiAgXHJcbiAgICAgICAgICogQHR5cGUge3tmeDogc3RyaW5nLCBfZ2lzcGxheWlkOm51bWJlcn19ICBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgdHJpYW5nbGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuXHJcbiAgICAgICAgICogQHR5cGUge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmlhbmdsZXMgPSB0cmlhbmdsZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIGJvcmRlcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS5cclxuICAgICAgICAgKiBAdHlwZSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvcmRlcnMgPSBib3JkZXJzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBGZWF0dXJlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7Ly8gQFJ1aSBSZW1vdmVyIHRoaXNcclxuICAgIH1cclxufVxyXG4gLyogaWYgKHdpbmRvdy5jb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICBpOiBpZCxcclxuICAgICAgICAgICAgICAgIHByczogcHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgIHRzOiB0cmlhbmdsZXMsXHJcbiAgICAgICAgICAgICAgICBiczogYm9yZGVycyxcclxuICAgICAgICAgICAgICAgIHB0czogcG9pbnRzLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvYmopKVxyXG4gICAgICAgIH0qL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9GZWF0dXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBREE7QUFhQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents a background map wrapper. Used to be a \"middle-man\" between the \r\n * background map provider and the API.\r\n */\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n\n    /**\r\n     * This is the map that comes from the background map provider(e.g., MapBox).\r\n     * @param {Object} map \r\n     */\n    function BGMapWrapper(map) {\n        _classCallCheck(this, BGMapWrapper);\n\n        console.log(\"BGMapWrapper constructor?\");\n        /**\r\n         * This is the map that comes from the background map provider(e.g., MapBox). \r\n         * @type {Object}\r\n         */\n        this.map = map;\n    }\n\n    /**\r\n     * Returns the map's containing HTML element.\r\n     */\n\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.map.getContainer();\n        }\n\n        /**\r\n         * Given one id it creates a canvas object.\r\n         * @todo Understand case mapbox comment bellow.\r\n         * @param {number} id - The id of the canvas to be created.\r\n         * @returns {HTMLCanvasElement} Canvas object where everything will be drawn.\r\n         */\n\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.map.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //mapCanvas.style.zIndex = \"2\";\n\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n\n        /**\r\n         * Returns the map's current zoom level.\r\n         */\n\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.map.getZoom();\n        }\n\n        /**\r\n         * Returns the longitude of the bounding box northwest corner.\r\n         */\n\n    }, {\n        key: 'getLngBound',\n        value: function getLngBound() {\n            return this.map.getBounds().getNorthWest().lng;\n        }\n\n        /**\r\n         * Returns the latitude of the bounding box northwest corner.\r\n         */\n\n    }, {\n        key: 'getLatBound',\n        value: function getLatBound() {\n            return this.map.getBounds().getNorthWest().lat;\n        }\n\n        /**\r\n         * Adds a listener to a specified event type.\r\n         * @param {string} eventstr - The event type to add a listen for.\r\n         * @param {Function} eventfunction - The function to be called when the event is fired. The listener function is called with the data object passed to  fire , extended with  target and  type properties. \r\n         */\n\n    }, {\n        key: 'onEvent',\n        value: function onEvent(eventstr, eventfunction) {\n            this.map.on(eventstr, eventfunction);\n        }\n\n        /**\r\n         * Creates loader to be shown at the beginning when the API is loading all data.\r\n         * @todo This method is calling another with parameters in the 1st if. This is incorrect.\r\n         */\n\n    }, {\n        key: 'loader',\n        value: function loader() {\n            if (this.loaderDiv === undefined) this.createLoader(this.map);else {\n                if (this.loaderDiv.style.display == 'none') this.loaderDiv.style.display = 'flex';else {\n                    this.loaderDiv.style.display = 'none';\n                }\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');\n                } else {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n                }\n            }\n        }\n\n        /**\r\n         * Auxiliar method to be called when the we want to create the loader.\r\n         * @todo Probably it is not being used because nobody calls it(see L:82).\r\n         * It inserts two divs on the map\r\n         */\n\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n\n            /*outerDiv.style = ' opacity: 0.5; background-color: grey; justify-content: center; display: flex;';\r\n            outerDiv.style.position = 'absolute';\r\n            outerDiv.style.zIndex = '999999999';*/\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            this.loaderDiv = outerDiv;\n\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcz9lMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBiYWNrZ3JvdW5kIG1hcCB3cmFwcGVyLiBVc2VkIHRvIGJlIGEgXCJtaWRkbGUtbWFuXCIgYmV0d2VlbiB0aGUgXHJcbiAqIGJhY2tncm91bmQgbWFwIHByb3ZpZGVyIGFuZCB0aGUgQVBJLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEJHTWFwV3JhcHBlciB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIHRoZSBtYXAgdGhhdCBjb21lcyBmcm9tIHRoZSBiYWNrZ3JvdW5kIG1hcCBwcm92aWRlcihlLmcuLCBNYXBCb3gpLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobWFwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJCR01hcFdyYXBwZXIgY29uc3RydWN0b3I/XCIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIG1hcCB0aGF0IGNvbWVzIGZyb20gdGhlIGJhY2tncm91bmQgbWFwIHByb3ZpZGVyKGUuZy4sIE1hcEJveCkuIFxyXG4gICAgICAgICAqIEB0eXBlIHtPYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXAncyBjb250YWluaW5nIEhUTUwgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0Q29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRDb250YWluZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIG9uZSBpZCBpdCBjcmVhdGVzIGEgY2FudmFzIG9iamVjdC5cclxuICAgICAqIEB0b2RvIFVuZGVyc3RhbmQgY2FzZSBtYXBib3ggY29tbWVudCBiZWxsb3cuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgaWQgb2YgdGhlIGNhbnZhcyB0byBiZSBjcmVhdGVkLlxyXG4gICAgICogQHJldHVybnMge0hUTUxDYW52YXNFbGVtZW50fSBDYW52YXMgb2JqZWN0IHdoZXJlIGV2ZXJ5dGhpbmcgd2lsbCBiZSBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgY3JlYXRlQ2FudmFzKGlkKSB7XHJcbiAgICAgICAgY29uc3QgbWFwQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgbWFwQ2FudmFzLmlkID0gYG1hcENhbnZhcyR7aWR9YDtcclxuICAgICAgICBtYXBDYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cclxuICAgICAgICBjb25zdCBtYXBEaXYgPSB0aGlzLm1hcC5nZXRDb250YWluZXIoKTtcclxuICAgICAgICBtYXBDYW52YXMuaGVpZ2h0ID0gbWFwRGl2Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBtYXBDYW52YXMud2lkdGggPSBtYXBEaXYub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgLy9tYXBDYW52YXMuc3R5bGUuekluZGV4ID0gXCIyXCI7XHJcblxyXG4gICAgICAgIC8vY2FzZSBtYXBib3hcclxuICAgICAgICBtYXBEaXYuaW5zZXJ0QmVmb3JlKG1hcENhbnZhcywgbWFwRGl2LmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpO1xyXG5cclxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgbWFwQ2FudmFzJHtpZH1gKTtcclxuICAgICAgICByZXR1cm4gY2FudmFzO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWFwJ3MgY3VycmVudCB6b29tIGxldmVsLlxyXG4gICAgICovXHJcbiAgICBnZXRab29tKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsb25naXR1ZGUgb2YgdGhlIGJvdW5kaW5nIGJveCBub3J0aHdlc3QgY29ybmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRMbmdCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkubG5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGF0aXR1ZGUgb2YgdGhlIGJvdW5kaW5nIGJveCBub3J0aHdlc3QgY29ybmVyLlxyXG4gICAgICovXHJcbiAgICBnZXRMYXRCb3VuZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Qm91bmRzKCkuZ2V0Tm9ydGhXZXN0KCkubGF0O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGxpc3RlbmVyIHRvIGEgc3BlY2lmaWVkIGV2ZW50IHR5cGUuXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRzdHIgLSBUaGUgZXZlbnQgdHlwZSB0byBhZGQgYSBsaXN0ZW4gZm9yLlxyXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRmdW5jdGlvbiAtIFRoZSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgd2hlbiB0aGUgZXZlbnQgaXMgZmlyZWQuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCB0aGUgZGF0YSBvYmplY3QgcGFzc2VkIHRvICBmaXJlICwgZXh0ZW5kZWQgd2l0aCAgdGFyZ2V0IGFuZCAgdHlwZSBwcm9wZXJ0aWVzLiBcclxuICAgICAqL1xyXG4gICAgb25FdmVudChldmVudHN0ciwgZXZlbnRmdW5jdGlvbikge1xyXG4gICAgICAgIHRoaXMubWFwLm9uKGV2ZW50c3RyLCBldmVudGZ1bmN0aW9uKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbG9hZGVyIHRvIGJlIHNob3duIGF0IHRoZSBiZWdpbm5pbmcgd2hlbiB0aGUgQVBJIGlzIGxvYWRpbmcgYWxsIGRhdGEuXHJcbiAgICAgKiBAdG9kbyBUaGlzIG1ldGhvZCBpcyBjYWxsaW5nIGFub3RoZXIgd2l0aCBwYXJhbWV0ZXJzIGluIHRoZSAxc3QgaWYuIFRoaXMgaXMgaW5jb3JyZWN0LlxyXG4gICAgICovXHJcbiAgICBsb2FkZXIoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubG9hZGVyRGl2ID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlTG9hZGVyKHRoaXMubWFwKTtcclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkZXJEaXYuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYuY2xhc3NOYW1lLmluY2x1ZGVzKCdfZ2lzcGxheWhpZGRlbicpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUgPSB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXloaWRkZW4oPyFcXFMpL2csICdfZ2lzcGxheUxvYWRlck91dGVyRGl2Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUgPSB0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXlMb2FkZXJPdXRlckRpdig/IVxcUykvZywgJ19naXNwbGF5aGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBdXhpbGlhciBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIHdlIHdhbnQgdG8gY3JlYXRlIHRoZSBsb2FkZXIuXHJcbiAgICAgKiBAdG9kbyBQcm9iYWJseSBpdCBpcyBub3QgYmVpbmcgdXNlZCBiZWNhdXNlIG5vYm9keSBjYWxscyBpdChzZWUgTDo4MikuXHJcbiAgICAgKiBJdCBpbnNlcnRzIHR3byBkaXZzIG9uIHRoZSBtYXBcclxuICAgICAqL1xyXG4gICAgY3JlYXRlTG9hZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IG91dGVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgY29uc3QgaW5uZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBpbm5lckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlsb2FkZXInO1xyXG5cclxuICAgICAgICBjb25zdCBtYXBEaXYgPSB0aGlzLmdldENvbnRhaW5lcigpO1xyXG5cclxuICAgICAgICAvKm91dGVyRGl2LnN0eWxlID0gJyBvcGFjaXR5OiAwLjU7IGJhY2tncm91bmQtY29sb3I6IGdyZXk7IGp1c3RpZnktY29udGVudDogY2VudGVyOyBkaXNwbGF5OiBmbGV4Oyc7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLnpJbmRleCA9ICc5OTk5OTk5OTknOyovXHJcbiAgICAgICAgb3V0ZXJEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5TG9hZGVyT3V0ZXJEaXYnO1xyXG4gICAgICAgIG91dGVyRGl2LnN0eWxlLmhlaWdodCA9IG1hcERpdi5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUud2lkdGggPSBtYXBEaXYub2Zmc2V0V2lkdGg7XHJcbiAgICAgICAgb3V0ZXJEaXYuYXBwZW5kQ2hpbGQoaW5uZXJEaXYpO1xyXG4gICAgICAgIHRoaXMubG9hZGVyRGl2ID0gb3V0ZXJEaXY7XHJcblxyXG4gICAgICAgIG1hcERpdi5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShvdXRlckRpdiwgbWFwRGl2KTtcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9CR01hcFdyYXBwZXIuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBSUE7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/Gisplay/Maps/ChangeMap.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChangeMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * ChangeMap implementation 07/03\r\n */\nvar ChangeMap = exports.ChangeMap = function (_Map) {\n    _inherits(ChangeMap, _Map);\n\n    function ChangeMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChangeMap);\n\n        var _this = _possibleConstructorReturn(this, (ChangeMap.__proto__ || Object.getPrototypeOf(ChangeMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.attr = \"change\";\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.attr = \"change\"; //@Rui Duplicate?\n        _this.type = 'CM';\n        maps.push(_this);\n        _this.initialize();\n\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(ChangeMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawContinuousPolygons(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n            var aesarray = [];\n            var values = [];\n            var breaks = void 0;\n            //var fcolor;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (typeof geojson.features[g].properties[this.minuend] == 'number' && geojson.features[g].properties[this.minuend] != null && typeof geojson.features[g].properties[this.subtrahend] == 'number' && geojson.features[g].properties[this.subtrahend] != null) {\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                }\n            }\n            breaks = [this.min, this.max];\n            this.fcolor = chroma.scale(colorscheme);\n            var aes = new _Aesthetic.Aesthetic(0, this.attr, this.fcolor, [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n            aes.outer = true;\n            aesarray.push(aes);\n\n            this.aesthetics = aesarray;\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            this.legend.insertGradient(this, this.min, 0, this.max);\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults() {\n            var options = {};\n            return options;\n        }\n    }]);\n\n    return ChangeMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0NoYW5nZU1hcC5qcz9lMTQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcCB9IGZyb20gJy4vTWFwJztcclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2VNYXAgaW1wbGVtZW50YXRpb24gMDcvMDNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaGFuZ2VNYXAgZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IFwiY2hhbmdlXCI7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy5hdHRyID0gXCJjaGFuZ2VcIjsvL0BSdWkgRHVwbGljYXRlP1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDTSc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICAvKiAgcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29udGludW91c1BvbHlnb25zKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcmVQcm9jZXNzRGF0YShnZW9qc29uLCBudW1iZXJPZiwgYWxnb3JpdGhtLCBjb2xvcnNjaGVtZSkge1xyXG4gICAgICAgIGNvbnN0IGFlc2FycmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgbGV0IGJyZWFrcztcclxuICAgICAgICAvL3ZhciBmY29sb3I7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAhPSBudWxsICYmIHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAtIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLm1pbnVlbmRdIC0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrcyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xyXG4gICAgICAgIHRoaXMuZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKTtcclxuICAgICAgICBjb25zdCBhZXMgPSBuZXcgQWVzdGhldGljKDAsIHRoaXMuYXR0ciwgdGhpcy5mY29sb3IsIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1swXSwgYnJlYWtzWzFdXSk7XHJcbiAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRHcmFkaWVudCh0aGlzLCB0aGlzLm1pbiwgMCwgdGhpcy5tYXgpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQ2hhbmdlTWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFhQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./src/Gisplay/Maps/ChorochromaticMap.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChorochromaticMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Choropleth2 = __webpack_require__(/*! ./Choropleth */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*import { Map } from './Map';*/\n\n\n/**\r\n * Chorochormatic Map implemenetation.\r\n */\nvar ChorochromaticMap = exports.ChorochromaticMap = function (_Choropleth) {\n    _inherits(ChorochromaticMap, _Choropleth);\n\n    function ChorochromaticMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChorochromaticMap);\n\n        return _possibleConstructorReturn(this, (ChorochromaticMap.__proto__ || Object.getPrototypeOf(ChorochromaticMap)).call(this, bgmap, geometry, options));\n    }\n\n    _createClass(ChorochromaticMap, [{\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ChorochromaticMap;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvY2hyb21hdGljTWFwLmpzPzQ0ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyppbXBvcnQgeyBNYXAgfSBmcm9tICcuL01hcCc7Ki9cclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9jaG9ybWF0aWMgTWFwIGltcGxlbWVuZXRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaG9yb2Nocm9tYXRpY01hcCBleHRlbmRzIENob3JvcGxldGgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbXCIjNDQwMTU0XCIsIFwiIzQ0MDI1NlwiLCBcIiM0NTA0NTdcIiwgXCIjNDUwNTU5XCIsIFwiIzQ2MDc1YVwiLCBcIiM0NjA4NWNcIiwgXCIjNDYwYTVkXCIsIFwiIzQ2MGI1ZVwiLCBcIiM0NzBkNjBcIiwgXCIjNDcwZTYxXCIsIFwiIzQ3MTA2M1wiLCBcIiM0NzExNjRcIiwgXCIjNDcxMzY1XCIsIFwiIzQ4MTQ2N1wiLCBcIiM0ODE2NjhcIiwgXCIjNDgxNzY5XCIsIFwiIzQ4MTg2YVwiLCBcIiM0ODFhNmNcIiwgXCIjNDgxYjZkXCIsIFwiIzQ4MWM2ZVwiLCBcIiM0ODFkNmZcIiwgXCIjNDgxZjcwXCIsIFwiIzQ4MjA3MVwiLCBcIiM0ODIxNzNcIiwgXCIjNDgyMzc0XCIsIFwiIzQ4MjQ3NVwiLCBcIiM0ODI1NzZcIiwgXCIjNDgyNjc3XCIsIFwiIzQ4Mjg3OFwiLCBcIiM0ODI5NzlcIiwgXCIjNDcyYTdhXCIsIFwiIzQ3MmM3YVwiLCBcIiM0NzJkN2JcIiwgXCIjNDcyZTdjXCIsIFwiIzQ3MmY3ZFwiLCBcIiM0NjMwN2VcIiwgXCIjNDYzMjdlXCIsIFwiIzQ2MzM3ZlwiLCBcIiM0NjM0ODBcIiwgXCIjNDUzNTgxXCIsIFwiIzQ1Mzc4MVwiLCBcIiM0NTM4ODJcIiwgXCIjNDQzOTgzXCIsIFwiIzQ0M2E4M1wiLCBcIiM0NDNiODRcIiwgXCIjNDMzZDg0XCIsIFwiIzQzM2U4NVwiLCBcIiM0MjNmODVcIiwgXCIjNDI0MDg2XCIsIFwiIzQyNDE4NlwiLCBcIiM0MTQyODdcIiwgXCIjNDE0NDg3XCIsIFwiIzQwNDU4OFwiLCBcIiM0MDQ2ODhcIiwgXCIjM2Y0Nzg4XCIsIFwiIzNmNDg4OVwiLCBcIiMzZTQ5ODlcIiwgXCIjM2U0YTg5XCIsIFwiIzNlNGM4YVwiLCBcIiMzZDRkOGFcIiwgXCIjM2Q0ZThhXCIsIFwiIzNjNGY4YVwiLCBcIiMzYzUwOGJcIiwgXCIjM2I1MThiXCIsIFwiIzNiNTI4YlwiLCBcIiMzYTUzOGJcIiwgXCIjM2E1NDhjXCIsIFwiIzM5NTU4Y1wiLCBcIiMzOTU2OGNcIiwgXCIjMzg1ODhjXCIsIFwiIzM4NTk4Y1wiLCBcIiMzNzVhOGNcIiwgXCIjMzc1YjhkXCIsIFwiIzM2NWM4ZFwiLCBcIiMzNjVkOGRcIiwgXCIjMzU1ZThkXCIsIFwiIzM1NWY4ZFwiLCBcIiMzNDYwOGRcIiwgXCIjMzQ2MThkXCIsIFwiIzMzNjI4ZFwiLCBcIiMzMzYzOGRcIiwgXCIjMzI2NDhlXCIsIFwiIzMyNjU4ZVwiLCBcIiMzMTY2OGVcIiwgXCIjMzE2NzhlXCIsIFwiIzMxNjg4ZVwiLCBcIiMzMDY5OGVcIiwgXCIjMzA2YThlXCIsIFwiIzJmNmI4ZVwiLCBcIiMyZjZjOGVcIiwgXCIjMmU2ZDhlXCIsIFwiIzJlNmU4ZVwiLCBcIiMyZTZmOGVcIiwgXCIjMmQ3MDhlXCIsIFwiIzJkNzE4ZVwiLCBcIiMyYzcxOGVcIiwgXCIjMmM3MjhlXCIsIFwiIzJjNzM4ZVwiLCBcIiMyYjc0OGVcIiwgXCIjMmI3NThlXCIsIFwiIzJhNzY4ZVwiLCBcIiMyYTc3OGVcIiwgXCIjMmE3ODhlXCIsIFwiIzI5Nzk4ZVwiLCBcIiMyOTdhOGVcIiwgXCIjMjk3YjhlXCIsIFwiIzI4N2M4ZVwiLCBcIiMyODdkOGVcIiwgXCIjMjc3ZThlXCIsIFwiIzI3N2Y4ZVwiLCBcIiMyNzgwOGVcIiwgXCIjMjY4MThlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjU4MzhlXCIsIFwiIzI1ODQ4ZVwiLCBcIiMyNTg1OGVcIiwgXCIjMjQ4NjhlXCIsIFwiIzI0ODc4ZVwiLCBcIiMyMzg4OGVcIiwgXCIjMjM4OThlXCIsIFwiIzIzOGE4ZFwiLCBcIiMyMjhiOGRcIiwgXCIjMjI4YzhkXCIsIFwiIzIyOGQ4ZFwiLCBcIiMyMThlOGRcIiwgXCIjMjE4ZjhkXCIsIFwiIzIxOTA4ZFwiLCBcIiMyMTkxOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkzOGNcIiwgXCIjMWY5NDhjXCIsIFwiIzFmOTU4YlwiLCBcIiMxZjk2OGJcIiwgXCIjMWY5NzhiXCIsIFwiIzFmOTg4YlwiLCBcIiMxZjk5OGFcIiwgXCIjMWY5YThhXCIsIFwiIzFlOWI4YVwiLCBcIiMxZTljODlcIiwgXCIjMWU5ZDg5XCIsIFwiIzFmOWU4OVwiLCBcIiMxZjlmODhcIiwgXCIjMWZhMDg4XCIsIFwiIzFmYTE4OFwiLCBcIiMxZmExODdcIiwgXCIjMWZhMjg3XCIsIFwiIzIwYTM4NlwiLCBcIiMyMGE0ODZcIiwgXCIjMjFhNTg1XCIsIFwiIzIxYTY4NVwiLCBcIiMyMmE3ODVcIiwgXCIjMjJhODg0XCIsIFwiIzIzYTk4M1wiLCBcIiMyNGFhODNcIiwgXCIjMjVhYjgyXCIsIFwiIzI1YWM4MlwiLCBcIiMyNmFkODFcIiwgXCIjMjdhZDgxXCIsIFwiIzI4YWU4MFwiLCBcIiMyOWFmN2ZcIiwgXCIjMmFiMDdmXCIsIFwiIzJjYjE3ZVwiLCBcIiMyZGIyN2RcIiwgXCIjMmViMzdjXCIsIFwiIzJmYjQ3Y1wiLCBcIiMzMWI1N2JcIiwgXCIjMzJiNjdhXCIsIFwiIzM0YjY3OVwiLCBcIiMzNWI3NzlcIiwgXCIjMzdiODc4XCIsIFwiIzM4Yjk3N1wiLCBcIiMzYWJhNzZcIiwgXCIjM2JiYjc1XCIsIFwiIzNkYmM3NFwiLCBcIiMzZmJjNzNcIiwgXCIjNDBiZDcyXCIsIFwiIzQyYmU3MVwiLCBcIiM0NGJmNzBcIiwgXCIjNDZjMDZmXCIsIFwiIzQ4YzE2ZVwiLCBcIiM0YWMxNmRcIiwgXCIjNGNjMjZjXCIsIFwiIzRlYzM2YlwiLCBcIiM1MGM0NmFcIiwgXCIjNTJjNTY5XCIsIFwiIzU0YzU2OFwiLCBcIiM1NmM2NjdcIiwgXCIjNThjNzY1XCIsIFwiIzVhYzg2NFwiLCBcIiM1Y2M4NjNcIiwgXCIjNWVjOTYyXCIsIFwiIzYwY2E2MFwiLCBcIiM2M2NiNWZcIiwgXCIjNjVjYjVlXCIsIFwiIzY3Y2M1Y1wiLCBcIiM2OWNkNWJcIiwgXCIjNmNjZDVhXCIsIFwiIzZlY2U1OFwiLCBcIiM3MGNmNTdcIiwgXCIjNzNkMDU2XCIsIFwiIzc1ZDA1NFwiLCBcIiM3N2QxNTNcIiwgXCIjN2FkMTUxXCIsIFwiIzdjZDI1MFwiLCBcIiM3ZmQzNGVcIiwgXCIjODFkMzRkXCIsIFwiIzg0ZDQ0YlwiLCBcIiM4NmQ1NDlcIiwgXCIjODlkNTQ4XCIsIFwiIzhiZDY0NlwiLCBcIiM4ZWQ2NDVcIiwgXCIjOTBkNzQzXCIsIFwiIzkzZDc0MVwiLCBcIiM5NWQ4NDBcIiwgXCIjOThkODNlXCIsIFwiIzliZDkzY1wiLCBcIiM5ZGQ5M2JcIiwgXCIjYTBkYTM5XCIsIFwiI2EyZGEzN1wiLCBcIiNhNWRiMzZcIiwgXCIjYThkYjM0XCIsIFwiI2FhZGMzMlwiLCBcIiNhZGRjMzBcIiwgXCIjYjBkZDJmXCIsIFwiI2IyZGQyZFwiLCBcIiNiNWRlMmJcIiwgXCIjYjhkZTI5XCIsIFwiI2JhZGUyOFwiLCBcIiNiZGRmMjZcIiwgXCIjYzBkZjI1XCIsIFwiI2MyZGYyM1wiLCBcIiNjNWUwMjFcIiwgXCIjYzhlMDIwXCIsIFwiI2NhZTExZlwiLCBcIiNjZGUxMWRcIiwgXCIjZDBlMTFjXCIsIFwiI2QyZTIxYlwiLCBcIiNkNWUyMWFcIiwgXCIjZDhlMjE5XCIsIFwiI2RhZTMxOVwiLCBcIiNkZGUzMThcIiwgXCIjZGZlMzE4XCIsIFwiI2UyZTQxOFwiLCBcIiNlNWU0MTlcIiwgXCIjZTdlNDE5XCIsIFwiI2VhZTUxYVwiLCBcIiNlY2U1MWJcIiwgXCIjZWZlNTFjXCIsIFwiI2YxZTUxZFwiLCBcIiNmNGU2MWVcIiwgXCIjZjZlNjIwXCIsIFwiI2Y4ZTYyMVwiLCBcIiNmYmU3MjNcIiwgXCIjZmRlNzI1XCJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3B1cnBsZScsICdvcmFuZ2UnLCAnYmx1ZScsICd5ZWxsb3cnLCAncGluaycsICdncmVlbicsICdyZWQnLCAnbmF2eSddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9DaG9yb2Nocm9tYXRpY01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBSEE7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/Gisplay/Maps/DotMap.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DotMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * DotMap implemenetation\r\n */\nvar DotMap = exports.DotMap = function (_Map) {\n    _inherits(DotMap, _Map);\n\n    function DotMap(bgmap, geometry, options) {\n        _classCallCheck(this, DotMap);\n\n        var _this = _possibleConstructorReturn(this, (DotMap.__proto__ || Object.getPrototypeOf(DotMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.type = 'DM';\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        maps.push(_this);\n        _this.initialize();\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(DotMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPointRow(this.aesthetics[a], this);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid, useroptions) {\n            //@TODO useroptions not used\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    break;\n            }\n            options.numberOfClasses = 1;\n            return options;\n        }\n    }]);\n\n    return DotMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9Eb3RNYXAuanM/ODkzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge01hcH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQge0xlZ2VuZH0gZnJvbSAnLi4vTGVnZW5kJztcclxuXHJcbi8qKlxyXG4gKiBEb3RNYXAgaW1wbGVtZW5ldGF0aW9uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgRG90TWFwIGV4dGVuZHMgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnRE0nO1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSBtYXBjb3VudCsrO1xyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgICAgICAvKiAgcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1tpXS5lbmFibGVkID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhIGluIHRoaXMuYWVzdGhldGljcylcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UG9pbnRSb3codGhpcy5hZXN0aGV0aWNzW2FdLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRMZWdlbmQodGhpcy5tYXApO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmF1bHRzKGRlZmF1bHRpZCwgdXNlcm9wdGlvbnMpIHsgLy9AVE9ETyB1c2Vyb3B0aW9ucyBub3QgdXNlZFxyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKGRlZmF1bHRpZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydwdXJwbGUnLCAnb3JhbmdlJywgJ2JsdWUnLCAneWVsbG93JywgJ3BpbmsnLCAnZ3JlZW4nLCAncmVkJywgJ25hdnknXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9wdGlvbnMubnVtYmVyT2ZDbGFzc2VzID0gMTtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0RvdE1hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFVQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./src/Gisplay/Maps/ProportionalSymbolsMap.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ProportionalSymbolsMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Proportional Symbols Map implementation.\r\n */\nvar ProportionalSymbolsMap = exports.ProportionalSymbolsMap = function (_Map) {\n    _inherits(ProportionalSymbolsMap, _Map);\n\n    function ProportionalSymbolsMap(bgmap, geometry, options) {\n        _classCallCheck(this, ProportionalSymbolsMap);\n\n        var _this = _possibleConstructorReturn(this, (ProportionalSymbolsMap.__proto__ || Object.getPrototypeOf(ProportionalSymbolsMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.legend; //@Rui TODO WUT\n        _this.annotations = new Array();\n        _this.map = bgmap;\n        _this.id = mapcount++;\n        _this.type = 'PS';\n        _this.loadOptions(options, bgmap);\n        _this.dynamic = options.sizeByClass == undefined ? true : !options.sizeByClass;\n        if (_this.dynamic == true) {\n            _this.maxpointsize = options.maxPointSize == undefined ? 10.0 : parseFloat(options.maxPointSize);\n            _this.minpointsize = options.minPointSize == undefined ? 1.0 : parseFloat(options.minPointSize);\n        }\n        maps.push(_this);\n        _this.initialize();\n        return _this;\n    }\n\n    _createClass(ProportionalSymbolsMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            if (this.dynamic == false) for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            } else {\n                for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                    if (this.aesthetics[i].enabled == true) this.drawProporcionalPoints(this.aesthetics[i]);\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            if (this.aesthetics.length == 1) this.legend.insertProportionalSymbols(this.aesthetics[0], this, this.numberOfLegendItems);else for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (i == 0) this.legend.insertProportionalSymbols(this.aesthetics[i], this, 2);else this.legend.insertProportionalSymbols(this.aesthetics[i], this, 1);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.maxPointSize = 60;\n                    options.minPointSize = 5;\n                    options.colorScheme = ['green', 'red', 'blue'];\n                    options.numberOfClasses = 1;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ProportionalSymbolsMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9Qcm9wb3J0aW9uYWxTeW1ib2xzTWFwLmpzPzgyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIFByb3BvcnRpb25hbCBTeW1ib2xzIE1hcCBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIGV4dGVuZHMgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZDsgLy9AUnVpIFRPRE8gV1VUXHJcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMubWFwID0gYmdtYXA7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ1BTJztcclxuICAgICAgICB0aGlzLmxvYWRPcHRpb25zKG9wdGlvbnMsIGJnbWFwKTtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLnNpemVCeUNsYXNzID09IHVuZGVmaW5lZCA/IHRydWUgOiAhb3B0aW9ucy5zaXplQnlDbGFzcztcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhwb2ludHNpemUgPSBvcHRpb25zLm1heFBvaW50U2l6ZSA9PSB1bmRlZmluZWQgPyAxMC4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1heFBvaW50U2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWlucG9pbnRzaXplID0gb3B0aW9ucy5taW5Qb2ludFNpemUgPT0gdW5kZWZpbmVkID8gMS4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1pblBvaW50U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IGZhbHNlKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQcm9wb3JjaW9uYWxQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljcy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbMF0sIHRoaXMsIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbaV0sIHRoaXMsIDEpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4UG9pbnRTaXplID0gNjA7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1pblBvaW50U2l6ZSA9IDU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydncmVlbicsICdyZWQnLCAnYmx1ZSddO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsYXNzZXMgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvUHJvcG9ydGlvbmFsU3ltYm9sc01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFpQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFNQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv2.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./Gisplay/Gisplay */ 4);\n\nvar _GisplayOptions = __webpack_require__(/*! ./Gisplay/Maps/GisplayOptions */ 5);\n\n/**\r\n * This file is the entry point for the Gisplay API\r\n */\nmodule.exports = {\n\n    /** #########################CHOROPLETH MAPS################################# */\n    //Choropleth\n    createBGMap: function createBGMap() {\n        console.log(\"Start gisplayv2. TESTE workflow18/02.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        /*window.count = 0;*/\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            /* console.log(window.map)\r\n             console.log(map)*/\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    createBGMapChorocromatic: function createBGMapChorocromatic() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChorocromatic: function startChorocromatic() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            attr: 'f2',\n            legendTitle: \"Most Frequent Crime\"\n        };\n\n        var time = Date.now();\n        console.log(\"starting Chorocromatic Map...\");\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n            gisplay.makeChorochromaticMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################DOT MAPS################################# */\n    //DOT MAP Example 1\n    createBGMapDotMap: function createBGMapDotMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startDotMap1: function startDotMap1() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 1...\");\n\n        var options = {\n            colorScheme: [\"red\", \"green\"],\n            attr: 'f1',\n            legendTitle: \"Alcohol\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    //DOT MAP Example 2\n    startDotMap2: function startDotMap2() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 2...\");\n\n        var options = {\n            colorScheme: [\"blue\", \"red\"],\n            maxPointSize: 100,\n            numberOfClasses: 2,\n            classBreaksMethod: \"k-means\",\n            minPointSize: 1,\n            attr: 'f2',\n            legendTitle: \"Fatals\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################CHANGE MAPS################################# */\n    //Change map Example\n    createBGMapChangeMap: function createBGMapChangeMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChangeMap: function startChangeMap() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Change Map 1...\");\n\n        var options = {\n            colorScheme: [\"green\", \"red\"],\n            minuend: 'f6',\n            subtrahend: 'f2',\n            alpha: 1,\n            legendTitle: \"Evoluo entre 2009 e 2013\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeChangeMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ########################PROP. SYMBOLS MAPS########################### */\n    createBGPSymbols: function createBGPSymbols() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startPSymbols: function startPSymbols() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Proportional Symbols...\");\n        var options = {\n            maxPointSize: 100,\n            minPointSize: 5,\n            attr: 'f1',\n            alpha: 1.0,\n            numberOfLegendItems: 3,\n            legendTitle: \"Accidents\"\n        };\n\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeProportionalSymbolsMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dpc3BsYXl2Mi5qcz81ZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciB0aGUgR2lzcGxheSBBUElcclxuICovXHJcbmltcG9ydCB7IEdpc3BsYXkgfSBmcm9tICcuL0dpc3BsYXkvR2lzcGxheSdcclxuaW1wb3J0IHsgR2lzcGxheU9wdGlvbnMgfSBmcm9tICcuL0dpc3BsYXkvTWFwcy9HaXNwbGF5T3B0aW9ucyc7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI0NIT1JPUExFVEggTUFQUyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLy9DaG9yb3BsZXRoXHJcbiAgICBjcmVhdGVCR01hcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiU3RhcnQgZ2lzcGxheXYyLiBURVNURSB3b3JrZmxvdzE4LzAyLlwiKTtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LnN0cmVldHMnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0Q2hvcm9wbGV0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8qd2luZG93LmNvdW50ID0gMDsqL1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29sb3JTY2hlbWU6IFtcIndoaXRlXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBudW1iZXJPZkNsYXNzZXM6IDQsXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMycsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiAnRmF0YWxzJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhcmVhZHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZGUgbGVpdHVyYSBkbyBmaWNoZWlybzogXCIgKyAoZGF0YXJlYWR0aW1lc3RhbXAgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNvbnNvbGUubG9nKHdpbmRvdy5tYXApXHJcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhtYXApKi9cclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hvcm9wbGV0aCh3aW5kb3cubWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBnaXNwbGF5OiBcIiArIChEYXRlLm5vdygpIC0gZGF0YXJlYWR0aW1lc3RhbXApIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIHRvdGFsOiBcIiArIChEYXRlLm5vdygpIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJHTWFwQ2hvcm9jcm9tYXRpYzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guc3RyZWV0cycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDaG9yb2Nyb21hdGljOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhdHRyOiAnZjInLFxyXG4gICAgICAgICAgICBsZWdlbmRUaXRsZTogXCJNb3N0IEZyZXF1ZW50IENyaW1lXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBDaG9yb2Nyb21hdGljIE1hcC4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YXJlYWR0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGRlIGxlaXR1cmEgZG8gZmljaGVpcm86IFwiICsgKGRhdGFyZWFkdGltZXN0YW1wIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZUNob3JvY2hyb21hdGljTWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjRE9UIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8vRE9UIE1BUCBFeGFtcGxlIDFcclxuICAgIGNyZWF0ZUJHTWFwRG90TWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5kYXJrJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydERvdE1hcDE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBEb3QgTWFwIDEuLi5cIik7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb2xvclNjaGVtZTogW1wicmVkXCIsIFwiZ3JlZW5cIl0sXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMScsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIkFsY29ob2xcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlRG90TWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vRE9UIE1BUCBFeGFtcGxlIDJcclxuICAgIHN0YXJ0RG90TWFwMjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIERvdCBNYXAgMi4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJibHVlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBtYXhQb2ludFNpemU6IDEwMCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZDbGFzc2VzOiAyLFxyXG4gICAgICAgICAgICBjbGFzc0JyZWFrc01ldGhvZDogXCJrLW1lYW5zXCIsXHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZTogMSxcclxuICAgICAgICAgICAgYXR0cjogJ2YyJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiRmF0YWxzXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZURvdE1hcChtYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVcIikuZmlsZXNbMF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI0NIQU5HRSBNQVBTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAvL0NoYW5nZSBtYXAgRXhhbXBsZVxyXG4gICAgY3JlYXRlQkdNYXBDaGFuZ2VNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LmRhcmsnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0Q2hhbmdlTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgQ2hhbmdlIE1hcCAxLi4uXCIpO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29sb3JTY2hlbWU6IFtcImdyZWVuXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBtaW51ZW5kOiAnZjYnLFxyXG4gICAgICAgICAgICBzdWJ0cmFoZW5kOiAnZjInLFxyXG4gICAgICAgICAgICBhbHBoYTogMSxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiRXZvbHXDp8OjbyBlbnRyZSAyMDA5IGUgMjAxM1wiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VDaGFuZ2VNYXAobWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1BST1AuIFNZTUJPTFMgTUFQUyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgY3JlYXRlQkdQU3ltYm9sczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guZGFyaycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRQU3ltYm9sczogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIFByb3BvcnRpb25hbCBTeW1ib2xzLi4uXCIpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBtYXhQb2ludFNpemU6IDEwMCxcclxuICAgICAgICAgICAgbWluUG9pbnRTaXplOiA1LFxyXG4gICAgICAgICAgICBhdHRyOiAnZjEnLFxyXG4gICAgICAgICAgICBhbHBoYTogMS4wLFxyXG4gICAgICAgICAgICBudW1iZXJPZkxlZ2VuZEl0ZW1zOiAzLFxyXG4gICAgICAgICAgICBsZWdlbmRUaXRsZTogXCJBY2NpZGVudHNcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VQcm9wb3J0aW9uYWxTeW1ib2xzTWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjSEVBVCBNQVBTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbn07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvZ2lzcGxheXYyLmpzIl0sIm1hcHBpbmdzIjoiOztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBTEE7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5LQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);