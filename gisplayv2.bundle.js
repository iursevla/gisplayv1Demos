var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 11);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/Gisplay/Legend.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents the Map Legend. 15/03\r\n */\nvar Legend = exports.Legend = function () {\n    /**\r\n     * Creates an instance of Legend class.\r\n     * @param {number} id -  The id of the legend.\r\n     * @param {string} title - The title for the legend.\r\n     * \r\n     * @memberOf Legend\r\n     */\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        /**\r\n         * Title of the Gisplay map Legend.\r\n         * @type {string}\r\n         */\n        this.title = title;\n        this.init(id);\n        return this; //@Rui Remove this\n    }\n\n    _createClass(Legend, [{\n        key: 'insertLegend',\n        value: function insertLegend(map) {\n            this.legendDiv.appendChild(this.table);\n            map.getContainer().appendChild(this.legendDiv);\n        }\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 2);\n        }\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 1);\n        }\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (currentaes.outer == false) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n            value.appendChild(text);\n\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n            colorDiv.style['backgroundColor'] = rgbc;\n            if (type == 1) {\n                //polygon\n                colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                colorDiv.style.width = 80; //(mapCanvas.width / 10);\n                if (currentaes.strokeColor != null && currentaes != undefined) colorDiv.style['borderColor'] = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type == 2) {\n                //point\n                var size = void 0;\n                if (currentaes.pointSize != null) {\n                    size = Math.max(currentaes.pointSize, 5);\n                } else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (window.profiling == true) var start = Date.now();\n                if (mapobj.legendToggle != false) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade == true) {\n                        this.className += \" _gisplayfade\";\n                    } else {\n                        this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                }\n                if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                mapobj.draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                }\n            };\n\n            this.table.appendChild(row);\n        }\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberof = 5;\n            if (mapobj.aesthetics.length > 5) numberof = mapobj.aesthetics.length;\n            var strcolor = '';\n            for (var i = 0; i < numberof; i++) {\n                var color = mapobj.fcolor(i / numberof).rgb();\n                strcolor += ',rgba(' + Math.round(color[0]) + ',' + Math.round(color[1]) + ',' + Math.round(color[2]) + ',' + mapobj.alpha + ')';\n            }\n            strcolor += ') ';\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor;\n\n            valueDiv.style.height = 25; //(mapCanvas.height / 10);\n            valueDiv.style.width = 130; //(mapCanvas.width / 10);\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            value2.colSpan = 2;\n\n            var divleft = document.createElement('div');\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n    }, {\n        key: 'init',\n        value: function init(id, classname) {\n            //console.log(\"id == \" + id);\n            var mapCanvas = document.getElementById('mapCanvas' + id);\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) {\n                this.legendDiv.className = classname;\n            } else {\n                this.legendDiv.className = '_gisplaylegendBR';\n            }\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n            //thcolor.style.width = 100;\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numberof) {\n            if (this.lastdiv == undefined) {\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else {\n                this.firstInsertion = false;\n            }\n\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + 1 + ')';\n            var strokecolor = void 0;\n\n            if (currentaes.strokeColor != null && currentaes != undefined) strokecolor = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numberof - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (this.firstInsertion == false && i == numberof - 1 || numberof == 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numberof - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(this.round(propvalue));\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgbc;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.maxpointsize - mapobj.minpointsize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (window.profiling == true) var start = Date.now();\n                    if (mapobj.legendToggle != false) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade == true) {\n                            this.className += \" _gisplayfade\";\n                        } else {\n                            this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                        }\n                    }\n                    if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                    mapobj.draw();\n                    if (window.profiling == true) {\n                        var end = Date.now();\n                        window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                    }\n                    if (!e) var e = window.event;\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n                current.appendChild(colorDiv);\n                if ( /*i!= (numberof-1) &&*/this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n            if (this.firstInsertion == true) {\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n    }, {\n        key: 'round',\n        value: function round(value, exp) {\n            //@Rui Added cuz its used by insertProportionalSymbols\n            if (typeof exp === 'undefined' || +exp === 0) return Math.round(value);\n\n            value = +value;\n            exp = +exp;\n\n            if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) return NaN;\n\n            // Shift\n            value = value.toString().split('e');\n            value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] + exp : exp)));\n\n            // Shift back\n            value = value.toString().split('e');\n            return +(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp));\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9MZWdlbmQuanM/Yzg0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBNYXAgTGVnZW5kLiAxNS8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExlZ2VuZCB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgTGVnZW5kIGNsYXNzLlxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkIC0gIFRoZSBpZCBvZiB0aGUgbGVnZW5kLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlIC0gVGhlIHRpdGxlIGZvciB0aGUgbGVnZW5kLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgTGVnZW5kXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGlkLCB0aXRsZSkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRpdGxlIG9mIHRoZSBHaXNwbGF5IG1hcCBMZWdlbmQuXHJcbiAgICAgICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgdGhpcy5pbml0KGlkKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy9AUnVpIFJlbW92ZSB0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0TGVnZW5kKG1hcCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2LmFwcGVuZENoaWxkKHRoaXMudGFibGUpO1xyXG4gICAgICAgIG1hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZCh0aGlzLmxlZ2VuZERpdik7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0UG9pbnRSb3coY3VycmVudGFlcywgbWFwb2JqKSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCAyKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRQb2x5Z29uUm93KGN1cnJlbnRhZXMsIG1hcG9iaikge1xyXG4gICAgICAgIHRoaXMuaW5zZXJ0Um93KGN1cnJlbnRhZXMsIG1hcG9iaiwgMSk7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0Um93KGN1cnJlbnRhZXMsIG1hcG9iaiwgdHlwZSkge1xyXG5cclxuICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgbGV0IHRleHQ7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50YWVzLnJhbmdlWzBdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBtaW5pbnB1dCA9IGN1cnJlbnRhZXMucmFuZ2VbMF0gIT0gbnVsbCA/IGN1cnJlbnRhZXMucmFuZ2VbMF0gOiBtYXBvYmoubWluO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhpbnB1dCA9IGN1cnJlbnRhZXMucmFuZ2VbMV0gIT0gbnVsbCA/IGN1cnJlbnRhZXMucmFuZ2VbMV0gOiBtYXBvYmoubWF4O1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudGFlcy5vdXRlciA9PSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShgWyR7bWluaW5wdXR9LCAke21heGlucHV0fVtgKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHttaW5pbnB1dH0sICR7bWF4aW5wdXR9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjdXJyZW50YWVzLnJhbmdlWzBdKTtcclxuICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuXHJcbiAgICAgICAgY29uc3QgY29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgY29uc3QgcmdiYyA9IGByZ2JhKCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMF19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMV19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMl19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbM119KWA7XHJcbiAgICAgICAgY29sb3JEaXYuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddID0gcmdiYztcclxuICAgICAgICBpZiAodHlwZSA9PSAxKSB7Ly9wb2x5Z29uXHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IDI1Oy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gODA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudGFlcy5zdHJva2VDb2xvciAhPSBudWxsICYmIGN1cnJlbnRhZXMgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgY29sb3JEaXYuc3R5bGVbJ2JvcmRlckNvbG9yJ10gPSBgcmdiYSgke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMF19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclsxXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzJdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbM119KWA7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheXJlY3RhbmdsZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT0gMikgey8vcG9pbnRcclxuICAgICAgICAgICAgbGV0IHNpemU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLnBvaW50U2l6ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzaXplID0gTWF0aC5tYXgoY3VycmVudGFlcy5wb2ludFNpemUsIDUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHNpemUgPSAyNTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXljaXJjbGUnO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGNvbG9yLmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuXHJcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKGNvbG9yKTtcclxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG5cclxuICAgICAgICByb3cub25jbGljayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kVG9nZ2xlICE9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ZhZGUgPSAhY3VycmVudGFlcy5lbmFibGVEaXNhYmxlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9GYWRlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSArPSBcIiBfZ2lzcGxheWZhZGVcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXlmYWRlKD8hXFxTKS9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbCAhPSBudWxsICYmIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwoY3VycmVudGFlcyk7XHJcbiAgICAgICAgICAgIG1hcG9iai5kcmF3KCk7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIHByb2Nlc3NhbWVudG8gZGUgZmlsdHJhZ2VtIHBlbGEgbGVnZW5kYSAoc2VndW5kb3MpOiAkeyhlbmQgLSBzdGFydCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0R3JhZGllbnQobWFwb2JqLCBsZWZ0LCBtaWRkbGUsIHJpZ2h0KSB7XHJcbiAgICAgICAgY29uc3Qgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICB2YWx1ZS5jb2xTcGFuID0gMjtcclxuICAgICAgICB2YWx1ZS5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBsZXQgbnVtYmVyb2YgPSA1O1xyXG4gICAgICAgIGlmIChtYXBvYmouYWVzdGhldGljcy5sZW5ndGggPiA1KVxyXG4gICAgICAgICAgICBudW1iZXJvZiA9IG1hcG9iai5hZXN0aGV0aWNzLmxlbmd0aDtcclxuICAgICAgICBsZXQgc3RyY29sb3IgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlcm9mOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBtYXBvYmouZmNvbG9yKGkgLyBudW1iZXJvZikucmdiKCk7XHJcbiAgICAgICAgICAgIHN0cmNvbG9yICs9IGAscmdiYSgke01hdGgucm91bmQoY29sb3JbMF0pfSwke01hdGgucm91bmQoY29sb3JbMV0pfSwke01hdGgucm91bmQoY29sb3JbMl0pfSwke21hcG9iai5hbHBoYX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3RyY29sb3IgKz0gJykgJztcclxuICAgICAgICB2YWx1ZURpdi5zdHlsZS5iYWNrZ3JvdW5kID0gYC13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQke3N0cmNvbG9yfWA7XHJcblxyXG4gICAgICAgIHZhbHVlRGl2LnN0eWxlLmhlaWdodCA9IDI1Oy8vKG1hcENhbnZhcy5oZWlnaHQgLyAxMCk7XHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUud2lkdGggPSAxMzA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG5cclxuICAgICAgICBjb25zdCByb3cyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICBjb25zdCB2YWx1ZTIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIHZhbHVlMi5jb2xTcGFuID0gMjtcclxuXHJcbiAgICAgICAgY29uc3QgZGl2bGVmdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUudGV4dEFsaWduID0gJ2xlZnQnO1xyXG4gICAgICAgIGRpdmxlZnQuc3R5bGUud2lkdGggPSAnMzMlJztcclxuICAgICAgICBkaXZsZWZ0LnN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xyXG4gICAgICAgIGNvbnN0IGxlZnR0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGVmdCk7XHJcbiAgICAgICAgY29uc3QgZGl2bWlkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgZGl2bWlkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIGRpdm1pZC5zdHlsZS53aWR0aCA9ICczMyUnO1xyXG4gICAgICAgIGRpdm1pZC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobWlkZGxlKTtcclxuICAgICAgICBjb25zdCBkaXZyaWdodCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUud2lkdGggPSAnMzMlJztcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICBjb25zdCByaWdodHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShyaWdodCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgZGl2bGVmdC5hcHBlbmRDaGlsZChsZWZ0dGV4dCk7XHJcbiAgICAgICAgZGl2bWlkLmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgIGRpdnJpZ2h0LmFwcGVuZENoaWxkKHJpZ2h0dGV4dCk7XHJcbiAgICAgICAgdmFsdWUyLmFwcGVuZENoaWxkKGRpdmxlZnQpO1xyXG4gICAgICAgIHZhbHVlMi5hcHBlbmRDaGlsZChkaXZtaWQpO1xyXG4gICAgICAgIHZhbHVlMi5hcHBlbmRDaGlsZChkaXZyaWdodCk7XHJcbiAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQodmFsdWVEaXYpO1xyXG4gICAgICAgIHJvdzIuYXBwZW5kQ2hpbGQodmFsdWUyKTtcclxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdzIpO1xyXG4gICAgfVxyXG5cclxuICAgIGluaXQoaWQsIGNsYXNzbmFtZSkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJpZCA9PSBcIiArIGlkKTtcclxuICAgICAgICBjb25zdCBtYXBDYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChgbWFwQ2FudmFzJHtpZH1gKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGlmIChjbGFzc25hbWUgIT0gdW5kZWZpbmVkICYmIGNsYXNzbmFtZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kRGl2LmNsYXNzTmFtZSA9IGNsYXNzbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWxlZ2VuZEJSJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWdlbmREaXYuaWQgPSBgbGVnZW5kRGl2JHtpZH1gO1xyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgdGhpcy50YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5zdHlsZS56SW5kZXggPSBcIjIwMDBcIjtcclxuICAgICAgICBjb25zdCB0aHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICBjb25zdCB0aGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICB0aGNvbG9yLnN0eWxlLmFsaWduID0gXCJjZW50ZXJcIjtcclxuICAgICAgICAvL3RoY29sb3Iuc3R5bGUud2lkdGggPSAxMDA7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aGNvbG9yKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHRodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IHRpdGxlcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICBjb25zdCB0aXRsZXRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICB0aXRsZXRkLmNvbFNwYW4gPSAyO1xyXG4gICAgICAgIHRpdGxldGQuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgdGl0bGV0ZC5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICBjb25zdCB0aXRsZXRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRpdGxlKTtcclxuICAgICAgICB0aXRsZXRkLmFwcGVuZENoaWxkKHRpdGxldGV4dCk7XHJcbiAgICAgICAgdGl0bGVyb3cuYXBwZW5kQ2hpbGQodGl0bGV0ZCk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aXRsZXJvdyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFByb3BvcnRpb25hbFN5bWJvbHMoY3VycmVudGFlcywgbWFwb2JqLCBudW1iZXJvZikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RkaXYgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgICAgICB2YWx1ZS5jb2xTcGFuID0gMjtcclxuICAgICAgICAgICAgdmFsdWUuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgICAgIHRoaXMuZmlyc3RJbnNlcnRpb24gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7IHRoaXMuZmlyc3RJbnNlcnRpb24gPSBmYWxzZTsgfVxyXG5cclxuICAgICAgICBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHsxfSlgO1xyXG4gICAgICAgIGxldCBzdHJva2Vjb2xvcjtcclxuXHJcbiAgICAgICAgaWYgKGN1cnJlbnRhZXMuc3Ryb2tlQ29sb3IgIT0gbnVsbCAmJiBjdXJyZW50YWVzICE9IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgc3Ryb2tlY29sb3IgPSBgcmdiYSgke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMF19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclsxXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzJdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbM119KWA7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBzdHJva2Vjb2xvciA9IGByZ2JhKCR7MH0sJHswfSwkezB9LCR7MX0pYDtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IG51bWJlcm9mIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBsZXQgcHJvcHZhbHVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maXJzdEluc2VydGlvbiA9PSBmYWxzZSAmJiBpID09IChudW1iZXJvZiAtIDEpIHx8IG51bWJlcm9mID09IDEpXHJcbiAgICAgICAgICAgICAgICBwcm9wdmFsdWUgPSBjdXJyZW50YWVzLnJhbmdlWzFdO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBwcm9wdmFsdWUgPSBtYXBvYmoubWluICsgaSAvIChudW1iZXJvZiAtIDEpICogKG1hcG9iai5tYXggLSBtYXBvYmoubWluKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnJvdW5kKHByb3B2YWx1ZSkpO1xyXG4gICAgICAgICAgICBjdXJyZW50LmFwcGVuZENoaWxkKHRleHQpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHJnYmM7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheXByb3BvcnRpb25hbGNpcmNsZSc7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmJvcmRlckNvbG9yID0gc3Ryb2tlY29sb3I7XHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXBwb2ludHNpemUgPSAoKG1hcG9iai5tYXhwb2ludHNpemUgLSBtYXBvYmoubWlucG9pbnRzaXplKSAvIChtYXBvYmoubWF4IC0gbWFwb2JqLm1pbikpICogKHByb3B2YWx1ZSAtIG1hcG9iai5taW4pO1xyXG4gICAgICAgICAgICBjb25zdCBzaXplID0gTWF0aC5tYXgodGVtcHBvaW50c2l6ZSwgNy41KTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5pbmhlcml0ID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICBjb2xvckRpdi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kVG9nZ2xlICE9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9GYWRlID0gIWN1cnJlbnRhZXMuZW5hYmxlRGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0ZhZGUgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSArPSBcIiBfZ2lzcGxheWZhZGVcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUucmVwbGFjZSgvKD86XnxcXHMpX2dpc3BsYXlmYWRlKD8hXFxTKS9nLCAnJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbCAhPSBudWxsICYmIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsKGN1cnJlbnRhZXMpO1xyXG4gICAgICAgICAgICAgICAgbWFwb2JqLmRyYXcoKTtcclxuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkZSBmaWx0cmFnZW0gcGVsYSBsZWdlbmRhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWUpIHZhciBlID0gd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICAgICAgZS5jYW5jZWxCdWJibGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZChjb2xvckRpdik7XHJcbiAgICAgICAgICAgIGlmICgvKmkhPSAobnVtYmVyb2YtMSkgJiYqLyB0aGlzLmxhc3RkaXYgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RkaXYuYXBwZW5kQ2hpbGQoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RkaXYgPSBjb2xvckRpdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ZGl2ID0gY29sb3JEaXY7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZpcnN0SW5zZXJ0aW9uID09IHRydWUpIHtcclxuICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuICAgICAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJvdW5kKHZhbHVlLCBleHApIHsvL0BSdWkgQWRkZWQgY3V6IGl0cyB1c2VkIGJ5IGluc2VydFByb3BvcnRpb25hbFN5bWJvbHNcclxuICAgICAgICBpZiAodHlwZW9mIGV4cCA9PT0gJ3VuZGVmaW5lZCcgfHwgK2V4cCA9PT0gMClcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUpO1xyXG5cclxuICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcclxuICAgICAgICBleHAgPSArZXhwO1xyXG5cclxuICAgICAgICBpZiAoaXNOYU4odmFsdWUpIHx8ICEodHlwZW9mIGV4cCA9PT0gJ251bWJlcicgJiYgZXhwICUgMSA9PT0gMCkpXHJcbiAgICAgICAgICAgIHJldHVybiBOYU47XHJcblxyXG4gICAgICAgIC8vIFNoaWZ0XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCdlJyk7XHJcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKCsodmFsdWVbMF0gKyAnZScgKyAodmFsdWVbMV0gPyAoK3ZhbHVlWzFdICsgZXhwKSA6IGV4cCkpKTtcclxuXHJcbiAgICAgICAgLy8gU2hpZnQgYmFja1xyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnZScpO1xyXG4gICAgICAgIHJldHVybiArKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSAtIGV4cCkgOiAtZXhwKSk7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTGVnZW5kLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7OztBQUdBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/Gisplay/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 6);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \r\n * ES5 libraries can be used either with \r\n * 1)import if they are just functions or in the case of rtree and ktree a \r\n * webpack loader is needed \"script-loader\"\" can do that.\r\n * 2) Added as <script> tag on index.html file\r\n * The former as choosen.\r\nimport chroma from '../../lib/chroma.min';\r\nimport earcut from '../../lib/earcut'\r\nimport {PolygonLookup} from '../../lib/rtree';\r\n*/\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available.\r\n */\nvar Map = exports.Map = function () {\n    function Map(type, geometry, options) {\n        _classCallCheck(this, Map);\n\n        console.log(\"Map constructor called -> super()\");\n        /* return this;*/ //@TODO Remove isnt doing anything? or is it saving the 3 parameters?\n    }\n\n    _createClass(Map, [{\n        key: 'program',\n        value: function program() {\n            this._webgl.program = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram = [];\n            this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();\n\n            var source_code = this.generateShaders();\n\n            var vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);\n            var fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);\n\n            this._webgl.gl.attachShader(this._webgl.program, vertex_shader);\n            this._webgl.gl.attachShader(this._webgl.program, fragment_shader);\n\n            this._webgl.gl.linkProgram(this._webgl.program);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'shader',\n        value: function shader(type, source_code, _webgl) {\n            //Added HERE by Rui\n            var shader = _webgl.gl.createShader(type);\n\n            _webgl.gl.shaderSource(shader, source_code);\n            _webgl.gl.compileShader(shader);\n\n            console.log(\"shader \" + (type.valueOf() == 35633 ? \"vertex\" : \"fragment\") + \": \" + _webgl.gl.getShaderInfoLog(shader));\n\n            return shader;\n        }\n    }, {\n        key: 'generateShaders',\n        value: function generateShaders() {\n            //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=\n            //general\n\n            var vertexSourceCode = \" attribute vec4 vertexCoord; \";\n            vertexSourceCode += \"\\n\tattribute float aPointSize; \";\n            vertexSourceCode += \"\\n\tuniform mat4 projection; \";\n            vertexSourceCode += \"\\n\tattribute float a_opacity; \";\n            vertexSourceCode += \"\\n\tvarying float v_opacity; \";\n            //vertexSourceCode+= \"\\n\tvarying vec4 u_color; \" ; //delete\n            vertexSourceCode += \"\\n\tvoid main() {\";\n            vertexSourceCode += \"\\n\t\tgl_Position = (projection * vertexCoord); \";\n            vertexSourceCode += \"\\n\t\tgl_PointSize = aPointSize; v_opacity = a_opacity; \";\n            vertexSourceCode += \"\\n}\";\n\n            var fragmentSourceCode = \"precision mediump float;\";\n            fragmentSourceCode += \"\\n\t\tuniform vec4 u_color;\"; //uniform\n            fragmentSourceCode += \"\\n\t\tvarying float v_opacity; \";\n            fragmentSourceCode += \"\\n \t\tuniform float isPoint;\";\n            fragmentSourceCode += \"\\n\t\tvoid main(){\";\n            fragmentSourceCode += \"\\n\t\t\tfloat border = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat radius = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat centerDist = length(gl_PointCoord - 0.5);\";\n            fragmentSourceCode += \"\\n\t\t\tfloat alpha;\";\n            fragmentSourceCode += \"\\n\t\t\tif (u_color[3] == -1.0){\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  v_opacity * step(centerDist, radius);\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\telse{\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  u_color[3] * step(centerDist, radius);\";\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\tif(isPoint == 1.0 ){\";\n            fragmentSourceCode += \"\\n\t\t\tif (alpha < 0.1) discard;\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}\";\n            fragmentSourceCode += \"\\n \t\t\telse\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\";\n            fragmentSourceCode += \"\\n\t\t}\";\n\n            return { vertex: vertexSourceCode, fragment: fragmentSourceCode };\n        }\n    }, {\n        key: 'addAesthetic',\n        value: function addAesthetic(aes) {\n            this.aesthetics.push(aes);\n        }\n    }, {\n        key: 'setAesthetic',\n        value: function setAesthetic(id, aes) {\n            for (var i = 0; i < aesthetics.length; i++) {\n                if (id == aesthetics[i].id) {\n                    aesthetics[i] = aes;\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            //legendDiv.style.height = 200;//(mapCanvas.height / 10);\n            legendDiv.style.width = 250; //(mapCanvas.width / 10);\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            //thvalue.style.width = 125;\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var currentaes = _step.value;\n\n                    //if(currentaes._features.length > 0 || currentaes._allFeatures.length > 0){\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    //console.log(rgbc);\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                    colorDiv.style.width = 80; //(mapCanvas.width / 10);\n\n\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n\n                    table.appendChild(row);\n                    //}\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.map.getContainer().appendChild(legendDiv);\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n\n            var aesarray = [];\n            var values = [];\n            var strings = [];\n            var breaks = void 0;\n            var fcolor = void 0;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (geojson.features[g].properties[this.attr] != null && typeof geojson.features[g].properties[this.attr] == 'number') {\n                    values.push(geojson.features[g].properties[this.attr]);\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);\n                } else if (!strings.includes(geojson.features[g].properties[this.attr])) strings.push(geojson.features[g].properties[this.attr]);\n            }\n            if (values.length > 0) {\n                //quantitative\n                if (this.breaks == undefined) {\n                    if (numberOf > 1) breaks = this.calcClassBreaks(values, algorithm, numberOf);else breaks = [this.min, this.max];\n                } else {\n                    breaks = this.breaks;\n                }\n                if (breaks.length > 2) {\n                    fcolor = chroma.scale(colorscheme).colors(breaks.length - 1);\n                    for (var i = 0; i < breaks.length - 1; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        if (i != breaks.length - 2) {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                        } else {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    color = chroma(colorscheme[0]).rgb();\n                    var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n                    aes.outer = true;\n                    aesarray.push(aes);\n                }\n            } else {\n                //qualitative\n                if (strings.length > 0) {\n                    breaks = strings;\n                    if (typeof colorscheme === 'string') {\n                        //string\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    } else {\n                        //array\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    }\n                    for (var i = 0; i < breaks.length; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);\n                        aesarray.push(aes);\n                    }\n                }\n            }\n\n            this.aesthetics = aesarray;\n            //return aesarray;\n        }\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(values, algorithm, numberOf) {\n            var breaks = void 0;\n            switch (algorithm) {\n                case 'equidistant':\n                    breaks = chroma.limits(values, 'e', numberOf);\n                    break;\n\n                case 'quantile':\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n\n                case 'k-means':\n                    breaks = chroma.limits(values, 'k', numberOf);\n                    break;\n\n                default:\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n            }\n            return breaks;\n        }\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var flag = false;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {\n                    this.aesthetics[i].addFeature(id, properties, triangles, borders, points);\n                    flag = true;\n                }\n            }\n            if (!flag) {\n                //TODO\n                //console.log(\"TODO: feature does not fit into any of the aesthetics defined.\\n Value: \" + properties[this.attr]);\n            }\n        }\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(idaes, triangles, borders, points) {\n            this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);\n        }\n    }, {\n        key: 'draw',\n        value: function draw() {\n            alert(\"draw() not implemented\");\n        }\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n\n            if (polygon.geometry.type == \"Polygon\") {\n                var outsidepolygon = polygon.geometry.coordinates[0];\n\n                var insidepolygons = [];\n                for (var k = 1; k < polygon.geometry.coordinates.length; k++) {\n                    //todo inside polygon\n                    //insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                }\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                    _vertexcount += (outsidepolygon.length + 1) / 2;\n                    //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                }\n\n                var triangles_vert = earcut(tempVerts);\n                _tricount += triangles_vert.length / 3;\n                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                var polyarray = [];\n                for (var i = 0; i < polygon.geometry.coordinates.length; i++) {\n\n                    var outsidepolygon = polygon.geometry.coordinates[i][0];\n\n                    var insidepolygons = [];\n                    for (var k = 1; k < polygon.geometry.coordinates[i].length; k++) {\n                        //todo inside polygon\n                        insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                    }\n                    var tempVerts = new Array();\n                    _vertexcount += outsidepolygon.length;\n                    for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                        tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n\n                        //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                    }\n\n                    var triangles_vert = earcut(tempVerts);\n\n                    //var temp = earcut.flatten(polygon.geometry.coordinates[i]);\n                    //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);\n                    _tricount += triangles_vert.length / 3;\n                    polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n                    //console.log(polyarray);\n                }\n\n                return polyarray;\n            }\n        }\n    }, {\n        key: 'processData',\n        value: function processData(geojson) {\n            this.loadGeoJSON(geojson);\n        }\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(id, geometry, properties) {\n            var gl = this._webgl.gl;\n            if (this.minuend != undefined && this.subtrahend != undefined && typeof properties[this.minuend] == 'number' && properties[this.subtrahend] != undefined && typeof properties[this.subtrahend] == 'number' && properties[this.subtrahend] != undefined) {\n                properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];\n            }\n\n            if (geometry.type == \"Polygon\" || geometry.type == \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentBorders = [];\n                var currentTriangles = [];\n                var bufferT = [];\n                var bufferB = [];\n\n                for (var j = 0; j < polygons.length; j++) {\n                    var trianglespolygon = polygons[j].triangles;\n                    var border = polygons[j].vertex;\n                    currentTriangles[j] = new Array();\n                    currentBorders[j] = new Array();\n                    for (var h = 0; h < trianglespolygon.length; h++) {\n                        var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);\n                        currentTriangles[j].push(pixel.x, pixel.y);\n\n                        if (h == trianglespolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[j].itemSize = 2;\n                            bufferT[j].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var y = 0; y < border.length; y += 2) {\n                        var pixel = this.latLongToPixelXY(border[y], border[y + 1]);\n                        currentBorders[j].push(pixel.x, pixel.y);\n\n                        if (y == border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentBorders[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferB[j].itemSize = 2;\n                            bufferB[j].numItems = vertArray.length / 2;\n                        }\n                    }\n                }\n                //polygon\n                this.insertFeature(id, properties, bufferT, bufferB, []);\n            } else if (geometry.type == \"Point\" && this.dynamic == true) {\n                //dum\n                var currentPoints = [];\n                currentPoints[0] = new Array();\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                currentPoints[0].push(pixel.x, pixel.y);\n                var bufferP = [];\n                bufferP.push(gl.createBuffer());\n\n                var vertArray = new Float32Array(currentPoints[0]);\n\n                gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                bufferP[0].itemSize = 2;\n                bufferP[0].numItems = vertArray.length / 2;\n\n                this.insertFeature(id, properties, [], [], bufferP);\n\n                if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type == \"Point\" && this.dynamic == false) {\n                //debugger;\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                if (this.tempPoints == null || this.tempPoints == undefined) {\n                    this.tempPoints = new Array();\n                    for (var a = 0; a < this.aesthetics.length; a++) {\n                        this.tempPoints[a] = [];\n                    }\n                }\n\n                var aesarrays = this.fitFeature(properties);\n                for (var y = 0; y < aesarrays.length; y++) {\n                    this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);\n                }\n\n                if (this.treepoints == null) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempPoints != null) {\n                for (var t = 0; t < this.tempPoints.length; t++) {\n                    if (this.tempPoints[t].length > 0) {\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        var vertArray = new Float32Array(this.tempPoints[t]);\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(t, [], [], bufferP);\n                    }\n                }\n            }\n            //console.log(geojson)\n            if (this.treepoints != null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons == true) this.rtree = new PolygonLookup(geojson); //console.log(\"@Rui LOOK I WAS REMOVED\");\n        }\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                geojson.features[g].properties['_gisplayid'] = g;\n                var geometry = geojson.features[g].geometry;\n                var properties = geojson.features[g].properties;\n                this.createAndInsertFeature(g, geometry, properties);\n            }\n            this.buildTrees(geojson);\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.map.createCanvas(this.id);\n\n            //init webgl properties\n            this._webgl = {\n                gl: null,\n                program: null,\n                projection: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            this._webgl.projection = new Float32Array(16);\n            this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n            this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'getNumberOfFeatures',\n        value: function getNumberOfFeatures() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                count += this.aesthetics[i]._features.length;\n            }\n            return count;\n        }\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            // scaling x and y, which is just scaling first two rows of matrix\n            matrix[0] *= scaleX;\n            matrix[1] *= scaleX;\n            matrix[2] *= scaleX;\n            matrix[3] *= scaleX;\n\n            matrix[4] *= scaleY;\n            matrix[5] *= scaleY;\n            matrix[6] *= scaleY;\n            matrix[7] *= scaleY;\n        }\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            // translation is in last row of matrix\n            matrix[12] += matrix[0] * tx + matrix[4] * ty;\n            matrix[13] += matrix[1] * tx + matrix[5] * ty;\n            matrix[14] += matrix[2] * tx + matrix[6] * ty;\n            matrix[15] += matrix[3] * tx + matrix[7] * ty;\n        }\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n\n            return pixel;\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._borders.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length && this.dynamic == true; i++) {\n                for (var y = 0; y < aes._features[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                    //1);\n                }\n            }\n\n            for (var i = 0; this.dynamic == false && aes._allFeatures != null && i < aes._allFeatures.length; i++) {\n                for (var y = 0; y < aes._allFeatures[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);\n                    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);\t\n                    //1);\n                }\n            }\n        }\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n\n            for (var i = 0; i < aes._features.length; i++) {\n                var ucolor = void 0;\n                var color = void 0;\n                var diff = aes._features[i]._properties[this.attr];\n                if (diff == 0) color = aes.fillColor(0.5).rgb();else {\n                    if (diff > 0) {\n                        color = aes.fillColor(0.5 + diff / this.max / 2).rgb();\n                    } else {\n                        color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                }\n                ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];\n\n                gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawProporcionalPoints',\n        value: function drawProporcionalPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);\n\n            if (this.dynamic == true) {\n                for (var i in aes._features) {\n                    for (var y in aes._features[i]._points) {\n\n                        gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n                        var propvalue = parseFloat(aes._features[i]._properties[this.attr]);\n                        var temppointsize = (this.maxpointsize - this.minpointsize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n                        var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n                        gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n                        gl.enableVertexAttribArray(vertexCoordLocation);\n                        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                        //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                        //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                        gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                        //1);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            this.max = null;\n            this.min = null;\n            this.createCanvas();\n            this.program();\n            var mappos = void 0;\n            for (var i = 0; i < maps.length; i++) {\n                if (maps[i].id == this.id) mappos = i;\n            }this.map.onEvent('move', function () {\n                console.log(\"@Rui: mudar o profiling do window para outra coisa?\");\n                if (window.profiling == true) var start = Date.now();\n                maps[mappos].draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de Zoom/Pan (segundos):' + (end - start) / 1000);\n                }\n            });\n\n            this.setupOnclick(mappos);\n        }\n    }, {\n        key: 'setupOnclick',\n        value: function setupOnclick(mappos) {\n            console.log(\"@Rui: profiling mudar de window para? | Rtree e KdTree\");\n            maps[mappos].map.onEvent('click', function (e) {\n                if (window.profiling == true) var start = Date.now();\n                var lat = e.latlng.lat;\n                var lon = e.latlng.lng;\n\n                if (maps[mappos].rtree != undefined) {\n                    var bool = maps[0].rtree.search(lon, lat);\n                    if (bool == undefined) return;else {\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s); //todo\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n                if (maps[mappos].kdtree != undefined) {\n\n                    var nearest = maps[mappos].kdtree.nearest({ lat: lat, lon: lon }, 1, 128 / 2 ** (map.getZoom() * 2));\n                    if (nearest.length <= 0) return;else {\n                        var bool = nearest[0][0];\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s);\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de um click (segundos): ' + (end - start) / 1000);\n                }\n            });\n        }\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var result = [];\n            for (var a = 0; a < this.aesthetics.length; a++) {\n                if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true) result.push(a);\n            }\n            return result;\n        }\n    }, {\n        key: 'loadOptions',\n        value: function loadOptions(options, bgmap) {\n            if (options.customMapService == true) this.map = bgmap;else this.map = new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (options.loader != false) this.loader();\n\n            if (options.showPropertiesOnClick == true) {\n                this.showPropertiesOnClick = null;\n                //append on bgmap object\n            } else if (options.showPropertiesOnClick == false) {\n                //nada\n            } else if (options.showPropertiesOnClick != undefined) {\n                this.showPropertiesOnClick = options.showPropertiesOnClick;\n            }\n            this.alpha = options.alpha != undefined ? options.alpha : 0.8;\n            this.interactive = options.interactive == undefined ? true : !options.interactive;\n            this.attr = options.attr;\n            this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;\n            this.maxfeatures = options.maxFeatures;\n            this.breaks = options.classBreaks;\n            this.colorscheme = options.colorScheme;\n            this.numberofclasses = options.numberOfClasses;\n            this.algorithm = options.classBreaksMethod;\n            this.legendOnClickCall = options.legendOnClickFunction;\n            this.mapOnClickCall = options.mapOnClickFunction;\n            this.minuend = options.minuend;\n            this.subtrahend = options.subtrahend;\n            this.legendTitle = options.legendTitle != undefined ? options.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n            this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            this.map.loader();\n        }\n    }, {\n        key: 'drawHeatPoints',\n        value: function drawHeatPoints(aes) {\n            var gl = this._webgl.gl;\n\n            if (gl == null) return;\n            gl.useProgram(this._webgl.heatmapProgram[0]);\n            var matrixProjection = new Float32Array(16);\n\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n\n            gl.blendFunc(gl.ONE, gl.ONE);\n\n            var currentZoom = map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'position');\n            var deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'delta');\n            var intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'intensity');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'aPointSize');\n\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            gl.enableVertexAttribArray(vertexCoordLocation);\n            gl.enableVertexAttribArray(deltaLocation);\n            gl.enableVertexAttribArray(intensityLoc);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);\n            gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);\n            gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);\n            gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);\n\n            console.log(aes._allFeatures[0]._points[0].numItems);\n            gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);\n\n            gl.useProgram(this._webgl.heatmapProgram[1]);\n\n            gl.disable(gl.BLEND);\n\n            //console.log(\"fase 1 concluida\");\n\n            var canvas = document.getElementById('mapCanvas' + this.id);\n\n            var source = gl.createTexture();\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, source);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n\n            function isPowerOf2(value) {\n                return (value & value - 1) == 0;\n            };\n\n            function steupTextureFilteringAndMips(width, height, gl) {\n                if (isPowerOf2(width) && isPowerOf2(height)) {\n                    // the dimensions are power of 2 so generate mips and turn on \n                    // tri-linear filtering.\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                } else {\n                    // at least one of the dimensions is not a power of 2 so set the filtering\n                    // so WebGL will render it.\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n            };\n\n            steupTextureFilteringAndMips(canvas.width, canvas.height, gl);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            var vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n            var buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            var positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], 'position');\n            var sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], 'source');\n            gl.enableVertexAttribArray(positionLoc);\n            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.uniform1i(sourceLoc, 0);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            gl.disableVertexAttribArray(positionLoc);\n            //defaults to general program\n            //console.log(\"fase 2 concluida\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'getNumberOfPolygons',\n        value: function getNumberOfPolygons() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                for (var z = 0; z < this.aesthetics[i]._features.length; z++) {\n                    count += this.aesthetics[i]._features[z]._triangles.length;\n                }\n            }\n            return count;\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL01hcC5qcz8xZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJHTWFwV3JhcHBlciB9IGZyb20gJy4vQkdNYXBXcmFwcGVyJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKiBcclxuICogRVM1IGxpYnJhcmllcyBjYW4gYmUgdXNlZCBlaXRoZXIgd2l0aCBcclxuICogMSlpbXBvcnQgaWYgdGhleSBhcmUganVzdCBmdW5jdGlvbnMgb3IgaW4gdGhlIGNhc2Ugb2YgcnRyZWUgYW5kIGt0cmVlIGEgXHJcbiAqIHdlYnBhY2sgbG9hZGVyIGlzIG5lZWRlZCBcInNjcmlwdC1sb2FkZXJcIlwiIGNhbiBkbyB0aGF0LlxyXG4gKiAyKSBBZGRlZCBhcyA8c2NyaXB0PiB0YWcgb24gaW5kZXguaHRtbCBmaWxlXHJcbiAqIFRoZSBmb3JtZXIgYXMgY2hvb3Nlbi5cclxuaW1wb3J0IGNocm9tYSBmcm9tICcuLi8uLi9saWIvY2hyb21hLm1pbic7XHJcbmltcG9ydCBlYXJjdXQgZnJvbSAnLi4vLi4vbGliL2VhcmN1dCdcclxuaW1wb3J0IHtQb2x5Z29uTG9va3VwfSBmcm9tICcuLi8uLi9saWIvcnRyZWUnO1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgdGhlIE1hcCBjbGFzcyB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG1hcC5cclxuICogRWFjaCBtYXAgaGFzIGEgZ3JvdXAgb2YgZnVuY3Rpb25zIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXAgY29uc3RydWN0b3IgY2FsbGVkIC0+IHN1cGVyKClcIilcclxuICAgICAgICAvKiByZXR1cm4gdGhpczsqLyAvL0BUT0RPIFJlbW92ZSBpc250IGRvaW5nIGFueXRoaW5nPyBvciBpcyBpdCBzYXZpbmcgdGhlIDMgcGFyYW1ldGVycz9cclxuICAgIH1cclxuXHJcbiAgICBwcm9ncmFtKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2dyYW0gPSB0aGlzLl93ZWJnbC5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW0gPSBbXTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlX2NvZGUgPSB0aGlzLmdlbmVyYXRlU2hhZGVycygpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuVkVSVEVYX1NIQURFUiwgc291cmNlX2NvZGUudmVydGV4LCB0aGlzLl93ZWJnbCk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuRlJBR01FTlRfU0hBREVSLCBzb3VyY2VfY29kZS5mcmFnbWVudCwgdGhpcy5fd2ViZ2wpO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5hdHRhY2hTaGFkZXIodGhpcy5fd2ViZ2wucHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3dlYmdsLnByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmxpbmtQcm9ncmFtKHRoaXMuX3dlYmdsLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNoYWRlcih0eXBlLCBzb3VyY2VfY29kZSwgX3dlYmdsKSB7IC8vQWRkZWQgSEVSRSBieSBSdWlcclxuICAgICAgICB2YXIgc2hhZGVyID0gX3dlYmdsLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuXHJcbiAgICAgICAgX3dlYmdsLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZV9jb2RlKTtcclxuICAgICAgICBfd2ViZ2wuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcInNoYWRlciBcIiArICh0eXBlLnZhbHVlT2YoKSA9PSAzNTYzMyA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIpICsgXCI6IFwiICsgX3dlYmdsLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVTaGFkZXJzKCkgeyAvL0FkZGVkIEhFUkUgYnkgUnVpIEBUT0RPIFJlZmFjdG9yIHRvIHVzZSBFUzYgYGAgaW5zdGVhZCBvZiArPVxyXG4gICAgICAgIC8vZ2VuZXJhbFxyXG5cclxuICAgICAgICBsZXQgdmVydGV4U291cmNlQ29kZSA9IFwiIGF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvb3JkOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRhdHRyaWJ1dGUgZmxvYXQgYVBvaW50U2l6ZTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb247IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdGF0dHJpYnV0ZSBmbG9hdCBhX29wYWNpdHk7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdHZhcnlpbmcgZmxvYXQgdl9vcGFjaXR5OyBcIjtcclxuICAgICAgICAvL3ZlcnRleFNvdXJjZUNvZGUrPSBcIlxcblx0dmFyeWluZyB2ZWM0IHVfY29sb3I7IFwiIDsgLy9kZWxldGVcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHR2b2lkIG1haW4oKSB7XCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0XHRnbF9Qb3NpdGlvbiA9IChwcm9qZWN0aW9uICogdmVydGV4Q29vcmQpOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRcdGdsX1BvaW50U2l6ZSA9IGFQb2ludFNpemU7IHZfb3BhY2l0eSA9IGFfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcbn1cIjtcclxuXHJcbiAgICAgICAgbGV0IGZyYWdtZW50U291cmNlQ29kZSA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1wiOy8vdW5pZm9ybVxyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR2YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuIFx0XHR1bmlmb3JtIGZsb2F0IGlzUG9pbnQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHZvaWQgbWFpbigpe1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGZsb2F0IGJvcmRlciA9IDAuNTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCByYWRpdXMgPSAwLjU7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgY2VudGVyRGlzdCA9IGxlbmd0aChnbF9Qb2ludENvb3JkIC0gMC41KTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCBhbHBoYTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRpZiAodV9jb2xvclszXSA9PSAtMS4wKXtcIjsgICAvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHZfb3BhY2l0eSAqIHN0ZXAoY2VudGVyRGlzdCwgcmFkaXVzKTtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHR9XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZWxzZXtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHVfY29sb3JbM10gKiBzdGVwKGNlbnRlckRpc3QsIHJhZGl1cyk7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0fVwiOy8vdW5uZWNlc3Nhcnk/P1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGlmKGlzUG9pbnQgPT0gMS4wICl7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0aWYgKGFscGhhIDwgMC4xKSBkaXNjYXJkO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yWzBdLCB1X2NvbG9yWzFdLCB1X2NvbG9yWzJdLCBhbHBoYSk7fVwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcbiBcdFx0XHRlbHNlXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3JbMF0sIHVfY29sb3JbMV0sIHVfY29sb3JbMl0sIHVfY29sb3JbM10pO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR9XCI7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHZlcnRleDogdmVydGV4U291cmNlQ29kZSwgZnJhZ21lbnQ6IGZyYWdtZW50U291cmNlQ29kZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEFlc3RoZXRpYyhhZXMpIHtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MucHVzaChhZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEFlc3RoZXRpYyhpZCwgYWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCA9PSBhZXN0aGV0aWNzW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZXN0aGV0aWNzW2ldID0gYWVzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7dGhpcy5pZH1gKTtcclxuICAgICAgICBjb25zdCBsZWdlbmREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBsZWdlbmREaXYuaWQgPSBgbGVnZW5kRGl2JHt0aGlzLmlkfWA7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAvL2xlZ2VuZERpdi5zdHlsZS5oZWlnaHQgPSAyMDA7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUud2lkdGggPSAyNTA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3R0b20gPSAyMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJvcmRlciA9ICdzb2xpZCc7XHJcblxyXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICBjb25zdCB0aHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICBjb25zdCB0aGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICAvL3RodmFsdWUuc3R5bGUud2lkdGggPSAxMjU7XHJcbiAgICAgICAgdGFibGUuc3R5bGUuekluZGV4ID0gXCIyMDAwXCI7XHJcbiAgICAgICAgdGhjb2xvci5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0aGNvbG9yKTtcclxuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0aHZhbHVlKTtcclxuXHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudGFlcyBvZiB0aGlzLmFlc3RoZXRpY3MpIHtcclxuICAgICAgICAgICAgLy9pZihjdXJyZW50YWVzLl9mZWF0dXJlcy5sZW5ndGggPiAwIHx8IGN1cnJlbnRhZXMuX2FsbEZlYXR1cmVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICAgICAgY29uc3QgcHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRhZXMucmFuZ2VbMF0gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHtjdXJyZW50YWVzLnJhbmdlWzBdfSwgJHtjdXJyZW50YWVzLnJhbmdlWzFdfVtgKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnRhZXMucmFuZ2VbMF0pO1xyXG4gICAgICAgICAgICBwdGV4dC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQocHRleHQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclszXX0pYDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZ2JjKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddID0gcmdiYztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbG9yLmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuXHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjb2xvcik7XHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlZ2VuZERpdi5hcHBlbmRDaGlsZCh0YWJsZSk7XHJcbiAgICAgICAgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQobGVnZW5kRGl2KTtcclxuICAgIH1cclxuXHJcbiAgICBwcmVQcm9jZXNzRGF0YShnZW9qc29uLCBudW1iZXJPZiwgYWxnb3JpdGhtLCBjb2xvcnNjaGVtZSkge1xyXG5cclxuICAgICAgICBjb25zdCBhZXNhcnJheSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcclxuICAgICAgICBsZXQgYnJlYWtzO1xyXG4gICAgICAgIGxldCBmY29sb3I7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgaWYgKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdICE9IG51bGwgJiYgdHlwZW9mIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJpbmdzLmluY2x1ZGVzKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKSlcclxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHsvL3F1YW50aXRhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5icmVha3MgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2YgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IHRoaXMuY2FsY0NsYXNzQnJlYWtzKHZhbHVlcywgYWxnb3JpdGhtLCBudW1iZXJPZik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtzID0gW3RoaXMubWluLCB0aGlzLm1heF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSB0aGlzLmJyZWFrcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnJlYWtzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYWtzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGNocm9tYShmY29sb3JbaV0pLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IGJyZWFrcy5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbaV0sIGJyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbaV0sIGJyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjaHJvbWEoY29sb3JzY2hlbWVbMF0pLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgdGhpcy5hbHBoYV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1swXSwgYnJlYWtzWzFdXSk7XHJcbiAgICAgICAgICAgICAgICBhZXMub3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIHsvL3F1YWxpdGF0aXZlXHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IHN0cmluZ3M7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yc2NoZW1lID09PSAnc3RyaW5nJykgey8vc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKS5jb2xvcnMoYnJlYWtzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9hcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmVha3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCAxXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbc3RyaW5nc1tpXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gYWVzYXJyYXk7XHJcbiAgICAgICAgLy9yZXR1cm4gYWVzYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FsY0NsYXNzQnJlYWtzKHZhbHVlcywgYWxnb3JpdGhtLCBudW1iZXJPZikge1xyXG4gICAgICAgIGxldCBicmVha3M7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0pIHtcclxuICAgICAgICAgICAgY2FzZSAnZXF1aWRpc3RhbnQnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdlJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBjaHJvbWEubGltaXRzKHZhbHVlcywgJ3EnLCBudW1iZXJPZik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2stbWVhbnMnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdrJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdxJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicmVha3M7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uY2hlY2tQcm9wZXJ0eShwcm9wZXJ0aWVzW3RoaXMuYWVzdGhldGljc1tpXS5nZXRBdHRyKCldKSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFlc3RoZXRpY3NbaV0uYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbGFnKSB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ETzogZmVhdHVyZSBkb2VzIG5vdCBmaXQgaW50byBhbnkgb2YgdGhlIGFlc3RoZXRpY3MgZGVmaW5lZC5cXG4gVmFsdWU6IFwiICsgcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0R3JvdXBlZEZlYXR1cmUoaWRhZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzW2lkYWVzXS5hZGRHcm91cGVkRmVhdHVyZShudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICBhbGVydChcImRyYXcoKSBub3QgaW1wbGVtZW50ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc1BvbHlnb24ocG9seWdvbikge1xyXG5cclxuICAgICAgICBpZiAocG9seWdvbi5nZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5zaWRlcG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgIC8vaW5zaWRlcG9seWdvbnMucHVzaChwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcFZlcnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChvdXRzaWRlcG9seWdvbltvdXRdWzBdLCBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXhjb3VudCArPSAob3V0c2lkZXBvbHlnb24ubGVuZ3RoICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvbjogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzBdICsgXCIgbGF0OiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG4gICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICBwb2x5YXJyYXkucHVzaCh7IHRyaWFuZ2xlczogdHJpYW5nbGVzX3ZlcnQsIHZlcnRleDogdGVtcFZlcnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBlbHNlIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB2YXIgcG9seWFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1bMF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZXBvbHlnb25zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBpbnNpZGVwb2x5Z29ucy5wdXNoKHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1ba10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBWZXJ0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgX3ZlcnRleGNvdW50ICs9IG91dHNpZGVwb2x5Z29uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRzLnB1c2gob3V0c2lkZXBvbHlnb25bb3V0XVswXSwgb3V0c2lkZXBvbHlnb25bb3V0XVsxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJsb246IFwiICsgb3V0c2lkZXBvbHlnb25bb3V0XVswXSArIFwiIGxhdDogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFyIHRlbXAgPSBlYXJjdXQuZmxhdHRlbihwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHRyaWFuZ2xlc192ZXJ0ID0gZWFyY3V0KHRlbXAudmVydGljZXMsIHRlbXAuaG9sZXMsIHRlbXAuZGltZW5zaW9ucyk7XHJcbiAgICAgICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0ZXg6IHRlbXBWZXJ0cyB9KTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9seWFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5YXJyYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzRGF0YShnZW9qc29uKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkR2VvSlNPTihnZW9qc29uKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVBbmRJbnNlcnRGZWF0dXJlKGlkLCBnZW9tZXRyeSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMubWludWVuZCAhPSB1bmRlZmluZWQgJiYgdGhpcy5zdWJ0cmFoZW5kICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJvcGVydGllc1t0aGlzLm1pbnVlbmRdID09ICdudW1iZXInXHJcbiAgICAgICAgICAgICYmIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAmJiBwcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbdGhpcy5hdHRyXSA9IHByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAtIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiIHx8IGdlb21ldHJ5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BvbHlnb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbnMgPSB0aGlzLnByb2Nlc3NQb2x5Z29uKHsgZ2VvbWV0cnksIHByb3BlcnRpZXMgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9yZGVycyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJpYW5nbGVzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclQgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyQiA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2x5Z29ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJpYW5nbGVzcG9seWdvbiA9IHBvbHlnb25zW2pdLnRyaWFuZ2xlcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlciA9IHBvbHlnb25zW2pdLnZlcnRleDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmlhbmdsZXNbal0gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2pdID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IHRyaWFuZ2xlc3BvbHlnb24ubGVuZ3RoOyBoKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoYm9yZGVyW3RyaWFuZ2xlc3BvbHlnb25baF0gKiAyXSwgYm9yZGVyW3RyaWFuZ2xlc3BvbHlnb25baF0gKiAyICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmlhbmdsZXNbal0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPT0gdHJpYW5nbGVzcG9seWdvbi5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclQucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50VHJpYW5nbGVzW2pdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyVFtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclRbal0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJUW2pdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGJvcmRlci5sZW5ndGg7IHkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShib3JkZXJbeV0sIGJvcmRlclt5ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2pdLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID09IGJvcmRlci5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckIucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50Qm9yZGVyc1tqXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5mc2l6ZSA9IHZlcnRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckJbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCW2pdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQltqXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9wb2x5Z29uXHJcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgYnVmZmVyVCwgYnVmZmVyQiwgW10pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2ludFwiICYmIHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vZHVtXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJQID0gW107XHJcbiAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50UG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyUFswXSk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlclBbMF0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICBidWZmZXJQWzBdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIFtdLCBbXSwgYnVmZmVyUCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzID09IG51bGwgfHwgdGhpcy50cmVlcG9pbnRzID09IHVuZGVmaW5lZCkgdGhpcy50cmVlcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cy5wdXNoKHsgbG9uOiBnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgbGF0OiBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSwgcHJvcGVydGllcyB9KTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PSBcIlBvaW50XCIgJiYgdGhpcy5keW5hbWljID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVidWdnZXI7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZW1wUG9pbnRzID09IG51bGwgfHwgdGhpcy50ZW1wUG9pbnRzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wUG9pbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcFBvaW50c1thXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhZXNhcnJheXMgPSB0aGlzLmZpdEZlYXR1cmUocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYWVzYXJyYXlzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBQb2ludHNbYWVzYXJyYXlzW3ldXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzID09IG51bGwpIHRoaXMudHJlZXBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVwb2ludHMucHVzaCh7IGxvbjogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGxhdDogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIHByb3BlcnRpZXMgfSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBidWlsZFRyZWVzKGdlb2pzb24pIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMudGVtcFBvaW50cy5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGVtcFBvaW50c1t0XS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy50ZW1wUG9pbnRzW3RdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlclBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0R3JvdXBlZEZlYXR1cmUodCwgW10sIFtdLCBidWZmZXJQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhnZW9qc29uKVxyXG4gICAgICAgIGlmICh0aGlzLnRyZWVwb2ludHMgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5rZHRyZWUgPSBuZXcga2RUcmVlKHRoaXMudHJlZXBvaW50cywgKGEsIGIpID0+IChhLmxvbiAtIGIubG9uKSAqKiAyICsgKGEubGF0IC0gYi5sYXQpICoqIDIsIFtcImxvblwiLCBcImxhdFwiLCBcInByb3BlcnRpZXNcIl0pO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1BvbHlnb25zID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMucnRyZWUgPSBuZXcgUG9seWdvbkxvb2t1cChnZW9qc29uKTsvL2NvbnNvbGUubG9nKFwiQFJ1aSBMT09LIEkgV0FTIFJFTU9WRURcIik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEdlb0pTT04oZ2VvanNvbikge1xyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggJiYgKHRoaXMubWF4ZmVhdHVyZXMgPT0gdW5kZWZpbmVkIHx8IGcgPCB0aGlzLm1heGZlYXR1cmVzKTsgZysrKSB7XHJcbiAgICAgICAgICAgIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1snX2dpc3BsYXlpZCddID0gZztcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ddLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEluc2VydEZlYXR1cmUoZywgZ2VvbWV0cnksIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1aWxkVHJlZXMoZ2VvanNvbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLm1hcC5jcmVhdGVDYW52YXModGhpcy5pZCk7XHJcblxyXG4gICAgICAgIC8vaW5pdCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wgPSB7XHJcbiAgICAgICAgICAgIGdsOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5wcm9qZWN0aW9uLnNldChbMiAvIGNhbnZhcy53aWR0aCwgMCwgMCwgMCwgMCwgLTIgLyBjYW52YXMuaGVpZ2h0LCAwLCAwLCAwLCAwLCAwLCAwLCAtMSwgMSwgMCwgMV0pO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5vZmZzZXRXaWR0aCwgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5kaXNhYmxlKHRoaXMuX3dlYmdsLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE51bWJlck9mRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlUHJvamVjdGlvbihtYXRyaXgsIHNjYWxlWCwgc2NhbGVZKSB7XHJcbiAgICAgICAgLy8gc2NhbGluZyB4IGFuZCB5LCB3aGljaCBpcyBqdXN0IHNjYWxpbmcgZmlyc3QgdHdvIHJvd3Mgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzBdICo9IHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMV0gKj0gc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFsyXSAqPSBzY2FsZVg7XHJcbiAgICAgICAgbWF0cml4WzNdICo9IHNjYWxlWDtcclxuXHJcbiAgICAgICAgbWF0cml4WzRdICo9IHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbNV0gKj0gc2NhbGVZO1xyXG4gICAgICAgIG1hdHJpeFs2XSAqPSBzY2FsZVk7XHJcbiAgICAgICAgbWF0cml4WzddICo9IHNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeCwgdHgsIHR5KSB7XHJcbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgaW4gbGFzdCByb3cgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzEyXSArPSBtYXRyaXhbMF0gKiB0eCArIG1hdHJpeFs0XSAqIHR5O1xyXG4gICAgICAgIG1hdHJpeFsxM10gKz0gbWF0cml4WzFdICogdHggKyBtYXRyaXhbNV0gKiB0eTtcclxuICAgICAgICBtYXRyaXhbMTRdICs9IG1hdHJpeFsyXSAqIHR4ICsgbWF0cml4WzZdICogdHk7XHJcbiAgICAgICAgbWF0cml4WzE1XSArPSBtYXRyaXhbM10gKiB0eCArIG1hdHJpeFs3XSAqIHR5O1xyXG4gICAgfVxyXG5cclxuICAgIGxhdExvbmdUb1BpeGVsWFkobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIGNvbnN0IHBpXzE4MCA9IE1hdGguUEkgLyAxODAuMDtcclxuICAgICAgICBjb25zdCBwaV80ID0gTWF0aC5QSSAqIDQ7XHJcbiAgICAgICAgY29uc3Qgc2luTGF0aXR1ZGUgPSBNYXRoLnNpbihsYXRpdHVkZSAqIHBpXzE4MCk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxZID0gKDAuNSAtIE1hdGgubG9nKCgxICsgc2luTGF0aXR1ZGUpIC8gKDEgLSBzaW5MYXRpdHVkZSkpIC8gKHBpXzQpKSAqIDI1NjtcclxuICAgICAgICBjb25zdCBwaXhlbFggPSAoKGxvbmdpdHVkZSArIDE4MCkgLyAzNjApICogMjU2O1xyXG5cclxuICAgICAgICBjb25zdCBwaXhlbCA9IHsgeDogcGl4ZWxYLCB5OiBwaXhlbFkgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpeGVsO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3VHJpYW5nbGVzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdCb3JkZXJzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAwLjApO1xyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuc3Ryb2tlQ29sb3JbMF0gLyAyNTUsIGFlcy5zdHJva2VDb2xvclsxXSAvIDI1NSwgYWVzLnN0cm9rZUNvbG9yWzJdIC8gMjU1LCBhZXMuc3Ryb2tlQ29sb3JbM10pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX0xPT1AsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvaW50cyhhZXMpIHtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA0LjAgKyBhZXMucG9pbnRTaXplLCBhZXMucG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAxLjApO1xyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWVzLl9mZWF0dXJlcy5sZW5ndGggJiYgdGhpcy5keW5hbWljID09IHRydWU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50cy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50c1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuZHluYW1pYyA9PSBmYWxzZSAmJiBhZXMuX2FsbEZlYXR1cmVzICE9IG51bGwgJiYgaSA8IGFlcy5fYWxsRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMtMik7XHRcclxuICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHVjb2xvcjtcclxuICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdO1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSkucmdiKCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSArIGRpZmYgLyB0aGlzLm1heCAvIDIpLnJnYigpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgLSBkaWZmIC8gdGhpcy5taW4gLyAyKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWNvbG9yID0gW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIHVjb2xvclswXSAvIDI1NSwgdWNvbG9yWzFdIC8gMjU1LCB1Y29sb3JbMl0gLyAyNTUsIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlcy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlc1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UHJvcG9yY2lvbmFsUG9pbnRzKGFlcykge1xyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCB0aGlzLmFscGhhKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBhZXMuX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHkgaW4gYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3B2YWx1ZSA9IHBhcnNlRmxvYXQoYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKCh0aGlzLm1heHBvaW50c2l6ZSAtIHRoaXMubWlucG9pbnRzaXplKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSkgKiAocHJvcHZhbHVlIC0gdGhpcy5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNC4wICsgdGVtcHBvaW50c2l6ZSAqIGN1cnJlbnRab29tIC8gNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLm1heCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5taW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtKCk7XHJcbiAgICAgICAgbGV0IG1hcHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChtYXBzW2ldLmlkID09IHRoaXMuaWQpXHJcbiAgICAgICAgICAgICAgICBtYXBwb3MgPSBpO1xyXG4gICAgICAgIHRoaXMubWFwLm9uRXZlbnQoJ21vdmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFJ1aTogbXVkYXIgbyBwcm9maWxpbmcgZG8gd2luZG93IHBhcmEgb3V0cmEgY29pc2E/XCIpXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBtYXBzW21hcHBvc10uZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIFpvb20vUGFuIChzZWd1bmRvcyk6JHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNldHVwT25jbGljayhtYXBwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwT25jbGljayhtYXBwb3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkBSdWk6IHByb2ZpbGluZyBtdWRhciBkZSB3aW5kb3cgcGFyYT8gfCBSdHJlZSBlIEtkVHJlZVwiKVxyXG4gICAgICAgIG1hcHNbbWFwcG9zXS5tYXAub25FdmVudCgnY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGUubGF0bG5nLmxhdDtcclxuICAgICAgICAgICAgY29uc3QgbG9uID0gZS5sYXRsbmcubG5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5ydHJlZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib29sID0gbWFwc1swXS5ydHJlZS5zZWFyY2gobG9uLCBsYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvb2wgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljay5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7bWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpICsgMV19OiAke2Jvb2wucHJvcGVydGllc1ttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYm9vbC5wcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0gIT0gXCJfZ2lzcGxheWlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7a2V5c1tpXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW2tleXNbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uaW50ZXJhY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQocyk7Ly90b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQgJiYgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbChib29sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLmtkdHJlZSAhPSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0ID0gbWFwc1ttYXBwb3NdLmtkdHJlZS5uZWFyZXN0KHsgbGF0LCBsb24gfSwgMSwgMTI4IC8gKCgyICoqIChtYXAuZ2V0Wm9vbSgpICogMikpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdC5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9vbCA9IG5lYXJlc3RbMF1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhib29sLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXSAhPSBcIl9naXNwbGF5aWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5pbnRlcmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZCAmJiBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsKGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIHVtIGNsaWNrIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZml0RmVhdHVyZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1thXS5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbdGhpcy5hZXN0aGV0aWNzW2FdLmdldEF0dHIoKV0pID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmN1c3RvbU1hcFNlcnZpY2UgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBiZ21hcDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IEJHTWFwV3JhcHBlcihiZ21hcCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVyICE9IGZhbHNlKVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlcigpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dQcm9wZXJ0aWVzT25DbGljayA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vYXBwZW5kIG9uIGJnbWFwIG9iamVjdFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvL25hZGFcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID0gb3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxwaGEgOiAwLjg7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuaW50ZXJhY3RpdmUgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICFvcHRpb25zLmludGVyYWN0aXZlO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IG9wdGlvbnMuYXR0cjtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLm1lbW9yeVNhdmVyID09IHVuZGVmaW5lZCA/IGZhbHNlIDogIW9wdGlvbnMubWVtb3J5U2F2ZXI7XHJcbiAgICAgICAgdGhpcy5tYXhmZWF0dXJlcyA9IG9wdGlvbnMubWF4RmVhdHVyZXM7XHJcbiAgICAgICAgdGhpcy5icmVha3MgPSBvcHRpb25zLmNsYXNzQnJlYWtzO1xyXG4gICAgICAgIHRoaXMuY29sb3JzY2hlbWUgPSBvcHRpb25zLmNvbG9yU2NoZW1lO1xyXG4gICAgICAgIHRoaXMubnVtYmVyb2ZjbGFzc2VzID0gb3B0aW9ucy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmNsYXNzQnJlYWtzTWV0aG9kO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT25DbGlja0NhbGwgPSBvcHRpb25zLmxlZ2VuZE9uQ2xpY2tGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLm1hcE9uQ2xpY2tDYWxsID0gb3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5taW51ZW5kID0gb3B0aW9ucy5taW51ZW5kO1xyXG4gICAgICAgIHRoaXMuc3VidHJhaGVuZCA9IG9wdGlvbnMuc3VidHJhaGVuZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZFRpdGxlID0gb3B0aW9ucy5sZWdlbmRUaXRsZSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmxlZ2VuZFRpdGxlIDogKHRoaXMuYXR0ciAhPSB1bmRlZmluZWQgPyB0aGlzLmF0dHIgOiBgJHt0aGlzLm1pbnVlbmR9IC0gJHt0aGlzLnN1YnRyYWhlbmR9YCk7XHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkxlZ2VuZEl0ZW1zID0gb3B0aW9ucy5udW1iZXJPZkxlZ2VuZEl0ZW1zICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVtYmVyT2ZMZWdlbmRJdGVtcyA6IDI7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMubWFwLmxvYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdIZWF0UG9pbnRzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnZGVsdGEnKTtcclxuICAgICAgICBjb25zdCBpbnRlbnNpdHlMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ2ludGVuc2l0eScpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnYVBvaW50U2l6ZScpO1xyXG5cclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbHRhTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGludGVuc2l0eUxvYyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDAgKiAyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbHRhTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCAyICogNCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbnRlbnNpdHlMb2MsIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCA0ICogNCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuXHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0pO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImZhc2UgMSBjb25jbHVpZGFcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzb3VyY2UpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY2FudmFzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb3dlck9mMih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3RldXBUZXh0dXJlRmlsdGVyaW5nQW5kTWlwcyh3aWR0aCwgaGVpZ2h0LCBnbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQb3dlck9mMih3aWR0aCkgJiYgaXNQb3dlck9mMihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGltZW5zaW9ucyBhcmUgcG93ZXIgb2YgMiBzbyBnZW5lcmF0ZSBtaXBzIGFuZCB0dXJuIG9uIFxyXG4gICAgICAgICAgICAgICAgLy8gdHJpLWxpbmVhciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgbm90IGEgcG93ZXIgb2YgMiBzbyBzZXQgdGhlIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gc28gV2ViR0wgd2lsbCByZW5kZXIgaXQuXHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgICAgIHN0ZXVwVGV4dHVyZUZpbHRlcmluZ0FuZE1pcHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCBnbCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMV0pO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0sICdwb3NpdGlvbicpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xaShzb3VyY2VMb2MsIDApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuXHJcblxyXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvYyk7XHJcbiAgICAgICAgLy9kZWZhdWx0cyB0byBnZW5lcmFsIHByb2dyYW1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmFzZSAyIGNvbmNsdWlkYVwiKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROdW1iZXJPZlBvbHlnb25zKCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzW3pdLl90cmlhbmdsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBOzs7Ozs7Ozs7OztBQVdBOzs7O0FBSUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF1QkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXVEQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/Gisplay/Aesthetic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Class that represents an aesthetic element. There will be one Aesthetic class for each class on the Legend.\r\n * \r\n * @export\r\n * @class Aesthetic\r\n */\nvar Aesthetic = exports.Aesthetic = function () {\n\n    /**\r\n     * Creates an instance of Aesthetic. \r\n     * There will be as many Aesthetic objects as the number of classes on the Legend. \r\n     * @example 1-> {\"id\":0,\"attr\":\"f3\",\"fcolor\":[255,255,255,0.8],\r\n     *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[1,37]}\r\n     * @example 2-> {\"id\":1,\"attr\":\"f3\",\"fcolor\":[255,255,0,0.8],\r\n     *         \"stroke\":[0,0,0,1],\"pointsize\":null,\"range\":[37,78]}\r\n     * @param {number} id - The unique id of the Aesthetic object.\r\n     * @param {string} attr - The attribute being mapped on this Aesthetic.\r\n     * @param {number[]} fcolor - The color to fill the Aesthetic element(RGBA).\r\n     * @param {number[]} stroke - Stroke color values(RGBA).\r\n     * @param {number|null} pointsize - Size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n     * @param {number[]} range - The range for this particular Aesthetic element.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n    function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n        _classCallCheck(this, Aesthetic);\n\n        /**\r\n         * The unique id of the Aesthetic object. \r\n         * @type {number}\r\n         */\n        this.id = id;\n        /**\r\n         * The attribute being mapped on the Aesthetic.\r\n         * @type {string}\r\n         */\n        this._attr = attr;\n        /**\r\n         * The color to fill the Aesthetic element(RGBA).\r\n         * @type {number[4]}\r\n         */\n        this.fillColor = fcolor;\n        /**\r\n         * Stroke color values(RGBA).\r\n         * @type {number[4]}\r\n         */\n        this.strokeColor = stroke;\n        /**\r\n         * The size of the Aesthetic point to be drawn (Used only in maps that require dots to be drawn).\r\n         * @type {number|null}\r\n         */\n        this.pointSize = pointsize == null ? 1.0 : parseFloat(pointsize);\n        /**\r\n         * The range for this particular Aesthetic element.\r\n         * @type {number[2]}\r\n         */\n        this.range = range;\n        /**\r\n         * This Array will keep track of all Features associated with this Aesthetic object.\r\n         * @type {Array<Feature>}\r\n         */\n        this._features = new Array();\n        /**\r\n         * This Array is used for? \r\n         * @todo\r\n         * @type {Array<Feature>}\r\n         */\n        this._allFeatures = null;\n        /**\r\n         * This particular element will be active or not in the Legend.\r\n         * @type {boolean}\r\n         */\n        this.enabled = true; //Elemento da legenda ativado ou desativado\n        /**\r\n         * Outer of? This is used for what?\r\n         * @type {boolean}\r\n         */\n        this.outer = false;\n        return this; //@TODO remove this\n    }\n\n    /**\r\n     * Adds a new feature to this Aesthetic object.\r\n     * @param {number} id - The Feature id. Each feature will have a different id inside this Aesthetic object.\r\n     * @param {{fx: string, _gisplayid:number}} properties - Properties associated with the Feature.\r\n     * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with the Feature.\r\n     * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with the Feature.\r\n     * @param {number[]} points - The points that belong to the Feature.\r\n     * \r\n     * @memberOf Aesthetic\r\n     */\n\n\n    _createClass(Aesthetic, [{\n        key: 'addFeature',\n        value: function addFeature(id, properties, triangles, borders, points) {\n            this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n        }\n\n        /**\r\n         * Gets this Aesthetic attribute.\r\n         * @returns {Aesthetic._attr} - The string representing the attr of this Aesthetic.\r\n         * \r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'getAttr',\n        value: function getAttr() {\n            return this._attr;\n        }\n\n        /**\r\n         * Verifies the existence or not of the property Aesthethic._attr and if it inside the range.\r\n         * Verifica se est dentro ou nao do range \r\n         * @param {string} value - The attribute  \r\n         * @returns {boolean} - True if there's no range or ?\r\n         * \r\n         * @memberOf Aesthetic\r\n         */\n\n    }, {\n        key: 'checkProperty',\n        value: function checkProperty(value) {\n            if (this.range == null) return true;else {\n                if (typeof value === 'number') return (this.range[0] == null || value >= this.range[0]) && (this.range[1] == null || value < this.range[1] || value <= this.range[1] && this.outer == true);else return value == this.range[0];\n            }\n        }\n    }, {\n        key: 'addGroupedFeature',\n        value: function addGroupedFeature(id, triangles, borders, points) {\n            if (this._allFeatures == null) {\n                this._allFeatures = new Array();\n                this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n            } else {\n                var cursor = 0; //TODO\n                //this._allFeatures[0]._properties.push(properties);\n                this._allFeatures[cursor].push(new _Feature.Feature(id, null, triangles, borders, points));\n                //this._allFeatures[cursor]._triangles.concat(triangles);\n                //this._allFeatures[cursor]._borders.concat(borders);\n            }\n        }\n    }, {\n        key: 'enableDisable',\n        value: function enableDisable() {\n            this.enabled = !this.enabled;\n            return this.enabled;\n        }\n    }]);\n\n    return Aesthetic;\n}();\n\n/*var obj = {\r\n           i: id,\r\n           a: attr,\r\n           f: fcolor,\r\n           s: stroke,\r\n           p: pointsize,\r\n           r: range\r\n       }\r\n       console.warn(\"Aest called constructor!!! == \" + JSON.stringify(obj));*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9BZXN0aGV0aWMuanM/NTllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi9GZWF0dXJlJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IHJlcHJlc2VudHMgYW4gYWVzdGhldGljIGVsZW1lbnQuIFRoZXJlIHdpbGwgYmUgb25lIEFlc3RoZXRpYyBjbGFzcyBmb3IgZWFjaCBjbGFzcyBvbiB0aGUgTGVnZW5kLlxyXG4gKiBcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgQWVzdGhldGljXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQWVzdGhldGljIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQWVzdGhldGljLiBcclxuICAgICAqIFRoZXJlIHdpbGwgYmUgYXMgbWFueSBBZXN0aGV0aWMgb2JqZWN0cyBhcyB0aGUgbnVtYmVyIG9mIGNsYXNzZXMgb24gdGhlIExlZ2VuZC4gXHJcbiAgICAgKiBAZXhhbXBsZSAxLT4ge1wiaWRcIjowLFwiYXR0clwiOlwiZjNcIixcImZjb2xvclwiOlsyNTUsMjU1LDI1NSwwLjhdLFxyXG4gICAgICogICAgICAgICBcInN0cm9rZVwiOlswLDAsMCwxXSxcInBvaW50c2l6ZVwiOm51bGwsXCJyYW5nZVwiOlsxLDM3XX1cclxuICAgICAqIEBleGFtcGxlIDItPiB7XCJpZFwiOjEsXCJhdHRyXCI6XCJmM1wiLFwiZmNvbG9yXCI6WzI1NSwyNTUsMCwwLjhdLFxyXG4gICAgICogICAgICAgICBcInN0cm9rZVwiOlswLDAsMCwxXSxcInBvaW50c2l6ZVwiOm51bGwsXCJyYW5nZVwiOlszNyw3OF19XHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgdW5pcXVlIGlkIG9mIHRoZSBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSBUaGUgYXR0cmlidXRlIGJlaW5nIG1hcHBlZCBvbiB0aGlzIEFlc3RoZXRpYy5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IGZjb2xvciAtIFRoZSBjb2xvciB0byBmaWxsIHRoZSBBZXN0aGV0aWMgZWxlbWVudChSR0JBKS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHN0cm9rZSAtIFN0cm9rZSBjb2xvciB2YWx1ZXMoUkdCQSkuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcnxudWxsfSBwb2ludHNpemUgLSBTaXplIG9mIHRoZSBBZXN0aGV0aWMgcG9pbnQgdG8gYmUgZHJhd24gKFVzZWQgb25seSBpbiBtYXBzIHRoYXQgcmVxdWlyZSBkb3RzIHRvIGJlIGRyYXduKS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJhbmdlIC0gVGhlIHJhbmdlIGZvciB0aGlzIHBhcnRpY3VsYXIgQWVzdGhldGljIGVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIGF0dHIsIGZjb2xvciwgc3Ryb2tlLCBwb2ludHNpemUsIHJhbmdlKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuaXF1ZSBpZCBvZiB0aGUgQWVzdGhldGljIG9iamVjdC4gXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZSBiZWluZyBtYXBwZWQgb24gdGhlIEFlc3RoZXRpYy5cclxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2F0dHIgPSBhdHRyO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2xvciB0byBmaWxsIHRoZSBBZXN0aGV0aWMgZWxlbWVudChSR0JBKS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyWzRdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0cm9rZSBjb2xvciB2YWx1ZXMoUkdCQSkuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcls0XX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gc3Ryb2tlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzaXplIG9mIHRoZSBBZXN0aGV0aWMgcG9pbnQgdG8gYmUgZHJhd24gKFVzZWQgb25seSBpbiBtYXBzIHRoYXQgcmVxdWlyZSBkb3RzIHRvIGJlIGRyYXduKS5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wb2ludFNpemUgPSBwb2ludHNpemUgPT0gbnVsbCA/IDEuMCA6IHBhcnNlRmxvYXQocG9pbnRzaXplKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcmFuZ2UgZm9yIHRoaXMgcGFydGljdWxhciBBZXN0aGV0aWMgZWxlbWVudC5cclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyWzJdfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIEFycmF5IHdpbGwga2VlcCB0cmFjayBvZiBhbGwgRmVhdHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQWVzdGhldGljIG9iamVjdC5cclxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RmVhdHVyZT59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGlzIEFycmF5IGlzIHVzZWQgZm9yPyBcclxuICAgICAgICAgKiBAdG9kb1xyXG4gICAgICAgICAqIEB0eXBlIHtBcnJheTxGZWF0dXJlPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBwYXJ0aWN1bGFyIGVsZW1lbnQgd2lsbCBiZSBhY3RpdmUgb3Igbm90IGluIHRoZSBMZWdlbmQuXHJcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTsvL0VsZW1lbnRvIGRhIGxlZ2VuZGEgYXRpdmFkbyBvdSBkZXNhdGl2YWRvXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT3V0ZXIgb2Y/IFRoaXMgaXMgdXNlZCBmb3Igd2hhdD9cclxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vQFRPRE8gcmVtb3ZlIHRoaXNcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgZmVhdHVyZSB0byB0aGlzIEFlc3RoZXRpYyBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgRmVhdHVyZSBpZC4gRWFjaCBmZWF0dXJlIHdpbGwgaGF2ZSBhIGRpZmZlcmVudCBpZCBpbnNpZGUgdGhpcyBBZXN0aGV0aWMgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIHt7Zng6IHN0cmluZywgX2dpc3BsYXlpZDpudW1iZXJ9fSBwcm9wZXJ0aWVzIC0gUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gdHJpYW5nbGVzIC0gTnVtYmVyIG9mIHRyaWFuZ2xlcyBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIE51bWJlciBvZiBib3JkZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZS5cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHBvaW50cyAtIFRoZSBwb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhlIEZlYXR1cmUuXHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGlzIEFlc3RoZXRpYyBhdHRyaWJ1dGUuXHJcbiAgICAgKiBAcmV0dXJucyB7QWVzdGhldGljLl9hdHRyfSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBhdHRyIG9mIHRoaXMgQWVzdGhldGljLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgQWVzdGhldGljXHJcbiAgICAgKi9cclxuICAgIGdldEF0dHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHI7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZmllcyB0aGUgZXhpc3RlbmNlIG9yIG5vdCBvZiB0aGUgcHJvcGVydHkgQWVzdGhldGhpYy5fYXR0ciBhbmQgaWYgaXQgaW5zaWRlIHRoZSByYW5nZS5cclxuICAgICAqIFZlcmlmaWNhIHNlIGVzdMOhIGRlbnRybyBvdSBuYW8gZG8gcmFuZ2UgXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSBUaGUgYXR0cmlidXRlICBcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlcmUncyBubyByYW5nZSBvciA/XHJcbiAgICAgKiBcclxuICAgICAqIEBtZW1iZXJPZiBBZXN0aGV0aWNcclxuICAgICAqL1xyXG4gICAgY2hlY2tQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmdlID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCh0aGlzLnJhbmdlWzBdID09IG51bGwgfHwgdmFsdWUgPj0gdGhpcy5yYW5nZVswXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5yYW5nZVsxXSA9PSBudWxsIHx8ICh2YWx1ZSA8IHRoaXMucmFuZ2VbMV0gfHwgKHZhbHVlIDw9IHRoaXMucmFuZ2VbMV0gJiYgdGhpcy5vdXRlciA9PSB0cnVlKSkpKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSA9PSB0aGlzLnJhbmdlWzBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgXHJcbiAgICBhZGRHcm91cGVkRmVhdHVyZShpZCwgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWxsRmVhdHVyZXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gMDsgLy9UT0RPXHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxsRmVhdHVyZXNbMF0uX3Byb3BlcnRpZXMucHVzaChwcm9wZXJ0aWVzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWxsRmVhdHVyZXNbY3Vyc29yXS5wdXNoKG5ldyBGZWF0dXJlKGlkLCBudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgICAgICAgICAvL3RoaXMuX2FsbEZlYXR1cmVzW2N1cnNvcl0uX3RyaWFuZ2xlcy5jb25jYXQodHJpYW5nbGVzKTtcclxuICAgICAgICAgICAgLy90aGlzLl9hbGxGZWF0dXJlc1tjdXJzb3JdLl9ib3JkZXJzLmNvbmNhdChib3JkZXJzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgZW5hYmxlRGlzYWJsZSgpIHtcclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSAhdGhpcy5lbmFibGVkO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuYWJsZWQ7XHJcbiAgICB9XHJcbn1cclxuXHJcbiAvKnZhciBvYmogPSB7XHJcbiAgICAgICAgICAgIGk6IGlkLFxyXG4gICAgICAgICAgICBhOiBhdHRyLFxyXG4gICAgICAgICAgICBmOiBmY29sb3IsXHJcbiAgICAgICAgICAgIHM6IHN0cm9rZSxcclxuICAgICAgICAgICAgcDogcG9pbnRzaXplLFxyXG4gICAgICAgICAgICByOiByYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zb2xlLndhcm4oXCJBZXN0IGNhbGxlZCBjb25zdHJ1Y3RvciEhISA9PSBcIiArIEpTT04uc3RyaW5naWZ5KG9iaikpOyovXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L0Flc3RoZXRpYy5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7O0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQWdCQTtBQUFBO0FBQ0E7QUFBQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUdBO0FBS0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7Ozs7Ozs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/Maps/Choropleth.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    function Choropleth(bgmap, geometry, options) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, options));\n\n        _this.aesthetics = new Array();\n        _this.geometry = geometry;\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.type = 'CP';\n        maps.push(_this);\n        _this.initialize();\n        /*return this;*/\n        return _this;\n    }\n\n    //@override\n\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            //console.log(\"Choropleth drawaaa() called\");\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawTriangles(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            //console.log(\"Choropleth buildLegend() called\");\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPolygonRow(this.aesthetics[a], this);\n            }\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            //console.log(\"Choropleth defaults() called\");\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanM/ZjhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXAgfSBmcm9tICcuL01hcCc7XHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9wbGV0aCBpbXBsZW1lbnRhdGlvbiAwNi8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENob3JvcGxldGggZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSBtYXBjb3VudCsrO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDUCc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIC8qcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICAvL0BvdmVycmlkZVxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBkcmF3YWFhKCkgY2FsbGVkXCIpO1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3VHJpYW5nbGVzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBidWlsZExlZ2VuZCgpIGNhbGxlZFwiKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhIGluIHRoaXMuYWVzdGhldGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2x5Z29uUm93KHRoaXMuYWVzdGhldGljc1thXSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNob3JvcGxldGggZGVmYXVsdHMoKSBjYWxsZWRcIik7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3doaXRlJywgJ3llbGxvdycsICdvcmFuZ2UnLCAncmVkJ107XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm51bWJlck9mQ2xhc3NlcyA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7Ozs7O0FBQ0E7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Choropleth */ 3);\n\nvar _DotMap = __webpack_require__(/*! ./Maps/DotMap */ 9);\n\nvar _ChangeMap = __webpack_require__(/*! ./Maps/ChangeMap */ 7);\n\nvar _ProportionalSymbolsMap = __webpack_require__(/*! ./Maps/ProportionalSymbolsMap */ 10);\n\nvar _ChorochromaticMap = __webpack_require__(/*! ./Maps/ChorochromaticMap */ 8);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API entry point with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n\n    /**\r\n     * Creates an instance of the Gisplay API.\r\n     * \r\n     * @memberOf Gisplay\r\n     */\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        console.log(\"Gisplay Class constructor\");\n        /**\r\n         * TimeStamp at the beginning.\r\n         * @type {number} \r\n         */\n        this.startTimeStamp = 0;\n\n        /**\r\n         * Whether or not it  should profile the API.\r\n         * @type {string} - Whether or not it  should profile the API.\r\n         */\n        window.profiling = true;\n        /**\r\n         * @type {Array} - Array of maps. @WHY?\r\n         */\n        window.maps = new Array();\n        /**\r\n         * @type {number} - The number of maps. @WHY?\r\n         */\n        window.mapcount = 0;\n\n        //WebGL API\n        /**\r\n        * @type {number} - The number of vertices produced. @WHY?\r\n        */\n        window._vertexcount = 0;\n        /**\r\n        * @type {number} - The number of ???. @WHY?\r\n        */\n        window._tricount = 0;\n    }\n\n    /**\r\n     * Creates a map of type Choropleth.\r\n     * @param {Object} bgmap - Background map object be used(atm only MapBox being used).- Background map object be used(atm only MapBox being used).\r\n     * @param {JSON} geometry - The geometry was read from the file.\r\n     * @param {Object} options - User personalization options.\r\n     * \r\n     * @memberOf Gisplay\r\n     */\n\n\n    _createClass(Gisplay, [{\n        key: 'makeChoropleth',\n        value: function makeChoropleth(bgmap, geometry, options) {\n            console.log(bgmap);\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Dot Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The geometry was read from the file.\r\n         * @param {Object} options - User personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeDotMap',\n        value: function makeDotMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _DotMap.DotMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Change Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The geometry was read from the file.\r\n         * @param {Object} options - User personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChangeMap',\n        value: function makeChangeMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChangeMap.ChangeMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n\n        /**\r\n         * Creates a Proportional Symbols Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The geometry was read from the file.\r\n         * @param {Object} options - User personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeProportionalSymbolsMap',\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ProportionalSymbolsMap.ProportionalSymbolsMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui add options (n tinha WUT)\n        }\n\n        /**\r\n         * Creates a Chorocromatic Map.\r\n         * @param {Object} bgmap - Background map object be used(atm only MapBox being used).\r\n         * @param {JSON} geometry - The geometry was read from the file.\r\n         * @param {Object} options - User personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeChorochromaticMap',\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            if (window.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChorochromaticMap.ChorochromaticMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui .defaultid);\n        }\n\n        /**\r\n         * Starts the construction of the map.\r\n         * @todo Should clean up this removing profiling code?\r\n         * @param {Map} gismap - The Gisplay Map to use (Choropleth, DotMap,etc).\r\n         * @param {Object} options - User personalization options.\r\n         * \r\n         * @memberOf Gisplay\r\n         */\n\n    }, {\n        key: 'makeMap',\n        value: function makeMap(gismap, options) {\n            var _this = this;\n\n            var defaultid = options.defaultid != null ? defaultid : 1;\n            setTimeout(function (console) {\n                var start = 0;\n                if (window.profiling == true) start = Date.now();\n                if (gismap.colorscheme == undefined) gismap.colorscheme = gismap.defaults(defaultid).colorScheme;\n                if (gismap.classbreaks == undefined) {\n                    if (gismap.numberofclasses == undefined) {\n                        gismap.numberofclasses = gismap.defaults(defaultid).numberOfClasses;\n                    }\n                    gismap.preProcessData(gismap.geometry, gismap.numberofclasses, gismap.algorithm, gismap.colorscheme);\n                }\n\n                //gismap.processData(gismap.geometry);\n                gismap.loadGeoJSON(gismap.geometry);\n                var start2 = 0;\n                if (window.profiling == true) {\n                    start2 = Date.now();\n                    window.console.log('Tempo de processamento do dados (segundos): ' + (start2 - start) / 1000);\n                }\n                gismap.draw();\n\n                var end = 0;\n                if (window.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo de desenho do mapa (segundos): ' + (end - start2) / 1000);\n                }\n                if (options.legend != false) gismap.buildLegend();\n                if (options.loader != false) {\n                    gismap.loader();\n                }\n                if (window.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo total (segundos): ' + (end - _this.startTimeStamp) / 1000);\n                }\n            }, 1);\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5LmpzPzA1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vTWFwcy9DaG9yb3BsZXRoJztcclxuaW1wb3J0IHsgRG90TWFwIH0gZnJvbSAnLi9NYXBzL0RvdE1hcCc7XHJcbmltcG9ydCB7IENoYW5nZU1hcCB9IGZyb20gJy4vTWFwcy9DaGFuZ2VNYXAnO1xyXG5pbXBvcnQgeyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIH0gZnJvbSAnLi9NYXBzL1Byb3BvcnRpb25hbFN5bWJvbHNNYXAnXHJcbmltcG9ydCB7IENob3JvY2hyb21hdGljTWFwIH0gZnJvbSAnLi9NYXBzL0Nob3JvY2hyb21hdGljTWFwJztcclxuXHJcbi8qKlxyXG4gKiBHaXNwbGF5IEFQSSBlbnRyeSBwb2ludCB3aXRoIG9uZSBtZXRob2QgZm9yIGVhY2ggbWFwIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHaXNwbGF5IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgdGhlIEdpc3BsYXkgQVBJLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkdpc3BsYXkgQ2xhc3MgY29uc3RydWN0b3JcIik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGltZVN0YW1wIGF0IHRoZSBiZWdpbm5pbmcuXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn0gXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IDA7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IGl0ICBzaG91bGQgcHJvZmlsZSB0aGUgQVBJLlxyXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd9IC0gV2hldGhlciBvciBub3QgaXQgIHNob3VsZCBwcm9maWxlIHRoZSBBUEkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2luZG93LnByb2ZpbGluZyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHR5cGUge0FycmF5fSAtIEFycmF5IG9mIG1hcHMuIEBXSFk/XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgd2luZG93Lm1hcHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgbWFwcy4gQFdIWT9cclxuICAgICAgICAgKi9cclxuICAgICAgICB3aW5kb3cubWFwY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvL1dlYkdMIEFQSVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICogQHR5cGUge251bWJlcn0gLSBUaGUgbnVtYmVyIG9mIHZlcnRpY2VzIHByb2R1Y2VkLiBAV0hZP1xyXG4gICAgICAgICovXHJcbiAgICAgICAgd2luZG93Ll92ZXJ0ZXhjb3VudCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgKiBAdHlwZSB7bnVtYmVyfSAtIFRoZSBudW1iZXIgb2YgPz8/LiBAV0hZP1xyXG4gICAgICAgICovXHJcbiAgICAgICAgd2luZG93Ll90cmljb3VudCA9IDA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbWFwIG9mIHR5cGUgQ2hvcm9wbGV0aC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS4tIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNob3JvcGxldGgoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYmdtYXApO1xyXG4gICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaG9yb3BsZXRoKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgRG90IE1hcC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZURvdE1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgRG90TWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgQ2hhbmdlIE1hcC5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBiZ21hcCAtIEJhY2tncm91bmQgbWFwIG9iamVjdCBiZSB1c2VkKGF0bSBvbmx5IE1hcEJveCBiZWluZyB1c2VkKS5cclxuICAgICAqIEBwYXJhbSB7SlNPTn0gZ2VvbWV0cnkgLSBUaGUgZ2VvbWV0cnkgd2FzIHJlYWQgZnJvbSB0aGUgZmlsZS5cclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVXNlciBwZXJzb25hbGl6YXRpb24gb3B0aW9ucy5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEdpc3BsYXlcclxuICAgICAqL1xyXG4gICAgbWFrZUNoYW5nZU1hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hhbmdlTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgUHJvcG9ydGlvbmFsIFN5bWJvbHMgTWFwLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBnZW9tZXRyeSB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBVc2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlUHJvcG9ydGlvbmFsU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgUHJvcG9ydGlvbmFsU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWFrZU1hcChnaXNtYXAsIG9wdGlvbnMpOyAvL0BSdWkgYWRkIG9wdGlvbnMgKG4gdGluaGEgV1VUKVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIENob3JvY3JvbWF0aWMgTWFwLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGJnbWFwIC0gQmFja2dyb3VuZCBtYXAgb2JqZWN0IGJlIHVzZWQoYXRtIG9ubHkgTWFwQm94IGJlaW5nIHVzZWQpLlxyXG4gICAgICogQHBhcmFtIHtKU09OfSBnZW9tZXRyeSAtIFRoZSBnZW9tZXRyeSB3YXMgcmVhZCBmcm9tIHRoZSBmaWxlLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBVc2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlQ2hvcm9jaHJvbWF0aWNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IENob3JvY2hyb21hdGljTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7Ly9AUnVpIC5kZWZhdWx0aWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSBjb25zdHJ1Y3Rpb24gb2YgdGhlIG1hcC5cclxuICAgICAqIEB0b2RvIFNob3VsZCBjbGVhbiB1cCB0aGlzIHJlbW92aW5nIHByb2ZpbGluZyBjb2RlP1xyXG4gICAgICogQHBhcmFtIHtNYXB9IGdpc21hcCAtIFRoZSBHaXNwbGF5IE1hcCB0byB1c2UgKENob3JvcGxldGgsIERvdE1hcCxldGMpLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBVc2VyIHBlcnNvbmFsaXphdGlvbiBvcHRpb25zLlxyXG4gICAgICogXHJcbiAgICAgKiBAbWVtYmVyT2YgR2lzcGxheVxyXG4gICAgICovXHJcbiAgICBtYWtlTWFwKGdpc21hcCwgb3B0aW9ucykge1xyXG4gICAgICAgIGxldCBkZWZhdWx0aWQgPSBvcHRpb25zLmRlZmF1bHRpZCAhPSBudWxsID8gZGVmYXVsdGlkIDogMTtcclxuICAgICAgICBzZXRUaW1lb3V0KGNvbnNvbGUgPT4ge1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQgPSAwO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAoZ2lzbWFwLmNvbG9yc2NoZW1lID09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgIGdpc21hcC5jb2xvcnNjaGVtZSA9IGdpc21hcC5kZWZhdWx0cyhkZWZhdWx0aWQpLmNvbG9yU2NoZW1lO1xyXG4gICAgICAgICAgICBpZiAoZ2lzbWFwLmNsYXNzYnJlYWtzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdpc21hcC5udW1iZXJvZmNsYXNzZXMgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2lzbWFwLm51bWJlcm9mY2xhc3NlcyA9IGdpc21hcC5kZWZhdWx0cyhkZWZhdWx0aWQpLm51bWJlck9mQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGdpc21hcC5wcmVQcm9jZXNzRGF0YShnaXNtYXAuZ2VvbWV0cnksIGdpc21hcC5udW1iZXJvZmNsYXNzZXMsIGdpc21hcC5hbGdvcml0aG0sIGdpc21hcC5jb2xvcnNjaGVtZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vZ2lzbWFwLnByb2Nlc3NEYXRhKGdpc21hcC5nZW9tZXRyeSk7XHJcbiAgICAgICAgICAgIGdpc21hcC5sb2FkR2VvSlNPTihnaXNtYXAuZ2VvbWV0cnkpO1xyXG4gICAgICAgICAgICBsZXQgc3RhcnQyID0gMDtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQyID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkbyBkYWRvcyAoc2VndW5kb3MpOiAkeyhzdGFydDIgLSBzdGFydCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdpc21hcC5kcmF3KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZW5kID0gMDtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgZGVzZW5obyBkbyBtYXBhIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0MikgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmxlZ2VuZCAhPSBmYWxzZSlcclxuICAgICAgICAgICAgICAgIGdpc21hcC5idWlsZExlZ2VuZCgpO1xyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2FkZXIgIT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGdpc21hcC5sb2FkZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyB0b3RhbCAoc2VndW5kb3MpOiAkeyhlbmQgLSB0aGlzLnN0YXJ0VGltZVN0YW1wKSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCAxKTtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9HaXNwbGF5LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7O0FBR0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQVFBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Feature.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n\n/**\r\n * This class represents a Feature. Each feature belongs to one Aesthetic element.\r\n * \r\n * @export\r\n * @class Feature\r\n */\nvar Feature =\n/**\r\n * Creates an instance of Feature.\r\n * @example 1-> {\"id\":0,\"properties\":{\"f1\":\"Alabama\",\"f2\":\"Autauga\",\"f3\":150,\"_gisplayid\":0},\r\n                 \"triangles\":[{\"itemSize\":2,\"numItems\":417}],\"borders\":[{\"itemSize\":2,\"numItems\":141}],\"points\":[]}\r\n * @param {number} id - This Feature id.\r\n * @param {{fx: string, _gisplayid:number}} properties - Properties associated with this Feature.  \r\n * @param {{itemSize: number, numItems: number}} triangles - Number of triangles associated with this Feature. \r\n * @param {{itemSize: number, numItems: number}} borders - Number of borders associated with this Feature.\r\n * @param {number[]} points - The points that belong to this Feature.\r\n * \r\n * @memberOf Feature\r\n */\nexports.Feature = function Feature(id, properties, triangles, borders, points) {\n  _classCallCheck(this, Feature);\n\n  /**\r\n   * This Feature id.\r\n   * @type {number} \r\n   */\n  this._id = id;\n  /**\r\n   * Properties associated with this Feature.  \r\n   * @type {{fx: string, _gisplayid:number}}  \r\n   */\n  this._properties = properties;\n  /**\r\n   * Number of triangles associated with this Feature.\r\n   * @type {{itemSize: number, numItems: number}}\r\n   */\n  this._triangles = triangles;\n  /**\r\n   * Number of borders associated with this Feature.\r\n   * @type {{itemSize: number, numItems: number}}\r\n   */\n  this._borders = borders;\n  /**\r\n   * The points that belong to this Feature.\r\n   * @type {number[]}\r\n   */\n  this._points = points;\n  return this; // @Rui Remover this\n};\n/* if (window.count == 0) {\r\n           var obj = {\r\n               i: id,\r\n               prs: properties,\r\n               ts: triangles,\r\n               bs: borders,\r\n               pts: points,\r\n           }\r\n           window.count++;\r\n           console.log(JSON.stringify(obj))\r\n       }*///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9GZWF0dXJlLmpzP2ZiNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbnRlcm1lZGlhdGUgQVBJXHJcblxyXG4vKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgRmVhdHVyZS4gRWFjaCBmZWF0dXJlIGJlbG9uZ3MgdG8gb25lIEFlc3RoZXRpYyBlbGVtZW50LlxyXG4gKiBcclxuICogQGV4cG9ydFxyXG4gKiBAY2xhc3MgRmVhdHVyZVxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIEZlYXR1cmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIEZlYXR1cmUuXHJcbiAgICAgKiBAZXhhbXBsZSAxLT4ge1wiaWRcIjowLFwicHJvcGVydGllc1wiOntcImYxXCI6XCJBbGFiYW1hXCIsXCJmMlwiOlwiQXV0YXVnYVwiLFwiZjNcIjoxNTAsXCJfZ2lzcGxheWlkXCI6MH0sXHJcbiAgICAgICAgICAgICAgICAgICAgIFwidHJpYW5nbGVzXCI6W3tcIml0ZW1TaXplXCI6MixcIm51bUl0ZW1zXCI6NDE3fV0sXCJib3JkZXJzXCI6W3tcIml0ZW1TaXplXCI6MixcIm51bUl0ZW1zXCI6MTQxfV0sXCJwb2ludHNcIjpbXX1cclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoaXMgRmVhdHVyZSBpZC5cclxuICAgICAqIEBwYXJhbSB7e2Z4OiBzdHJpbmcsIF9naXNwbGF5aWQ6bnVtYmVyfX0gcHJvcGVydGllcyAtIFByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS4gIFxyXG4gICAgICogQHBhcmFtIHt7aXRlbVNpemU6IG51bWJlciwgbnVtSXRlbXM6IG51bWJlcn19IHRyaWFuZ2xlcyAtIE51bWJlciBvZiB0cmlhbmdsZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS4gXHJcbiAgICAgKiBAcGFyYW0ge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX0gYm9yZGVycyAtIE51bWJlciBvZiBib3JkZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHMgLSBUaGUgcG9pbnRzIHRoYXQgYmVsb25nIHRvIHRoaXMgRmVhdHVyZS5cclxuICAgICAqIFxyXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaWQsIHByb3BlcnRpZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhpcyBGZWF0dXJlIGlkLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUHJvcGVydGllcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBGZWF0dXJlLiAgXHJcbiAgICAgICAgICogQHR5cGUge3tmeDogc3RyaW5nLCBfZ2lzcGxheWlkOm51bWJlcn19ICBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gcHJvcGVydGllcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgdHJpYW5nbGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEZlYXR1cmUuXHJcbiAgICAgICAgICogQHR5cGUge3tpdGVtU2l6ZTogbnVtYmVyLCBudW1JdGVtczogbnVtYmVyfX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl90cmlhbmdsZXMgPSB0cmlhbmdsZXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIGJvcmRlcnMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmVhdHVyZS5cclxuICAgICAgICAgKiBAdHlwZSB7e2l0ZW1TaXplOiBudW1iZXIsIG51bUl0ZW1zOiBudW1iZXJ9fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2JvcmRlcnMgPSBib3JkZXJzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBwb2ludHMgdGhhdCBiZWxvbmcgdG8gdGhpcyBGZWF0dXJlLlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJbXX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7Ly8gQFJ1aSBSZW1vdmVyIHRoaXNcclxuICAgIH1cclxufVxyXG4gLyogaWYgKHdpbmRvdy5jb3VudCA9PSAwKSB7XHJcbiAgICAgICAgICAgIHZhciBvYmogPSB7XHJcbiAgICAgICAgICAgICAgICBpOiBpZCxcclxuICAgICAgICAgICAgICAgIHByczogcHJvcGVydGllcyxcclxuICAgICAgICAgICAgICAgIHRzOiB0cmlhbmdsZXMsXHJcbiAgICAgICAgICAgICAgICBiczogYm9yZGVycyxcclxuICAgICAgICAgICAgICAgIHB0czogcG9pbnRzLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHdpbmRvdy5jb3VudCsrO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvYmopKVxyXG4gICAgICAgIH0qL1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9GZWF0dXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTs7Ozs7Ozs7Ozs7O0FBREE7QUFhQTtBQUNBO0FBQUE7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTs7OztBQUlBO0FBQ0E7Ozs7QUFJQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7Ozs7Ozs7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n    function BGMapWrapper(map) {\n        _classCallCheck(this, BGMapWrapper);\n\n        console.log(\"BGMapWrapper constructor?\");\n        this.map = map;\n        /*return this;*/\n    }\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.map.getContainer();\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.map.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //mapCanvas.style.zIndex = \"2\";\n\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.map.getZoom();\n        }\n    }, {\n        key: 'getLngBound',\n        value: function getLngBound() {\n            return this.map.getBounds().getNorthWest().lng;\n        }\n    }, {\n        key: 'getLatBound',\n        value: function getLatBound() {\n            return this.map.getBounds().getNorthWest().lat;\n        }\n    }, {\n        key: 'onEvent',\n        value: function onEvent(eventstr, eventfunction) {\n            this.map.on(eventstr, eventfunction);\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            if (this.loaderDiv === undefined) this.createLoader(this.map);else {\n                if (this.loaderDiv.style.display == 'none') this.loaderDiv.style.display = 'flex';else {\n                    this.loaderDiv.style.display = 'none';\n                }\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');\n                } else {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n                }\n            }\n        }\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n\n            /*outerDiv.style = ' opacity: 0.5; background-color: grey; justify-content: center; display: flex;';\r\n            outerDiv.style.position = 'absolute';\r\n            outerDiv.style.zIndex = '999999999';*/\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            this.loaderDiv = outerDiv;\n\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcz9lMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5leHBvcnQgY2xhc3MgQkdNYXBXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQkdNYXBXcmFwcGVyIGNvbnN0cnVjdG9yP1wiKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICAvKnJldHVybiB0aGlzOyovXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRDb250YWluZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVDYW52YXMoaWQpIHtcclxuICAgICAgICBjb25zdCBtYXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBtYXBDYW52YXMuaWQgPSBgbWFwQ2FudmFzJHtpZH1gO1xyXG4gICAgICAgIG1hcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMubWFwLmdldENvbnRhaW5lcigpO1xyXG4gICAgICAgIG1hcENhbnZhcy5oZWlnaHQgPSBtYXBEaXYub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIG1hcENhbnZhcy53aWR0aCA9IG1hcERpdi5vZmZzZXRXaWR0aDtcclxuICAgICAgICAvL21hcENhbnZhcy5zdHlsZS56SW5kZXggPSBcIjJcIjtcclxuXHJcbiAgICAgICAgLy9jYXNlIG1hcGJveFxyXG4gICAgICAgIG1hcERpdi5pbnNlcnRCZWZvcmUobWFwQ2FudmFzLCBtYXBEaXYuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApO1xyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldExuZ0JvdW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRCb3VuZHMoKS5nZXROb3J0aFdlc3QoKS5sbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TGF0Qm91bmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxhdDtcclxuICAgIH1cclxuXHJcbiAgICBvbkV2ZW50KGV2ZW50c3RyLCBldmVudGZ1bmN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5tYXAub24oZXZlbnRzdHIsIGV2ZW50ZnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVMb2FkZXIodGhpcy5tYXApO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYuc3R5bGUuZGlzcGxheSA9PSAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUuaW5jbHVkZXMoJ19naXNwbGF5aGlkZGVuJykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZSA9IHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheWhpZGRlbig/IVxcUykvZywgJ19naXNwbGF5TG9hZGVyT3V0ZXJEaXYnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZSA9IHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheUxvYWRlck91dGVyRGl2KD8hXFxTKS9nLCAnX2dpc3BsYXloaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVMb2FkZXIoKSB7XHJcbiAgICAgICAgY29uc3Qgb3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb25zdCBpbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGlubmVyRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWxvYWRlcic7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcblxyXG4gICAgICAgIC8qb3V0ZXJEaXYuc3R5bGUgPSAnIG9wYWNpdHk6IDAuNTsgYmFja2dyb3VuZC1jb2xvcjogZ3JleTsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IGRpc3BsYXk6IGZsZXg7JztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUuekluZGV4ID0gJzk5OTk5OTk5OSc7Ki9cclxuICAgICAgICBvdXRlckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlMb2FkZXJPdXRlckRpdic7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUuaGVpZ2h0ID0gbWFwRGl2Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS53aWR0aCA9IG1hcERpdi5vZmZzZXRXaWR0aDtcclxuICAgICAgICBvdXRlckRpdi5hcHBlbmRDaGlsZChpbm5lckRpdik7XHJcbiAgICAgICAgdGhpcy5sb2FkZXJEaXYgPSBvdXRlckRpdjtcclxuXHJcbiAgICAgICAgbWFwRGl2LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG91dGVyRGl2LCBtYXBEaXYpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/Gisplay/Maps/ChangeMap.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChangeMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * ChangeMap implementation 07/03\r\n */\nvar ChangeMap = exports.ChangeMap = function (_Map) {\n    _inherits(ChangeMap, _Map);\n\n    function ChangeMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChangeMap);\n\n        var _this = _possibleConstructorReturn(this, (ChangeMap.__proto__ || Object.getPrototypeOf(ChangeMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.attr = \"change\";\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.attr = \"change\"; //@Rui Duplicate?\n        _this.type = 'CM';\n        maps.push(_this);\n        _this.initialize();\n\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(ChangeMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawContinuousPolygons(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n            var aesarray = [];\n            var values = [];\n            var breaks = void 0;\n            //var fcolor;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (typeof geojson.features[g].properties[this.minuend] == 'number' && geojson.features[g].properties[this.minuend] != null && typeof geojson.features[g].properties[this.subtrahend] == 'number' && geojson.features[g].properties[this.subtrahend] != null) {\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                }\n            }\n            breaks = [this.min, this.max];\n            this.fcolor = chroma.scale(colorscheme);\n            var aes = new _Aesthetic.Aesthetic(0, this.attr, this.fcolor, [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n            aes.outer = true;\n            aesarray.push(aes);\n\n            this.aesthetics = aesarray;\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            this.legend.insertGradient(this, this.min, 0, this.max);\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults() {\n            var options = {};\n            return options;\n        }\n    }]);\n\n    return ChangeMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0NoYW5nZU1hcC5qcz9lMTQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcCB9IGZyb20gJy4vTWFwJztcclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2VNYXAgaW1wbGVtZW50YXRpb24gMDcvMDNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaGFuZ2VNYXAgZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IFwiY2hhbmdlXCI7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy5hdHRyID0gXCJjaGFuZ2VcIjsvL0BSdWkgRHVwbGljYXRlP1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDTSc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICAvKiAgcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29udGludW91c1BvbHlnb25zKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcmVQcm9jZXNzRGF0YShnZW9qc29uLCBudW1iZXJPZiwgYWxnb3JpdGhtLCBjb2xvcnNjaGVtZSkge1xyXG4gICAgICAgIGNvbnN0IGFlc2FycmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgbGV0IGJyZWFrcztcclxuICAgICAgICAvL3ZhciBmY29sb3I7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAhPSBudWxsICYmIHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAtIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLm1pbnVlbmRdIC0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrcyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xyXG4gICAgICAgIHRoaXMuZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKTtcclxuICAgICAgICBjb25zdCBhZXMgPSBuZXcgQWVzdGhldGljKDAsIHRoaXMuYXR0ciwgdGhpcy5mY29sb3IsIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1swXSwgYnJlYWtzWzFdXSk7XHJcbiAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRHcmFkaWVudCh0aGlzLCB0aGlzLm1pbiwgMCwgdGhpcy5tYXgpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQ2hhbmdlTWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFhQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./src/Gisplay/Maps/ChorochromaticMap.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChorochromaticMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Choropleth2 = __webpack_require__(/*! ./Choropleth */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*import { Map } from './Map';*/\n\n\n/**\r\n * Chorochormatic Map implemenetation.\r\n */\nvar ChorochromaticMap = exports.ChorochromaticMap = function (_Choropleth) {\n    _inherits(ChorochromaticMap, _Choropleth);\n\n    function ChorochromaticMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChorochromaticMap);\n\n        return _possibleConstructorReturn(this, (ChorochromaticMap.__proto__ || Object.getPrototypeOf(ChorochromaticMap)).call(this, bgmap, geometry, options));\n    }\n\n    _createClass(ChorochromaticMap, [{\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ChorochromaticMap;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvY2hyb21hdGljTWFwLmpzPzQ0ZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLyppbXBvcnQgeyBNYXAgfSBmcm9tICcuL01hcCc7Ki9cclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vQ2hvcm9wbGV0aCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9jaG9ybWF0aWMgTWFwIGltcGxlbWVuZXRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaG9yb2Nocm9tYXRpY01hcCBleHRlbmRzIENob3JvcGxldGgge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbXCIjNDQwMTU0XCIsIFwiIzQ0MDI1NlwiLCBcIiM0NTA0NTdcIiwgXCIjNDUwNTU5XCIsIFwiIzQ2MDc1YVwiLCBcIiM0NjA4NWNcIiwgXCIjNDYwYTVkXCIsIFwiIzQ2MGI1ZVwiLCBcIiM0NzBkNjBcIiwgXCIjNDcwZTYxXCIsIFwiIzQ3MTA2M1wiLCBcIiM0NzExNjRcIiwgXCIjNDcxMzY1XCIsIFwiIzQ4MTQ2N1wiLCBcIiM0ODE2NjhcIiwgXCIjNDgxNzY5XCIsIFwiIzQ4MTg2YVwiLCBcIiM0ODFhNmNcIiwgXCIjNDgxYjZkXCIsIFwiIzQ4MWM2ZVwiLCBcIiM0ODFkNmZcIiwgXCIjNDgxZjcwXCIsIFwiIzQ4MjA3MVwiLCBcIiM0ODIxNzNcIiwgXCIjNDgyMzc0XCIsIFwiIzQ4MjQ3NVwiLCBcIiM0ODI1NzZcIiwgXCIjNDgyNjc3XCIsIFwiIzQ4Mjg3OFwiLCBcIiM0ODI5NzlcIiwgXCIjNDcyYTdhXCIsIFwiIzQ3MmM3YVwiLCBcIiM0NzJkN2JcIiwgXCIjNDcyZTdjXCIsIFwiIzQ3MmY3ZFwiLCBcIiM0NjMwN2VcIiwgXCIjNDYzMjdlXCIsIFwiIzQ2MzM3ZlwiLCBcIiM0NjM0ODBcIiwgXCIjNDUzNTgxXCIsIFwiIzQ1Mzc4MVwiLCBcIiM0NTM4ODJcIiwgXCIjNDQzOTgzXCIsIFwiIzQ0M2E4M1wiLCBcIiM0NDNiODRcIiwgXCIjNDMzZDg0XCIsIFwiIzQzM2U4NVwiLCBcIiM0MjNmODVcIiwgXCIjNDI0MDg2XCIsIFwiIzQyNDE4NlwiLCBcIiM0MTQyODdcIiwgXCIjNDE0NDg3XCIsIFwiIzQwNDU4OFwiLCBcIiM0MDQ2ODhcIiwgXCIjM2Y0Nzg4XCIsIFwiIzNmNDg4OVwiLCBcIiMzZTQ5ODlcIiwgXCIjM2U0YTg5XCIsIFwiIzNlNGM4YVwiLCBcIiMzZDRkOGFcIiwgXCIjM2Q0ZThhXCIsIFwiIzNjNGY4YVwiLCBcIiMzYzUwOGJcIiwgXCIjM2I1MThiXCIsIFwiIzNiNTI4YlwiLCBcIiMzYTUzOGJcIiwgXCIjM2E1NDhjXCIsIFwiIzM5NTU4Y1wiLCBcIiMzOTU2OGNcIiwgXCIjMzg1ODhjXCIsIFwiIzM4NTk4Y1wiLCBcIiMzNzVhOGNcIiwgXCIjMzc1YjhkXCIsIFwiIzM2NWM4ZFwiLCBcIiMzNjVkOGRcIiwgXCIjMzU1ZThkXCIsIFwiIzM1NWY4ZFwiLCBcIiMzNDYwOGRcIiwgXCIjMzQ2MThkXCIsIFwiIzMzNjI4ZFwiLCBcIiMzMzYzOGRcIiwgXCIjMzI2NDhlXCIsIFwiIzMyNjU4ZVwiLCBcIiMzMTY2OGVcIiwgXCIjMzE2NzhlXCIsIFwiIzMxNjg4ZVwiLCBcIiMzMDY5OGVcIiwgXCIjMzA2YThlXCIsIFwiIzJmNmI4ZVwiLCBcIiMyZjZjOGVcIiwgXCIjMmU2ZDhlXCIsIFwiIzJlNmU4ZVwiLCBcIiMyZTZmOGVcIiwgXCIjMmQ3MDhlXCIsIFwiIzJkNzE4ZVwiLCBcIiMyYzcxOGVcIiwgXCIjMmM3MjhlXCIsIFwiIzJjNzM4ZVwiLCBcIiMyYjc0OGVcIiwgXCIjMmI3NThlXCIsIFwiIzJhNzY4ZVwiLCBcIiMyYTc3OGVcIiwgXCIjMmE3ODhlXCIsIFwiIzI5Nzk4ZVwiLCBcIiMyOTdhOGVcIiwgXCIjMjk3YjhlXCIsIFwiIzI4N2M4ZVwiLCBcIiMyODdkOGVcIiwgXCIjMjc3ZThlXCIsIFwiIzI3N2Y4ZVwiLCBcIiMyNzgwOGVcIiwgXCIjMjY4MThlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjU4MzhlXCIsIFwiIzI1ODQ4ZVwiLCBcIiMyNTg1OGVcIiwgXCIjMjQ4NjhlXCIsIFwiIzI0ODc4ZVwiLCBcIiMyMzg4OGVcIiwgXCIjMjM4OThlXCIsIFwiIzIzOGE4ZFwiLCBcIiMyMjhiOGRcIiwgXCIjMjI4YzhkXCIsIFwiIzIyOGQ4ZFwiLCBcIiMyMThlOGRcIiwgXCIjMjE4ZjhkXCIsIFwiIzIxOTA4ZFwiLCBcIiMyMTkxOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkzOGNcIiwgXCIjMWY5NDhjXCIsIFwiIzFmOTU4YlwiLCBcIiMxZjk2OGJcIiwgXCIjMWY5NzhiXCIsIFwiIzFmOTg4YlwiLCBcIiMxZjk5OGFcIiwgXCIjMWY5YThhXCIsIFwiIzFlOWI4YVwiLCBcIiMxZTljODlcIiwgXCIjMWU5ZDg5XCIsIFwiIzFmOWU4OVwiLCBcIiMxZjlmODhcIiwgXCIjMWZhMDg4XCIsIFwiIzFmYTE4OFwiLCBcIiMxZmExODdcIiwgXCIjMWZhMjg3XCIsIFwiIzIwYTM4NlwiLCBcIiMyMGE0ODZcIiwgXCIjMjFhNTg1XCIsIFwiIzIxYTY4NVwiLCBcIiMyMmE3ODVcIiwgXCIjMjJhODg0XCIsIFwiIzIzYTk4M1wiLCBcIiMyNGFhODNcIiwgXCIjMjVhYjgyXCIsIFwiIzI1YWM4MlwiLCBcIiMyNmFkODFcIiwgXCIjMjdhZDgxXCIsIFwiIzI4YWU4MFwiLCBcIiMyOWFmN2ZcIiwgXCIjMmFiMDdmXCIsIFwiIzJjYjE3ZVwiLCBcIiMyZGIyN2RcIiwgXCIjMmViMzdjXCIsIFwiIzJmYjQ3Y1wiLCBcIiMzMWI1N2JcIiwgXCIjMzJiNjdhXCIsIFwiIzM0YjY3OVwiLCBcIiMzNWI3NzlcIiwgXCIjMzdiODc4XCIsIFwiIzM4Yjk3N1wiLCBcIiMzYWJhNzZcIiwgXCIjM2JiYjc1XCIsIFwiIzNkYmM3NFwiLCBcIiMzZmJjNzNcIiwgXCIjNDBiZDcyXCIsIFwiIzQyYmU3MVwiLCBcIiM0NGJmNzBcIiwgXCIjNDZjMDZmXCIsIFwiIzQ4YzE2ZVwiLCBcIiM0YWMxNmRcIiwgXCIjNGNjMjZjXCIsIFwiIzRlYzM2YlwiLCBcIiM1MGM0NmFcIiwgXCIjNTJjNTY5XCIsIFwiIzU0YzU2OFwiLCBcIiM1NmM2NjdcIiwgXCIjNThjNzY1XCIsIFwiIzVhYzg2NFwiLCBcIiM1Y2M4NjNcIiwgXCIjNWVjOTYyXCIsIFwiIzYwY2E2MFwiLCBcIiM2M2NiNWZcIiwgXCIjNjVjYjVlXCIsIFwiIzY3Y2M1Y1wiLCBcIiM2OWNkNWJcIiwgXCIjNmNjZDVhXCIsIFwiIzZlY2U1OFwiLCBcIiM3MGNmNTdcIiwgXCIjNzNkMDU2XCIsIFwiIzc1ZDA1NFwiLCBcIiM3N2QxNTNcIiwgXCIjN2FkMTUxXCIsIFwiIzdjZDI1MFwiLCBcIiM3ZmQzNGVcIiwgXCIjODFkMzRkXCIsIFwiIzg0ZDQ0YlwiLCBcIiM4NmQ1NDlcIiwgXCIjODlkNTQ4XCIsIFwiIzhiZDY0NlwiLCBcIiM4ZWQ2NDVcIiwgXCIjOTBkNzQzXCIsIFwiIzkzZDc0MVwiLCBcIiM5NWQ4NDBcIiwgXCIjOThkODNlXCIsIFwiIzliZDkzY1wiLCBcIiM5ZGQ5M2JcIiwgXCIjYTBkYTM5XCIsIFwiI2EyZGEzN1wiLCBcIiNhNWRiMzZcIiwgXCIjYThkYjM0XCIsIFwiI2FhZGMzMlwiLCBcIiNhZGRjMzBcIiwgXCIjYjBkZDJmXCIsIFwiI2IyZGQyZFwiLCBcIiNiNWRlMmJcIiwgXCIjYjhkZTI5XCIsIFwiI2JhZGUyOFwiLCBcIiNiZGRmMjZcIiwgXCIjYzBkZjI1XCIsIFwiI2MyZGYyM1wiLCBcIiNjNWUwMjFcIiwgXCIjYzhlMDIwXCIsIFwiI2NhZTExZlwiLCBcIiNjZGUxMWRcIiwgXCIjZDBlMTFjXCIsIFwiI2QyZTIxYlwiLCBcIiNkNWUyMWFcIiwgXCIjZDhlMjE5XCIsIFwiI2RhZTMxOVwiLCBcIiNkZGUzMThcIiwgXCIjZGZlMzE4XCIsIFwiI2UyZTQxOFwiLCBcIiNlNWU0MTlcIiwgXCIjZTdlNDE5XCIsIFwiI2VhZTUxYVwiLCBcIiNlY2U1MWJcIiwgXCIjZWZlNTFjXCIsIFwiI2YxZTUxZFwiLCBcIiNmNGU2MWVcIiwgXCIjZjZlNjIwXCIsIFwiI2Y4ZTYyMVwiLCBcIiNmYmU3MjNcIiwgXCIjZmRlNzI1XCJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3B1cnBsZScsICdvcmFuZ2UnLCAnYmx1ZScsICd5ZWxsb3cnLCAncGluaycsICdncmVlbicsICdyZWQnLCAnbmF2eSddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL0dpc3BsYXkvTWFwcy9DaG9yb2Nocm9tYXRpY01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBSEE7QUFDQTtBQUNBO0FBRUE7OztBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/Gisplay/Maps/DotMap.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DotMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * DotMap implemenetation\r\n */\nvar DotMap = exports.DotMap = function (_Map) {\n    _inherits(DotMap, _Map);\n\n    function DotMap(bgmap, geometry, options) {\n        _classCallCheck(this, DotMap);\n\n        var _this = _possibleConstructorReturn(this, (DotMap.__proto__ || Object.getPrototypeOf(DotMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.type = 'DM';\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        maps.push(_this);\n        _this.initialize();\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(DotMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPointRow(this.aesthetics[a], this);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid, useroptions) {\n            //@TODO useroptions not used\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    break;\n            }\n            options.numberOfClasses = 1;\n            return options;\n        }\n    }]);\n\n    return DotMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0RvdE1hcC5qcz84OTMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XHJcbmltcG9ydCB7TGVnZW5kfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIERvdE1hcCBpbXBsZW1lbmV0YXRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEb3RNYXAgZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdETSc7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIC8qICByZXR1cm4gdGhpczsqL1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50cyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGEgaW4gdGhpcy5hZXN0aGV0aWNzKVxyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2ludFJvdyh0aGlzLmFlc3RoZXRpY3NbYV0sIHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkLCB1c2Vyb3B0aW9ucykgeyAvL0BUT0RPIHVzZXJvcHRpb25zIG5vdCB1c2VkXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbXCIjNDQwMTU0XCIsIFwiIzQ0MDI1NlwiLCBcIiM0NTA0NTdcIiwgXCIjNDUwNTU5XCIsIFwiIzQ2MDc1YVwiLCBcIiM0NjA4NWNcIiwgXCIjNDYwYTVkXCIsIFwiIzQ2MGI1ZVwiLCBcIiM0NzBkNjBcIiwgXCIjNDcwZTYxXCIsIFwiIzQ3MTA2M1wiLCBcIiM0NzExNjRcIiwgXCIjNDcxMzY1XCIsIFwiIzQ4MTQ2N1wiLCBcIiM0ODE2NjhcIiwgXCIjNDgxNzY5XCIsIFwiIzQ4MTg2YVwiLCBcIiM0ODFhNmNcIiwgXCIjNDgxYjZkXCIsIFwiIzQ4MWM2ZVwiLCBcIiM0ODFkNmZcIiwgXCIjNDgxZjcwXCIsIFwiIzQ4MjA3MVwiLCBcIiM0ODIxNzNcIiwgXCIjNDgyMzc0XCIsIFwiIzQ4MjQ3NVwiLCBcIiM0ODI1NzZcIiwgXCIjNDgyNjc3XCIsIFwiIzQ4Mjg3OFwiLCBcIiM0ODI5NzlcIiwgXCIjNDcyYTdhXCIsIFwiIzQ3MmM3YVwiLCBcIiM0NzJkN2JcIiwgXCIjNDcyZTdjXCIsIFwiIzQ3MmY3ZFwiLCBcIiM0NjMwN2VcIiwgXCIjNDYzMjdlXCIsIFwiIzQ2MzM3ZlwiLCBcIiM0NjM0ODBcIiwgXCIjNDUzNTgxXCIsIFwiIzQ1Mzc4MVwiLCBcIiM0NTM4ODJcIiwgXCIjNDQzOTgzXCIsIFwiIzQ0M2E4M1wiLCBcIiM0NDNiODRcIiwgXCIjNDMzZDg0XCIsIFwiIzQzM2U4NVwiLCBcIiM0MjNmODVcIiwgXCIjNDI0MDg2XCIsIFwiIzQyNDE4NlwiLCBcIiM0MTQyODdcIiwgXCIjNDE0NDg3XCIsIFwiIzQwNDU4OFwiLCBcIiM0MDQ2ODhcIiwgXCIjM2Y0Nzg4XCIsIFwiIzNmNDg4OVwiLCBcIiMzZTQ5ODlcIiwgXCIjM2U0YTg5XCIsIFwiIzNlNGM4YVwiLCBcIiMzZDRkOGFcIiwgXCIjM2Q0ZThhXCIsIFwiIzNjNGY4YVwiLCBcIiMzYzUwOGJcIiwgXCIjM2I1MThiXCIsIFwiIzNiNTI4YlwiLCBcIiMzYTUzOGJcIiwgXCIjM2E1NDhjXCIsIFwiIzM5NTU4Y1wiLCBcIiMzOTU2OGNcIiwgXCIjMzg1ODhjXCIsIFwiIzM4NTk4Y1wiLCBcIiMzNzVhOGNcIiwgXCIjMzc1YjhkXCIsIFwiIzM2NWM4ZFwiLCBcIiMzNjVkOGRcIiwgXCIjMzU1ZThkXCIsIFwiIzM1NWY4ZFwiLCBcIiMzNDYwOGRcIiwgXCIjMzQ2MThkXCIsIFwiIzMzNjI4ZFwiLCBcIiMzMzYzOGRcIiwgXCIjMzI2NDhlXCIsIFwiIzMyNjU4ZVwiLCBcIiMzMTY2OGVcIiwgXCIjMzE2NzhlXCIsIFwiIzMxNjg4ZVwiLCBcIiMzMDY5OGVcIiwgXCIjMzA2YThlXCIsIFwiIzJmNmI4ZVwiLCBcIiMyZjZjOGVcIiwgXCIjMmU2ZDhlXCIsIFwiIzJlNmU4ZVwiLCBcIiMyZTZmOGVcIiwgXCIjMmQ3MDhlXCIsIFwiIzJkNzE4ZVwiLCBcIiMyYzcxOGVcIiwgXCIjMmM3MjhlXCIsIFwiIzJjNzM4ZVwiLCBcIiMyYjc0OGVcIiwgXCIjMmI3NThlXCIsIFwiIzJhNzY4ZVwiLCBcIiMyYTc3OGVcIiwgXCIjMmE3ODhlXCIsIFwiIzI5Nzk4ZVwiLCBcIiMyOTdhOGVcIiwgXCIjMjk3YjhlXCIsIFwiIzI4N2M4ZVwiLCBcIiMyODdkOGVcIiwgXCIjMjc3ZThlXCIsIFwiIzI3N2Y4ZVwiLCBcIiMyNzgwOGVcIiwgXCIjMjY4MThlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjU4MzhlXCIsIFwiIzI1ODQ4ZVwiLCBcIiMyNTg1OGVcIiwgXCIjMjQ4NjhlXCIsIFwiIzI0ODc4ZVwiLCBcIiMyMzg4OGVcIiwgXCIjMjM4OThlXCIsIFwiIzIzOGE4ZFwiLCBcIiMyMjhiOGRcIiwgXCIjMjI4YzhkXCIsIFwiIzIyOGQ4ZFwiLCBcIiMyMThlOGRcIiwgXCIjMjE4ZjhkXCIsIFwiIzIxOTA4ZFwiLCBcIiMyMTkxOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkzOGNcIiwgXCIjMWY5NDhjXCIsIFwiIzFmOTU4YlwiLCBcIiMxZjk2OGJcIiwgXCIjMWY5NzhiXCIsIFwiIzFmOTg4YlwiLCBcIiMxZjk5OGFcIiwgXCIjMWY5YThhXCIsIFwiIzFlOWI4YVwiLCBcIiMxZTljODlcIiwgXCIjMWU5ZDg5XCIsIFwiIzFmOWU4OVwiLCBcIiMxZjlmODhcIiwgXCIjMWZhMDg4XCIsIFwiIzFmYTE4OFwiLCBcIiMxZmExODdcIiwgXCIjMWZhMjg3XCIsIFwiIzIwYTM4NlwiLCBcIiMyMGE0ODZcIiwgXCIjMjFhNTg1XCIsIFwiIzIxYTY4NVwiLCBcIiMyMmE3ODVcIiwgXCIjMjJhODg0XCIsIFwiIzIzYTk4M1wiLCBcIiMyNGFhODNcIiwgXCIjMjVhYjgyXCIsIFwiIzI1YWM4MlwiLCBcIiMyNmFkODFcIiwgXCIjMjdhZDgxXCIsIFwiIzI4YWU4MFwiLCBcIiMyOWFmN2ZcIiwgXCIjMmFiMDdmXCIsIFwiIzJjYjE3ZVwiLCBcIiMyZGIyN2RcIiwgXCIjMmViMzdjXCIsIFwiIzJmYjQ3Y1wiLCBcIiMzMWI1N2JcIiwgXCIjMzJiNjdhXCIsIFwiIzM0YjY3OVwiLCBcIiMzNWI3NzlcIiwgXCIjMzdiODc4XCIsIFwiIzM4Yjk3N1wiLCBcIiMzYWJhNzZcIiwgXCIjM2JiYjc1XCIsIFwiIzNkYmM3NFwiLCBcIiMzZmJjNzNcIiwgXCIjNDBiZDcyXCIsIFwiIzQyYmU3MVwiLCBcIiM0NGJmNzBcIiwgXCIjNDZjMDZmXCIsIFwiIzQ4YzE2ZVwiLCBcIiM0YWMxNmRcIiwgXCIjNGNjMjZjXCIsIFwiIzRlYzM2YlwiLCBcIiM1MGM0NmFcIiwgXCIjNTJjNTY5XCIsIFwiIzU0YzU2OFwiLCBcIiM1NmM2NjdcIiwgXCIjNThjNzY1XCIsIFwiIzVhYzg2NFwiLCBcIiM1Y2M4NjNcIiwgXCIjNWVjOTYyXCIsIFwiIzYwY2E2MFwiLCBcIiM2M2NiNWZcIiwgXCIjNjVjYjVlXCIsIFwiIzY3Y2M1Y1wiLCBcIiM2OWNkNWJcIiwgXCIjNmNjZDVhXCIsIFwiIzZlY2U1OFwiLCBcIiM3MGNmNTdcIiwgXCIjNzNkMDU2XCIsIFwiIzc1ZDA1NFwiLCBcIiM3N2QxNTNcIiwgXCIjN2FkMTUxXCIsIFwiIzdjZDI1MFwiLCBcIiM3ZmQzNGVcIiwgXCIjODFkMzRkXCIsIFwiIzg0ZDQ0YlwiLCBcIiM4NmQ1NDlcIiwgXCIjODlkNTQ4XCIsIFwiIzhiZDY0NlwiLCBcIiM4ZWQ2NDVcIiwgXCIjOTBkNzQzXCIsIFwiIzkzZDc0MVwiLCBcIiM5NWQ4NDBcIiwgXCIjOThkODNlXCIsIFwiIzliZDkzY1wiLCBcIiM5ZGQ5M2JcIiwgXCIjYTBkYTM5XCIsIFwiI2EyZGEzN1wiLCBcIiNhNWRiMzZcIiwgXCIjYThkYjM0XCIsIFwiI2FhZGMzMlwiLCBcIiNhZGRjMzBcIiwgXCIjYjBkZDJmXCIsIFwiI2IyZGQyZFwiLCBcIiNiNWRlMmJcIiwgXCIjYjhkZTI5XCIsIFwiI2JhZGUyOFwiLCBcIiNiZGRmMjZcIiwgXCIjYzBkZjI1XCIsIFwiI2MyZGYyM1wiLCBcIiNjNWUwMjFcIiwgXCIjYzhlMDIwXCIsIFwiI2NhZTExZlwiLCBcIiNjZGUxMWRcIiwgXCIjZDBlMTFjXCIsIFwiI2QyZTIxYlwiLCBcIiNkNWUyMWFcIiwgXCIjZDhlMjE5XCIsIFwiI2RhZTMxOVwiLCBcIiNkZGUzMThcIiwgXCIjZGZlMzE4XCIsIFwiI2UyZTQxOFwiLCBcIiNlNWU0MTlcIiwgXCIjZTdlNDE5XCIsIFwiI2VhZTUxYVwiLCBcIiNlY2U1MWJcIiwgXCIjZWZlNTFjXCIsIFwiI2YxZTUxZFwiLCBcIiNmNGU2MWVcIiwgXCIjZjZlNjIwXCIsIFwiI2Y4ZTYyMVwiLCBcIiNmYmU3MjNcIiwgXCIjZmRlNzI1XCJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3B1cnBsZScsICdvcmFuZ2UnLCAnYmx1ZScsICd5ZWxsb3cnLCAncGluaycsICdncmVlbicsICdyZWQnLCAnbmF2eSddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsYXNzZXMgPSAxO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvRG90TWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./src/Gisplay/Maps/ProportionalSymbolsMap.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ProportionalSymbolsMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Proportional Symbols Map implementation.\r\n */\nvar ProportionalSymbolsMap = exports.ProportionalSymbolsMap = function (_Map) {\n    _inherits(ProportionalSymbolsMap, _Map);\n\n    function ProportionalSymbolsMap(bgmap, geometry, options) {\n        _classCallCheck(this, ProportionalSymbolsMap);\n\n        var _this = _possibleConstructorReturn(this, (ProportionalSymbolsMap.__proto__ || Object.getPrototypeOf(ProportionalSymbolsMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.legend; //@Rui TODO WUT\n        _this.annotations = new Array();\n        _this.map = bgmap;\n        _this.id = mapcount++;\n        _this.type = 'PS';\n        _this.loadOptions(options, bgmap);\n        _this.dynamic = options.sizeByClass == undefined ? true : !options.sizeByClass;\n        if (_this.dynamic == true) {\n            _this.maxpointsize = options.maxPointSize == undefined ? 10.0 : parseFloat(options.maxPointSize);\n            _this.minpointsize = options.minPointSize == undefined ? 1.0 : parseFloat(options.minPointSize);\n        }\n        maps.push(_this);\n        _this.initialize();\n        return _this;\n    }\n\n    _createClass(ProportionalSymbolsMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            if (this.dynamic == false) for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            } else {\n                for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                    if (this.aesthetics[i].enabled == true) this.drawProporcionalPoints(this.aesthetics[i]);\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            if (this.aesthetics.length == 1) this.legend.insertProportionalSymbols(this.aesthetics[0], this, this.numberOfLegendItems);else for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (i == 0) this.legend.insertProportionalSymbols(this.aesthetics[i], this, 2);else this.legend.insertProportionalSymbols(this.aesthetics[i], this, 1);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.maxPointSize = 60;\n                    options.minPointSize = 5;\n                    options.colorScheme = ['green', 'red', 'blue'];\n                    options.numberOfClasses = 1;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ProportionalSymbolsMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9Qcm9wb3J0aW9uYWxTeW1ib2xzTWFwLmpzPzgyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIFByb3BvcnRpb25hbCBTeW1ib2xzIE1hcCBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIGV4dGVuZHMgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZDsgLy9AUnVpIFRPRE8gV1VUXHJcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMubWFwID0gYmdtYXA7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ1BTJztcclxuICAgICAgICB0aGlzLmxvYWRPcHRpb25zKG9wdGlvbnMsIGJnbWFwKTtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLnNpemVCeUNsYXNzID09IHVuZGVmaW5lZCA/IHRydWUgOiAhb3B0aW9ucy5zaXplQnlDbGFzcztcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhwb2ludHNpemUgPSBvcHRpb25zLm1heFBvaW50U2l6ZSA9PSB1bmRlZmluZWQgPyAxMC4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1heFBvaW50U2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWlucG9pbnRzaXplID0gb3B0aW9ucy5taW5Qb2ludFNpemUgPT0gdW5kZWZpbmVkID8gMS4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1pblBvaW50U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IGZhbHNlKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQcm9wb3JjaW9uYWxQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljcy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbMF0sIHRoaXMsIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbaV0sIHRoaXMsIDEpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4UG9pbnRTaXplID0gNjA7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1pblBvaW50U2l6ZSA9IDU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydncmVlbicsICdyZWQnLCAnYmx1ZSddO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsYXNzZXMgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvUHJvcG9ydGlvbmFsU3ltYm9sc01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFpQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFNQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv2.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./Gisplay/Gisplay */ 4);\n\nmodule.exports = {\n\n    /** #########################CHOROPLETH MAPS################################# */\n    //Choropleth\n    createBGMap: function createBGMap() {\n        console.log(\"Start gisplayv2. TESTE workflow18/02.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        /*window.count = 0;*/\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            /* console.log(window.map)\r\n             console.log(map)*/\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    createBGMapChorocromatic: function createBGMapChorocromatic() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChorocromatic: function startChorocromatic() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            attr: 'f2',\n            legendTitle: \"Most Frequent Crime\"\n        };\n\n        var time = Date.now();\n        console.log(\"starting Chorocromatic Map...\");\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n            gisplay.makeChorochromaticMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################DOT MAPS################################# */\n    //DOT MAP Example 1\n    createBGMapDotMap: function createBGMapDotMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startDotMap1: function startDotMap1() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 1...\");\n\n        var options = {\n            colorScheme: [\"red\", \"green\"],\n            attr: 'f1',\n            legendTitle: \"Alcohol\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    //DOT MAP Example 2\n    startDotMap2: function startDotMap2() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 2...\");\n\n        var options = {\n            colorScheme: [\"blue\", \"red\"],\n            maxPointSize: 100,\n            numberOfClasses: 2,\n            classBreaksMethod: \"k-means\",\n            minPointSize: 1,\n            attr: 'f2',\n            legendTitle: \"Fatals\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################CHANGE MAPS################################# */\n    //Change map Example\n    createBGMapChangeMap: function createBGMapChangeMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChangeMap: function startChangeMap() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Change Map 1...\");\n\n        var options = {\n            colorScheme: [\"green\", \"red\"],\n            minuend: 'f6',\n            subtrahend: 'f2',\n            alpha: 1,\n            legendTitle: \"Evoluo entre 2009 e 2013\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeChangeMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ########################PROP. SYMBOLS MAPS########################### */\n    createBGPSymbols: function createBGPSymbols() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startPSymbols: function startPSymbols() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Proportional Symbols...\");\n        var options = {\n            maxPointSize: 100,\n            minPointSize: 5,\n            attr: 'f1',\n            alpha: 1.0,\n            numberOfLegendItems: 3,\n            legendTitle: \"Accidents\"\n        };\n\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeProportionalSymbolsMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n\n}; /**\r\n    * This file is the entry point for the Gisplay API\r\n    *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL2dpc3BsYXl2Mi5qcz81ZTM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBUaGlzIGZpbGUgaXMgdGhlIGVudHJ5IHBvaW50IGZvciB0aGUgR2lzcGxheSBBUElcclxuICovXHJcbmltcG9ydCB7IEdpc3BsYXkgfSBmcm9tICcuL0dpc3BsYXkvR2lzcGxheSdcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjQ0hPUk9QTEVUSCBNQVBTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICAvL0Nob3JvcGxldGhcclxuICAgIGNyZWF0ZUJHTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJTdGFydCBnaXNwbGF5djIuIFRFU1RFIHdvcmtmbG93MTgvMDIuXCIpO1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guc3RyZWV0cycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDaG9yb3BsZXRoOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLyp3aW5kb3cuY291bnQgPSAwOyovXHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb2xvclNjaGVtZTogW1wid2hpdGVcIiwgXCJ5ZWxsb3dcIiwgXCJvcmFuZ2VcIiwgXCJyZWRcIl0sXHJcbiAgICAgICAgICAgIG51bWJlck9mQ2xhc3NlczogNCxcclxuICAgICAgICAgICAgYXR0cjogJ2YzJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6ICdGYXRhbHMnXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgdmFyIGRhdGFyZWFkdGltZXN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBkZSBsZWl0dXJhIGRvIGZpY2hlaXJvOiBcIiArIChkYXRhcmVhZHRpbWVzdGFtcCAtIHRpbWUpIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG5cclxuICAgICAgICAgICAgLyogY29uc29sZS5sb2cod2luZG93Lm1hcClcclxuICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1hcCkqL1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VDaG9yb3BsZXRoKHdpbmRvdy5tYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGdpc3BsYXk6IFwiICsgKERhdGUubm93KCkgLSBkYXRhcmVhZHRpbWVzdGFtcCkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gdG90YWw6IFwiICsgKERhdGUubm93KCkgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgY3JlYXRlQkdNYXBDaG9yb2Nyb21hdGljOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5zdHJlZXRzJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydENob3JvY3JvbWF0aWM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGF0dHI6ICdmMicsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIk1vc3QgRnJlcXVlbnQgQ3JpbWVcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIENob3JvY3JvbWF0aWMgTWFwLi4uXCIpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhcmVhZHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZGUgbGVpdHVyYSBkbyBmaWNoZWlybzogXCIgKyAoZGF0YXJlYWR0aW1lc3RhbXAgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hvcm9jaHJvbWF0aWNNYXAobWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNET1QgTUFQUyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLy9ET1QgTUFQIEV4YW1wbGUgMVxyXG4gICAgY3JlYXRlQkdNYXBEb3RNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LmRhcmsnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0RG90TWFwMTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIERvdCBNYXAgMS4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJyZWRcIiwgXCJncmVlblwiXSxcclxuICAgICAgICAgICAgYXR0cjogJ2YxJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiQWxjb2hvbFwiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VEb3RNYXAobWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy9ET1QgTUFQIEV4YW1wbGUgMlxyXG4gICAgc3RhcnREb3RNYXAyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgRG90IE1hcCAyLi4uXCIpO1xyXG5cclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29sb3JTY2hlbWU6IFtcImJsdWVcIiwgXCJyZWRcIl0sXHJcbiAgICAgICAgICAgIG1heFBvaW50U2l6ZTogMTAwLFxyXG4gICAgICAgICAgICBudW1iZXJPZkNsYXNzZXM6IDIsXHJcbiAgICAgICAgICAgIGNsYXNzQnJlYWtzTWV0aG9kOiBcImstbWVhbnNcIixcclxuICAgICAgICAgICAgbWluUG9pbnRTaXplOiAxLFxyXG4gICAgICAgICAgICBhdHRyOiAnZjInLFxyXG4gICAgICAgICAgICBsZWdlbmRUaXRsZTogXCJGYXRhbHNcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlRG90TWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjQ0hBTkdFIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8vQ2hhbmdlIG1hcCBFeGFtcGxlXHJcbiAgICBjcmVhdGVCR01hcENoYW5nZU1hcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guZGFyaycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDaGFuZ2VNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBDaGFuZ2UgTWFwIDEuLi5cIik7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb2xvclNjaGVtZTogW1wiZ3JlZW5cIiwgXCJyZWRcIl0sXHJcbiAgICAgICAgICAgIG1pbnVlbmQ6ICdmNicsXHJcbiAgICAgICAgICAgIHN1YnRyYWhlbmQ6ICdmMicsXHJcbiAgICAgICAgICAgIGFscGhhOiAxLFxyXG4gICAgICAgICAgICBsZWdlbmRUaXRsZTogXCJFdm9sdcOnw6NvIGVudHJlIDIwMDkgZSAyMDEzXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZUNoYW5nZU1hcChtYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVcIikuZmlsZXNbMF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjUFJPUC4gU1lNQk9MUyBNQVBTIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjICovXHJcbiAgICBjcmVhdGVCR1BTeW1ib2xzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5kYXJrJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydFBTeW1ib2xzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwic3RhcnRpbmcgUHJvcG9ydGlvbmFsIFN5bWJvbHMuLi5cIik7XHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIG1heFBvaW50U2l6ZTogMTAwLFxyXG4gICAgICAgICAgICBtaW5Qb2ludFNpemU6IDUsXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMScsXHJcbiAgICAgICAgICAgIGFscGhhOiAxLjAsXHJcbiAgICAgICAgICAgIG51bWJlck9mTGVnZW5kSXRlbXM6IDMsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIkFjY2lkZW50c1wiXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xyXG5cclxuICAgICAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICByZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZVByb3BvcnRpb25hbFN5bWJvbHNNYXAobWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNIRUFUIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxufTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9naXNwbGF5djIuanMiXSwibWFwcGluZ3MiOiI7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5LQTs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);