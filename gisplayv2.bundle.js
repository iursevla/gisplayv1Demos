var GisplayLibrary =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* unknown exports provided */
/* all exports used */
/*!*******************************!*\
  !*** ./src/Gisplay/Legend.js ***!
  \*******************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * This class represents the Map Legend. 15/03\r\n */\nvar Legend = exports.Legend = function () {\n    function Legend(id, title) {\n        _classCallCheck(this, Legend);\n\n        this.title = title;\n        this.init(id);\n        return this;\n    }\n\n    _createClass(Legend, [{\n        key: 'insertLegend',\n        value: function insertLegend(map) {\n            this.legendDiv.appendChild(this.table);\n            map.getContainer().appendChild(this.legendDiv);\n        }\n    }, {\n        key: 'insertPointRow',\n        value: function insertPointRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 2);\n        }\n    }, {\n        key: 'insertPolygonRow',\n        value: function insertPolygonRow(currentaes, mapobj) {\n            this.insertRow(currentaes, mapobj, 1);\n        }\n    }, {\n        key: 'insertRow',\n        value: function insertRow(currentaes, mapobj, type) {\n\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var color = document.createElement('td');\n            var text = void 0;\n            if (typeof currentaes.range[0] === 'number') {\n                var mininput = currentaes.range[0] != null ? currentaes.range[0] : mapobj.min;\n                var maxinput = currentaes.range[1] != null ? currentaes.range[1] : mapobj.max;\n                if (currentaes.outer == false) text = document.createTextNode('[' + mininput + ', ' + maxinput + '[');else text = document.createTextNode('[' + mininput + ', ' + maxinput + ']');\n            } else text = document.createTextNode(currentaes.range[0]);\n            value.appendChild(text);\n\n            var colorDiv = document.createElement('div');\n            colorDiv.style.position = 'relative';\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n            colorDiv.style['backgroundColor'] = rgbc;\n            if (type == 1) {\n                //polygon\n                colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                colorDiv.style.width = 80; //(mapCanvas.width / 10);\n                if (currentaes.strokeColor != null && currentaes != undefined) colorDiv.style['borderColor'] = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';\n                colorDiv.className = '_gisplayrectangle';\n            } else if (type == 2) {\n                //point\n                var size = void 0;\n                if (currentaes.pointSize != null) {\n                    size = Math.max(currentaes.pointSize, 5);\n                } else size = 25;\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.className = '_gisplaycircle';\n            }\n\n            color.appendChild(colorDiv);\n\n            row.appendChild(color);\n            row.appendChild(value);\n\n            row.onclick = function () {\n                if (window.profiling == true) var start = Date.now();\n                if (mapobj.legendToggle != false) {\n                    var toFade = !currentaes.enableDisable();\n                    if (toFade == true) {\n                        this.className += \" _gisplayfade\";\n                    } else {\n                        this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                    }\n                }\n                if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                mapobj.draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                }\n            };\n\n            this.table.appendChild(row);\n        }\n    }, {\n        key: 'insertGradient',\n        value: function insertGradient(mapobj, left, middle, right) {\n            var row = document.createElement('tr');\n            var value = document.createElement('td');\n            var valueDiv = document.createElement('div');\n            value.colSpan = 2;\n            value.style.textAlign = 'center';\n            var numberof = 5;\n            if (mapobj.aesthetics.length > 5) numberof = mapobj.aesthetics.length;\n            var strcolor = '';\n            for (var i = 0; i < numberof; i++) {\n                var color = mapobj.fcolor(i / numberof).rgb();\n                strcolor += ',rgba(' + Math.round(color[0]) + ',' + Math.round(color[1]) + ',' + Math.round(color[2]) + ',' + mapobj.alpha + ')';\n            }\n            strcolor += ') ';\n            valueDiv.style.background = '-webkit-linear-gradient(left' + strcolor;\n\n            valueDiv.style.height = 25; //(mapCanvas.height / 10);\n            valueDiv.style.width = 130; //(mapCanvas.width / 10);\n\n            var row2 = document.createElement('tr');\n            var value2 = document.createElement('td');\n            value2.colSpan = 2;\n\n            var divleft = document.createElement('div');\n            divleft.style.textAlign = 'left';\n            divleft.style.width = '33%';\n            divleft.style.display = \"inline-block\";\n            var lefttext = document.createTextNode(left);\n            var divmid = document.createElement('div');\n            divmid.style.textAlign = 'center';\n            divmid.style.width = '33%';\n            divmid.style.display = \"inline-block\";\n            var text = document.createTextNode(middle);\n            var divright = document.createElement('div');\n            divright.style.textAlign = 'right';\n            divright.style.width = '33%';\n            divright.style.display = \"inline-block\";\n            var righttext = document.createTextNode(right);\n\n            divleft.appendChild(lefttext);\n            divmid.appendChild(text);\n            divright.appendChild(righttext);\n            value2.appendChild(divleft);\n            value2.appendChild(divmid);\n            value2.appendChild(divright);\n            value.appendChild(valueDiv);\n            row2.appendChild(value2);\n            row.appendChild(value);\n            this.table.appendChild(row);\n            this.table.appendChild(row2);\n        }\n    }, {\n        key: 'init',\n        value: function init(id, classname) {\n            //console.log(\"id == \" + id);\n            var mapCanvas = document.getElementById('mapCanvas' + id);\n            this.legendDiv = document.createElement('div');\n            if (classname != undefined && classname != null) {\n                this.legendDiv.className = classname;\n            } else {\n                this.legendDiv.className = '_gisplaylegendBR';\n            }\n            this.legendDiv.id = 'legendDiv' + id;\n\n            this.table = document.createElement('table');\n            this.table.style.zIndex = \"2000\";\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            thcolor.style.align = \"center\";\n            //thcolor.style.width = 100;\n            this.table.appendChild(thcolor);\n            this.table.appendChild(thvalue);\n            var titlerow = document.createElement('tr');\n            var titletd = document.createElement('td');\n            titletd.colSpan = 2;\n            titletd.style.textAlign = 'center';\n            titletd.style.width = 100;\n            var titletext = document.createTextNode(this.title);\n            titletd.appendChild(titletext);\n            titlerow.appendChild(titletd);\n            this.table.appendChild(titlerow);\n        }\n    }, {\n        key: 'insertProportionalSymbols',\n        value: function insertProportionalSymbols(currentaes, mapobj, numberof) {\n            if (this.lastdiv == undefined) {\n                var row = document.createElement('tr');\n                var value = document.createElement('td');\n                value.colSpan = 2;\n                value.style.textAlign = 'center';\n                this.firstInsertion = true;\n            } else {\n                this.firstInsertion = false;\n            }\n\n            var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + 1 + ')';\n            var strokecolor = void 0;\n\n            if (currentaes.strokeColor != null && currentaes != undefined) strokecolor = 'rgba(' + currentaes.strokeColor[0] + ',' + currentaes.strokeColor[1] + ',' + currentaes.strokeColor[2] + ',' + currentaes.strokeColor[3] + ')';else strokecolor = 'rgba(' + 0 + ',' + 0 + ',' + 0 + ',' + 1 + ')';\n\n            for (var i = numberof - 1; i >= 0; i--) {\n                var current = document.createElement('div');\n                var propvalue = void 0;\n                if (this.firstInsertion == false && i == numberof - 1 || numberof == 1) propvalue = currentaes.range[1];else propvalue = mapobj.min + i / (numberof - 1) * (mapobj.max - mapobj.min);\n\n                var text = document.createTextNode(this.round(propvalue));\n                current.appendChild(text);\n                var colorDiv = document.createElement('div');\n                colorDiv.style.position = 'relative';\n                colorDiv.style.backgroundColor = rgbc;\n                colorDiv.className = '_gisplayproportionalcircle';\n                colorDiv.style.borderColor = strokecolor;\n                var temppointsize = (mapobj.maxpointsize - mapobj.minpointsize) / (mapobj.max - mapobj.min) * (propvalue - mapobj.min);\n                var size = Math.max(temppointsize, 7.5);\n                colorDiv.style.height = size;\n                colorDiv.style.width = size;\n                colorDiv.style.inherit = false;\n\n                colorDiv.onclick = function (e) {\n                    if (window.profiling == true) var start = Date.now();\n                    if (mapobj.legendToggle != false) {\n                        var toFade = !currentaes.enableDisable();\n                        if (toFade == true) {\n                            this.className += \" _gisplayfade\";\n                        } else {\n                            this.className = this.className.replace(/(?:^|\\s)_gisplayfade(?!\\S)/g, '');\n                        }\n                    }\n                    if (mapobj.legendOnClickCall != null && mapobj.legendOnClickCall != undefined) mapobj.legendOnClickCall(currentaes);\n                    mapobj.draw();\n                    if (window.profiling == true) {\n                        var end = Date.now();\n                        window.console.log('Tempo de processamento de filtragem pela legenda (segundos): ' + (end - start) / 1000);\n                    }\n                    if (!e) var e = window.event;\n                    e.cancelBubble = true;\n                    if (e.stopPropagation) e.stopPropagation();\n                };\n                current.appendChild(colorDiv);\n                if ( /*i!= (numberof-1) &&*/this.lastdiv != undefined) {\n                    this.lastdiv.appendChild(current);\n                    this.lastdiv = colorDiv;\n                } else {\n                    value.appendChild(current);\n                    this.lastdiv = colorDiv;\n                }\n            }\n            if (this.firstInsertion == true) {\n                row.appendChild(value);\n                this.table.appendChild(row);\n            }\n        }\n    }, {\n        key: 'round',\n        value: function round(value, exp) {\n            //@Rui Added cuz its used by insertProportionalSymbols\n            if (typeof exp === 'undefined' || +exp === 0) return Math.round(value);\n\n            value = +value;\n            exp = +exp;\n\n            if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) return NaN;\n\n            // Shift\n            value = value.toString().split('e');\n            value = Math.round(+(value[0] + 'e' + (value[1] ? +value[1] + exp : exp)));\n\n            // Shift back\n            value = value.toString().split('e');\n            return +(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp));\n        }\n    }]);\n\n    return Legend;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9MZWdlbmQuanM/Yzg0MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIHRoZSBNYXAgTGVnZW5kLiAxNS8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIExlZ2VuZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgdGl0bGUpIHtcclxuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGU7XHJcbiAgICAgICAgdGhpcy5pbml0KGlkKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRMZWdlbmQobWFwKSB7XHJcbiAgICAgICAgdGhpcy5sZWdlbmREaXYuYXBwZW5kQ2hpbGQodGhpcy50YWJsZSk7XHJcbiAgICAgICAgbWFwLmdldENvbnRhaW5lcigpLmFwcGVuZENoaWxkKHRoaXMubGVnZW5kRGl2KTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRQb2ludFJvdyhjdXJyZW50YWVzLCBtYXBvYmopIHtcclxuICAgICAgICB0aGlzLmluc2VydFJvdyhjdXJyZW50YWVzLCBtYXBvYmosIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIGluc2VydFBvbHlnb25Sb3coY3VycmVudGFlcywgbWFwb2JqKSB7XHJcbiAgICAgICAgdGhpcy5pbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCAxKTtcclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRSb3coY3VycmVudGFlcywgbWFwb2JqLCB0eXBlKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICBsZXQgdGV4dDtcclxuICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRhZXMucmFuZ2VbMF0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1pbmlucHV0ID0gY3VycmVudGFlcy5yYW5nZVswXSAhPSBudWxsID8gY3VycmVudGFlcy5yYW5nZVswXSA6IG1hcG9iai5taW47XHJcbiAgICAgICAgICAgIGNvbnN0IG1heGlucHV0ID0gY3VycmVudGFlcy5yYW5nZVsxXSAhPSBudWxsID8gY3VycmVudGFlcy5yYW5nZVsxXSA6IG1hcG9iai5tYXg7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLm91dGVyID09IGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHttaW5pbnB1dH0sICR7bWF4aW5wdXR9W2ApO1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYFske21pbmlucHV0fSwgJHttYXhpbnB1dH1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnRhZXMucmFuZ2VbMF0pO1xyXG4gICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHRleHQpO1xyXG5cclxuICAgICAgICBjb25zdCBjb2xvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGNvbG9yRGl2LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclszXX0pYDtcclxuICAgICAgICBjb2xvckRpdi5zdHlsZVsnYmFja2dyb3VuZENvbG9yJ10gPSByZ2JjO1xyXG4gICAgICAgIGlmICh0eXBlID09IDEpIHsvL3BvbHlnb25cclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50YWVzLnN0cm9rZUNvbG9yICE9IG51bGwgJiYgY3VycmVudGFlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICBjb2xvckRpdi5zdHlsZVsnYm9yZGVyQ29sb3InXSA9IGByZ2JhKCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclswXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzFdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMl19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclszXX0pYDtcclxuICAgICAgICAgICAgY29sb3JEaXYuY2xhc3NOYW1lID0gJ19naXNwbGF5cmVjdGFuZ2xlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PSAyKSB7Ly9wb2ludFxyXG4gICAgICAgICAgICBsZXQgc2l6ZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRhZXMucG9pbnRTaXplICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHNpemUgPSBNYXRoLm1heChjdXJyZW50YWVzLnBvaW50U2l6ZSwgNSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDI1O1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5oZWlnaHQgPSBzaXplO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS53aWR0aCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWNpcmNsZSc7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgY29sb3IuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG5cclxuICAgICAgICByb3cuYXBwZW5kQ2hpbGQoY29sb3IpO1xyXG4gICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgcm93Lm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9GYWRlID0gIWN1cnJlbnRhZXMuZW5hYmxlRGlzYWJsZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvRmFkZSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgbWFwb2JqLmxlZ2VuZE9uQ2xpY2tDYWxsKGN1cnJlbnRhZXMpO1xyXG4gICAgICAgICAgICBtYXBvYmouZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIGZpbHRyYWdlbSBwZWxhIGxlZ2VuZGEgKHNlZ3VuZG9zKTogJHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGluc2VydEdyYWRpZW50KG1hcG9iaiwgbGVmdCwgbWlkZGxlLCByaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgdmFsdWUuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgdmFsdWUuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcbiAgICAgICAgbGV0IG51bWJlcm9mID0gNTtcclxuICAgICAgICBpZiAobWFwb2JqLmFlc3RoZXRpY3MubGVuZ3RoID4gNSlcclxuICAgICAgICAgICAgbnVtYmVyb2YgPSBtYXBvYmouYWVzdGhldGljcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHN0cmNvbG9yID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJvZjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gbWFwb2JqLmZjb2xvcihpIC8gbnVtYmVyb2YpLnJnYigpO1xyXG4gICAgICAgICAgICBzdHJjb2xvciArPSBgLHJnYmEoJHtNYXRoLnJvdW5kKGNvbG9yWzBdKX0sJHtNYXRoLnJvdW5kKGNvbG9yWzFdKX0sJHtNYXRoLnJvdW5kKGNvbG9yWzJdKX0sJHttYXBvYmouYWxwaGF9KWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN0cmNvbG9yICs9ICcpICc7XHJcbiAgICAgICAgdmFsdWVEaXYuc3R5bGUuYmFja2dyb3VuZCA9IGAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0JHtzdHJjb2xvcn1gO1xyXG5cclxuICAgICAgICB2YWx1ZURpdi5zdHlsZS5oZWlnaHQgPSAyNTsvLyhtYXBDYW52YXMuaGVpZ2h0IC8gMTApO1xyXG4gICAgICAgIHZhbHVlRGl2LnN0eWxlLndpZHRoID0gMTMwOy8vKG1hcENhbnZhcy53aWR0aCAvIDEwKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdmFsdWUyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICB2YWx1ZTIuY29sU3BhbiA9IDI7XHJcblxyXG4gICAgICAgIGNvbnN0IGRpdmxlZnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZsZWZ0LnN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcclxuICAgICAgICBkaXZsZWZ0LnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2bGVmdC5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcclxuICAgICAgICBjb25zdCBsZWZ0dGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxlZnQpO1xyXG4gICAgICAgIGNvbnN0IGRpdm1pZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGRpdm1pZC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcclxuICAgICAgICBkaXZtaWQuc3R5bGUud2lkdGggPSAnMzMlJztcclxuICAgICAgICBkaXZtaWQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG1pZGRsZSk7XHJcbiAgICAgICAgY29uc3QgZGl2cmlnaHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBkaXZyaWdodC5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xyXG4gICAgICAgIGRpdnJpZ2h0LnN0eWxlLndpZHRoID0gJzMzJSc7XHJcbiAgICAgICAgZGl2cmlnaHQuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lLWJsb2NrXCI7XHJcbiAgICAgICAgY29uc3QgcmlnaHR0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmlnaHQpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGRpdmxlZnQuYXBwZW5kQ2hpbGQobGVmdHRleHQpO1xyXG4gICAgICAgIGRpdm1pZC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICBkaXZyaWdodC5hcHBlbmRDaGlsZChyaWdodHRleHQpO1xyXG4gICAgICAgIHZhbHVlMi5hcHBlbmRDaGlsZChkaXZsZWZ0KTtcclxuICAgICAgICB2YWx1ZTIuYXBwZW5kQ2hpbGQoZGl2bWlkKTtcclxuICAgICAgICB2YWx1ZTIuYXBwZW5kQ2hpbGQoZGl2cmlnaHQpO1xyXG4gICAgICAgIHZhbHVlLmFwcGVuZENoaWxkKHZhbHVlRGl2KTtcclxuICAgICAgICByb3cyLmFwcGVuZENoaWxkKHZhbHVlMik7XHJcbiAgICAgICAgcm93LmFwcGVuZENoaWxkKHZhbHVlKTtcclxuICAgICAgICB0aGlzLnRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZChyb3cyKTtcclxuICAgIH1cclxuXHJcbiAgICBpbml0KGlkLCBjbGFzc25hbWUpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiaWQgPT0gXCIgKyBpZCk7XHJcbiAgICAgICAgY29uc3QgbWFwQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7aWR9YCk7XHJcbiAgICAgICAgdGhpcy5sZWdlbmREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBpZiAoY2xhc3NuYW1lICE9IHVuZGVmaW5lZCAmJiBjbGFzc25hbWUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERpdi5jbGFzc05hbWUgPSBjbGFzc25hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZERpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlsZWdlbmRCUic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVnZW5kRGl2LmlkID0gYGxlZ2VuZERpdiR7aWR9YDtcclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHRoaXMudGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xyXG4gICAgICAgIHRoaXMudGFibGUuc3R5bGUuekluZGV4ID0gXCIyMDAwXCI7XHJcbiAgICAgICAgY29uc3QgdGh2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgY29uc3QgdGhjb2xvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XHJcbiAgICAgICAgdGhjb2xvci5zdHlsZS5hbGlnbiA9IFwiY2VudGVyXCI7XHJcbiAgICAgICAgLy90aGNvbG9yLnN0eWxlLndpZHRoID0gMTAwO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGhjb2xvcik7XHJcbiAgICAgICAgdGhpcy50YWJsZS5hcHBlbmRDaGlsZCh0aHZhbHVlKTtcclxuICAgICAgICBjb25zdCB0aXRsZXJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XHJcbiAgICAgICAgY29uc3QgdGl0bGV0ZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgdGl0bGV0ZC5jb2xTcGFuID0gMjtcclxuICAgICAgICB0aXRsZXRkLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgIHRpdGxldGQuc3R5bGUud2lkdGggPSAxMDA7XHJcbiAgICAgICAgY29uc3QgdGl0bGV0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50aXRsZSk7XHJcbiAgICAgICAgdGl0bGV0ZC5hcHBlbmRDaGlsZCh0aXRsZXRleHQpO1xyXG4gICAgICAgIHRpdGxlcm93LmFwcGVuZENoaWxkKHRpdGxldGQpO1xyXG4gICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQodGl0bGVyb3cpO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICBpbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKGN1cnJlbnRhZXMsIG1hcG9iaiwgbnVtYmVyb2YpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXN0ZGl2ID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICAgICAgdmFsdWUuY29sU3BhbiA9IDI7XHJcbiAgICAgICAgICAgIHZhbHVlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG4gICAgICAgICAgICB0aGlzLmZpcnN0SW5zZXJ0aW9uID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2UgeyB0aGlzLmZpcnN0SW5zZXJ0aW9uID0gZmFsc2U7IH1cclxuXHJcbiAgICAgICAgY29uc3QgcmdiYyA9IGByZ2JhKCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMF19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMV19LCR7Y3VycmVudGFlcy5maWxsQ29sb3JbMl19LCR7MX0pYDtcclxuICAgICAgICBsZXQgc3Ryb2tlY29sb3I7XHJcblxyXG4gICAgICAgIGlmIChjdXJyZW50YWVzLnN0cm9rZUNvbG9yICE9IG51bGwgJiYgY3VycmVudGFlcyAhPSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIHN0cm9rZWNvbG9yID0gYHJnYmEoJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzBdfSwke2N1cnJlbnRhZXMuc3Ryb2tlQ29sb3JbMV19LCR7Y3VycmVudGFlcy5zdHJva2VDb2xvclsyXX0sJHtjdXJyZW50YWVzLnN0cm9rZUNvbG9yWzNdfSlgO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgc3Ryb2tlY29sb3IgPSBgcmdiYSgkezB9LCR7MH0sJHswfSwkezF9KWA7XHJcblxyXG4gICAgICAgIGZvciAobGV0IGkgPSBudW1iZXJvZiAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgbGV0IHByb3B2YWx1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RJbnNlcnRpb24gPT0gZmFsc2UgJiYgaSA9PSAobnVtYmVyb2YgLSAxKSB8fCBudW1iZXJvZiA9PSAxKVxyXG4gICAgICAgICAgICAgICAgcHJvcHZhbHVlID0gY3VycmVudGFlcy5yYW5nZVsxXTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcHJvcHZhbHVlID0gbWFwb2JqLm1pbiArIGkgLyAobnVtYmVyb2YgLSAxKSAqIChtYXBvYmoubWF4IC0gbWFwb2JqLm1pbik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5yb3VuZChwcm9wdmFsdWUpKTtcclxuICAgICAgICAgICAgY3VycmVudC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICAgICAgY29uc3QgY29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByZ2JjO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlwcm9wb3J0aW9uYWxjaXJjbGUnO1xyXG4gICAgICAgICAgICBjb2xvckRpdi5zdHlsZS5ib3JkZXJDb2xvciA9IHN0cm9rZWNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKChtYXBvYmoubWF4cG9pbnRzaXplIC0gbWFwb2JqLm1pbnBvaW50c2l6ZSkgLyAobWFwb2JqLm1heCAtIG1hcG9iai5taW4pKSAqIChwcm9wdmFsdWUgLSBtYXBvYmoubWluKTtcclxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IE1hdGgubWF4KHRlbXBwb2ludHNpemUsIDcuNSk7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLmhlaWdodCA9IHNpemU7XHJcbiAgICAgICAgICAgIGNvbG9yRGl2LnN0eWxlLndpZHRoID0gc2l6ZTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaW5oZXJpdCA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgICAgY29sb3JEaXYub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWFwb2JqLmxlZ2VuZFRvZ2dsZSAhPSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvRmFkZSA9ICFjdXJyZW50YWVzLmVuYWJsZURpc2FibGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodG9GYWRlID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgKz0gXCIgX2dpc3BsYXlmYWRlXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnJlcGxhY2UoLyg/Ol58XFxzKV9naXNwbGF5ZmFkZSg/IVxcUykvZywgJycpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gbnVsbCAmJiBtYXBvYmoubGVnZW5kT25DbGlja0NhbGwgIT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIG1hcG9iai5sZWdlbmRPbkNsaWNrQ2FsbChjdXJyZW50YWVzKTtcclxuICAgICAgICAgICAgICAgIG1hcG9iai5kcmF3KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIHByb2Nlc3NhbWVudG8gZGUgZmlsdHJhZ2VtIHBlbGEgbGVnZW5kYSAoc2VndW5kb3MpOiAkeyhlbmQgLSBzdGFydCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFlKSB2YXIgZSA9IHdpbmRvdy5ldmVudDtcclxuICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGN1cnJlbnQuYXBwZW5kQ2hpbGQoY29sb3JEaXYpO1xyXG4gICAgICAgICAgICBpZiAoLyppIT0gKG51bWJlcm9mLTEpICYmKi8gdGhpcy5sYXN0ZGl2ICE9IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ZGl2LmFwcGVuZENoaWxkKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0ZGl2ID0gY29sb3JEaXY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZS5hcHBlbmRDaGlsZChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGFzdGRpdiA9IGNvbG9yRGl2O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5maXJzdEluc2VydGlvbiA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIHRoaXMudGFibGUuYXBwZW5kQ2hpbGQocm93KTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICByb3VuZCh2YWx1ZSwgZXhwKSB7Ly9AUnVpIEFkZGVkIGN1eiBpdHMgdXNlZCBieSBpbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzXHJcbiAgICAgICAgaWYgKHR5cGVvZiBleHAgPT09ICd1bmRlZmluZWQnIHx8ICtleHAgPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcclxuXHJcbiAgICAgICAgdmFsdWUgPSArdmFsdWU7XHJcbiAgICAgICAgZXhwID0gK2V4cDtcclxuXHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhKHR5cGVvZiBleHAgPT09ICdudW1iZXInICYmIGV4cCAlIDEgPT09IDApKVxyXG4gICAgICAgICAgICByZXR1cm4gTmFOO1xyXG5cclxuICAgICAgICAvLyBTaGlmdFxyXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnZScpO1xyXG4gICAgICAgIHZhbHVlID0gTWF0aC5yb3VuZCgrKHZhbHVlWzBdICsgJ2UnICsgKHZhbHVlWzFdID8gKCt2YWx1ZVsxXSArIGV4cCkgOiBleHApKSk7XHJcblxyXG4gICAgICAgIC8vIFNoaWZ0IGJhY2tcclxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJ2UnKTtcclxuICAgICAgICByZXR1cm4gKyh2YWx1ZVswXSArICdlJyArICh2YWx1ZVsxXSA/ICgrdmFsdWVbMV0gLSBleHApIDogLWV4cCkpO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L0xlZ2VuZC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 1 */
/* unknown exports provided */
/* all exports used */
/*!*********************************!*\
  !*** ./src/Gisplay/Maps/Map.js ***!
  \*********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Map = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BGMapWrapper = __webpack_require__(/*! ./BGMapWrapper */ 5);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \r\n * ES5 libraries can be used either with \r\n * 1)import if they are just functions or in the case of rtree and ktree a \r\n * webpack loader is needed \"script-loader\"\" can do that.\r\n * 2) Added as <script> tag on index.html file\r\n * The former as choosen.\r\nimport chroma from '../../lib/chroma.min';\r\nimport earcut from '../../lib/earcut'\r\nimport {PolygonLookup} from '../../lib/rtree';\r\n*/\n\n/**\r\n * This class contains the Map class which represents the current map.\r\n * Each map has a group of functions available.\r\n */\nvar Map = exports.Map = function () {\n    function Map(type, geometry, options) {\n        _classCallCheck(this, Map);\n\n        console.log(\"Map constructor called -> super()\");\n        /* return this;*/ //@TODO Remove isnt doing anything? or is it saving the 3 parameters?\n    }\n\n    _createClass(Map, [{\n        key: 'program',\n        value: function program() {\n            this._webgl.program = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram = [];\n            this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();\n            this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();\n\n            var source_code = this.generateShaders();\n\n            var vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);\n            var fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);\n\n            this._webgl.gl.attachShader(this._webgl.program, vertex_shader);\n            this._webgl.gl.attachShader(this._webgl.program, fragment_shader);\n\n            this._webgl.gl.linkProgram(this._webgl.program);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'shader',\n        value: function shader(type, source_code, _webgl) {\n            //Added HERE by Rui\n            var shader = _webgl.gl.createShader(type);\n\n            _webgl.gl.shaderSource(shader, source_code);\n            _webgl.gl.compileShader(shader);\n\n            console.log(\"shader \" + (type.valueOf() == 35633 ? \"vertex\" : \"fragment\") + \": \" + _webgl.gl.getShaderInfoLog(shader));\n\n            return shader;\n        }\n    }, {\n        key: 'generateShaders',\n        value: function generateShaders() {\n            //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=\n            //general\n\n            var vertexSourceCode = \" attribute vec4 vertexCoord; \";\n            vertexSourceCode += \"\\n\tattribute float aPointSize; \";\n            vertexSourceCode += \"\\n\tuniform mat4 projection; \";\n            vertexSourceCode += \"\\n\tattribute float a_opacity; \";\n            vertexSourceCode += \"\\n\tvarying float v_opacity; \";\n            //vertexSourceCode+= \"\\n\tvarying vec4 u_color; \" ; //delete\n            vertexSourceCode += \"\\n\tvoid main() {\";\n            vertexSourceCode += \"\\n\t\tgl_Position = (projection * vertexCoord); \";\n            vertexSourceCode += \"\\n\t\tgl_PointSize = aPointSize; v_opacity = a_opacity; \";\n            vertexSourceCode += \"\\n}\";\n\n            var fragmentSourceCode = \"precision mediump float;\";\n            fragmentSourceCode += \"\\n\t\tuniform vec4 u_color;\"; //uniform\n            fragmentSourceCode += \"\\n\t\tvarying float v_opacity; \";\n            fragmentSourceCode += \"\\n \t\tuniform float isPoint;\";\n            fragmentSourceCode += \"\\n\t\tvoid main(){\";\n            fragmentSourceCode += \"\\n\t\t\tfloat border = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat radius = 0.5;\";\n            fragmentSourceCode += \"\\n\t\t\tfloat centerDist = length(gl_PointCoord - 0.5);\";\n            fragmentSourceCode += \"\\n\t\t\tfloat alpha;\";\n            fragmentSourceCode += \"\\n\t\t\tif (u_color[3] == -1.0){\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  v_opacity * step(centerDist, radius);\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\telse{\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\t\talpha =  u_color[3] * step(centerDist, radius);\";\n            fragmentSourceCode += \"\\n\t\t\t}\"; //unnecessary??\n            fragmentSourceCode += \"\\n\t\t\tif(isPoint == 1.0 ){\";\n            fragmentSourceCode += \"\\n\t\t\tif (alpha < 0.1) discard;\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}\";\n            fragmentSourceCode += \"\\n \t\t\telse\";\n            fragmentSourceCode += \"\\n\t\t\t\tgl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);\";\n            fragmentSourceCode += \"\\n\t\t}\";\n\n            return { vertex: vertexSourceCode, fragment: fragmentSourceCode };\n        }\n    }, {\n        key: 'addAesthetic',\n        value: function addAesthetic(aes) {\n            this.aesthetics.push(aes);\n        }\n    }, {\n        key: 'setAesthetic',\n        value: function setAesthetic(id, aes) {\n            for (var i = 0; i < aesthetics.length; i++) {\n                if (id == aesthetics[i].id) {\n                    aesthetics[i] = aes;\n                    break;\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            var mapCanvas = document.getElementById('mapCanvas' + this.id);\n            var legendDiv = document.createElement('div');\n            legendDiv.id = 'legendDiv' + this.id;\n            legendDiv.style.position = 'absolute';\n            legendDiv.style.backgroundColor = 'white';\n            //legendDiv.style.height = 200;//(mapCanvas.height / 10);\n            legendDiv.style.width = 250; //(mapCanvas.width / 10);\n            legendDiv.style.bottom = 20;\n            legendDiv.style.right = 0;\n            legendDiv.style.borderColor = 'black';\n            legendDiv.style.border = 'solid';\n\n            var table = document.createElement('table');\n            var thvalue = document.createElement('th');\n            var thcolor = document.createElement('th');\n            //thvalue.style.width = 125;\n            table.style.zIndex = \"2000\";\n            thcolor.style.width = 100;\n            table.appendChild(thcolor);\n            table.appendChild(thvalue);\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n                for (var _iterator = this.aesthetics[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                    var currentaes = _step.value;\n\n                    //if(currentaes._features.length > 0 || currentaes._allFeatures.length > 0){\n                    var row = document.createElement('tr');\n                    var value = document.createElement('td');\n                    var color = document.createElement('td');\n                    var ptext = document.createElement('p');\n                    var text = void 0;\n                    if (typeof currentaes.range[0] === 'number') text = document.createTextNode('[' + currentaes.range[0] + ', ' + currentaes.range[1] + '[');else text = document.createTextNode(currentaes.range[0]);\n                    ptext.appendChild(text);\n                    value.appendChild(ptext);\n\n                    var colorDiv = document.createElement('div');\n                    colorDiv.style.position = 'relative';\n                    var rgbc = 'rgba(' + currentaes.fillColor[0] + ',' + currentaes.fillColor[1] + ',' + currentaes.fillColor[2] + ',' + currentaes.fillColor[3] + ')';\n                    //console.log(rgbc);\n                    colorDiv.style['backgroundColor'] = rgbc;\n                    colorDiv.style.height = 25; //(mapCanvas.height / 10);\n                    colorDiv.style.width = 80; //(mapCanvas.width / 10);\n\n\n                    color.appendChild(colorDiv);\n\n                    row.appendChild(color);\n                    row.appendChild(value);\n\n                    table.appendChild(row);\n                    //}\n                }\n            } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion && _iterator.return) {\n                        _iterator.return();\n                    }\n                } finally {\n                    if (_didIteratorError) {\n                        throw _iteratorError;\n                    }\n                }\n            }\n\n            legendDiv.appendChild(table);\n            this.map.getContainer().appendChild(legendDiv);\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n\n            var aesarray = [];\n            var values = [];\n            var strings = [];\n            var breaks = void 0;\n            var fcolor = void 0;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (geojson.features[g].properties[this.attr] != null && typeof geojson.features[g].properties[this.attr] == 'number') {\n                    values.push(geojson.features[g].properties[this.attr]);\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);\n                } else if (!strings.includes(geojson.features[g].properties[this.attr])) strings.push(geojson.features[g].properties[this.attr]);\n            }\n            if (values.length > 0) {\n                //quantitative\n                if (this.breaks == undefined) {\n                    if (numberOf > 1) breaks = this.calcClassBreaks(values, algorithm, numberOf);else breaks = [this.min, this.max];\n                } else {\n                    breaks = this.breaks;\n                }\n                if (breaks.length > 2) {\n                    fcolor = chroma.scale(colorscheme).colors(breaks.length - 1);\n                    for (var i = 0; i < breaks.length - 1; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        if (i != breaks.length - 2) {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                        } else {\n                            var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);\n                            aes.outer = true;\n                        }\n                        aesarray.push(aes);\n                    }\n                } else {\n                    color = chroma(colorscheme[0]).rgb();\n                    var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n                    aes.outer = true;\n                    aesarray.push(aes);\n                }\n            } else {\n                //qualitative\n                if (strings.length > 0) {\n                    breaks = strings;\n                    if (typeof colorscheme === 'string') {\n                        //string\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    } else {\n                        //array\n                        fcolor = chroma.scale(colorscheme).colors(breaks.length);\n                    }\n                    for (var i = 0; i < breaks.length; i++) {\n                        var color = chroma(fcolor[i]).rgb();\n                        var aes = new _Aesthetic.Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);\n                        aesarray.push(aes);\n                    }\n                }\n            }\n\n            this.aesthetics = aesarray;\n            //return aesarray;\n        }\n    }, {\n        key: 'calcClassBreaks',\n        value: function calcClassBreaks(values, algorithm, numberOf) {\n            var breaks = void 0;\n            switch (algorithm) {\n                case 'equidistant':\n                    breaks = chroma.limits(values, 'e', numberOf);\n                    break;\n\n                case 'quantile':\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n\n                case 'k-means':\n                    breaks = chroma.limits(values, 'k', numberOf);\n                    break;\n\n                default:\n                    breaks = chroma.limits(values, 'q', numberOf);\n                    break;\n            }\n            return breaks;\n        }\n    }, {\n        key: 'insertFeature',\n        value: function insertFeature(id, properties, triangles, borders, points) {\n            var flag = false;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {\n                    this.aesthetics[i].addFeature(id, properties, triangles, borders, points);\n                    flag = true;\n                }\n            }\n            if (!flag) {\n                //TODO\n                //console.log(\"TODO: feature does not fit into any of the aesthetics defined.\\n Value: \" + properties[this.attr]);\n            }\n        }\n    }, {\n        key: 'insertGroupedFeature',\n        value: function insertGroupedFeature(idaes, triangles, borders, points) {\n            this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);\n        }\n    }, {\n        key: 'draw',\n        value: function draw() {\n            alert(\"draw() not implemented\");\n        }\n    }, {\n        key: 'processPolygon',\n        value: function processPolygon(polygon) {\n\n            if (polygon.geometry.type == \"Polygon\") {\n                var outsidepolygon = polygon.geometry.coordinates[0];\n\n                var insidepolygons = [];\n                for (var k = 1; k < polygon.geometry.coordinates.length; k++) {\n                    //todo inside polygon\n                    //insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                }\n                var tempVerts = new Array();\n                for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n                    _vertexcount += (outsidepolygon.length + 1) / 2;\n                    //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                }\n\n                var triangles_vert = earcut(tempVerts);\n                _tricount += triangles_vert.length / 3;\n                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n            } else if (polygon.geometry.type == \"MultiPolygon\") {\n                var polyarray = [];\n                for (var i = 0; i < polygon.geometry.coordinates.length; i++) {\n\n                    var outsidepolygon = polygon.geometry.coordinates[i][0];\n\n                    var insidepolygons = [];\n                    for (var k = 1; k < polygon.geometry.coordinates[i].length; k++) {\n                        //todo inside polygon\n                        insidepolygons.push(polygon.geometry.coordinates[i][k]);\n                    }\n                    var tempVerts = new Array();\n                    _vertexcount += outsidepolygon.length;\n                    for (var out = 0; out < outsidepolygon.length - 1; out++) {\n                        tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);\n\n                        //console.log(\"lon: \" + outsidepolygon[out][0] + \" lat: \" + outsidepolygon[out][1]);\n                    }\n\n                    var triangles_vert = earcut(tempVerts);\n\n                    //var temp = earcut.flatten(polygon.geometry.coordinates[i]);\n                    //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);\n                    _tricount += triangles_vert.length / 3;\n                    polyarray.push({ triangles: triangles_vert, vertex: tempVerts });\n                    //console.log(polyarray);\n                }\n\n                return polyarray;\n            }\n        }\n    }, {\n        key: 'processData',\n        value: function processData(geojson) {\n            this.loadGeoJSON(geojson);\n        }\n    }, {\n        key: 'createAndInsertFeature',\n        value: function createAndInsertFeature(id, geometry, properties) {\n            var gl = this._webgl.gl;\n            if (this.minuend != undefined && this.subtrahend != undefined && typeof properties[this.minuend] == 'number' && properties[this.subtrahend] != undefined && typeof properties[this.subtrahend] == 'number' && properties[this.subtrahend] != undefined) {\n                properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];\n            }\n\n            if (geometry.type == \"Polygon\" || geometry.type == \"MultiPolygon\") {\n                this.hasPolygons = true;\n                var polygons = this.processPolygon({ geometry: geometry, properties: properties });\n\n                var currentBorders = [];\n                var currentTriangles = [];\n                var bufferT = [];\n                var bufferB = [];\n\n                for (var j = 0; j < polygons.length; j++) {\n                    var trianglespolygon = polygons[j].triangles;\n                    var border = polygons[j].vertex;\n                    currentTriangles[j] = new Array();\n                    currentBorders[j] = new Array();\n                    for (var h = 0; h < trianglespolygon.length; h++) {\n                        var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);\n                        currentTriangles[j].push(pixel.x, pixel.y);\n\n                        if (h == trianglespolygon.length - 1) {\n                            bufferT.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentTriangles[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferT[j].itemSize = 2;\n                            bufferT[j].numItems = vertArray.length / 2;\n                        }\n                    }\n\n                    for (var y = 0; y < border.length; y += 2) {\n                        var pixel = this.latLongToPixelXY(border[y], border[y + 1]);\n                        currentBorders[j].push(pixel.x, pixel.y);\n\n                        if (y == border.length - 2) {\n                            bufferB.push(gl.createBuffer());\n\n                            var vertArray = new Float32Array(currentBorders[j]);\n\n                            gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                            gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);\n                            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                            bufferB[j].itemSize = 2;\n                            bufferB[j].numItems = vertArray.length / 2;\n                        }\n                    }\n                }\n                //polygon\n                this.insertFeature(id, properties, bufferT, bufferB, []);\n            } else if (geometry.type == \"Point\" && this.dynamic == true) {\n                //dum\n                var currentPoints = [];\n                currentPoints[0] = new Array();\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                currentPoints[0].push(pixel.x, pixel.y);\n                var bufferP = [];\n                bufferP.push(gl.createBuffer());\n\n                var vertArray = new Float32Array(currentPoints[0]);\n\n                gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                bufferP[0].itemSize = 2;\n                bufferP[0].numItems = vertArray.length / 2;\n\n                this.insertFeature(id, properties, [], [], bufferP);\n\n                if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            } else if (geometry.type == \"Point\" && this.dynamic == false) {\n                //debugger;\n                var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);\n                if (this.tempPoints == null || this.tempPoints == undefined) {\n                    this.tempPoints = new Array();\n                    for (var a = 0; a < this.aesthetics.length; a++) {\n                        this.tempPoints[a] = [];\n                    }\n                }\n\n                var aesarrays = this.fitFeature(properties);\n                for (var y = 0; y < aesarrays.length; y++) {\n                    this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);\n                }\n\n                if (this.treepoints == null) this.treepoints = [];\n                this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties: properties });\n            }\n        }\n    }, {\n        key: 'buildTrees',\n        value: function buildTrees(geojson) {\n            var gl = this._webgl.gl;\n            if (this.tempPoints != null) {\n                for (var t = 0; t < this.tempPoints.length; t++) {\n                    if (this.tempPoints[t].length > 0) {\n                        var bufferP = [];\n                        bufferP.push(gl.createBuffer());\n\n                        var vertArray = new Float32Array(this.tempPoints[t]);\n\n                        gl.fsize = vertArray.BYTES_PER_ELEMENT;\n                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);\n                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);\n\n                        bufferP[0].itemSize = 2;\n                        bufferP[0].numItems = vertArray.length / 2;\n                        this.insertGroupedFeature(t, [], [], bufferP);\n                    }\n                }\n            }\n            //console.log(geojson)\n            if (this.treepoints != null) this.kdtree = new kdTree(this.treepoints, function (a, b) {\n                return (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2;\n            }, [\"lon\", \"lat\", \"properties\"]);\n            if (this.hasPolygons == true) this.rtree = new PolygonLookup(geojson); //console.log(\"@Rui LOOK I WAS REMOVED\");\n        }\n    }, {\n        key: 'loadGeoJSON',\n        value: function loadGeoJSON(geojson) {\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                geojson.features[g].properties['_gisplayid'] = g;\n                var geometry = geojson.features[g].geometry;\n                var properties = geojson.features[g].properties;\n                this.createAndInsertFeature(g, geometry, properties);\n            }\n            this.buildTrees(geojson);\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas() {\n            var canvas = this.map.createCanvas(this.id);\n\n            //init webgl properties\n            this._webgl = {\n                gl: null,\n                program: null,\n                projection: null\n            };\n\n            this._webgl.gl = canvas.getContext(\"webgl\");\n            this._webgl.projection = new Float32Array(16);\n            this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);\n\n            this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);\n            this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'getNumberOfFeatures',\n        value: function getNumberOfFeatures() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                count += this.aesthetics[i]._features.length;\n            }\n            return count;\n        }\n    }, {\n        key: 'scaleProjection',\n        value: function scaleProjection(matrix, scaleX, scaleY) {\n            // scaling x and y, which is just scaling first two rows of matrix\n            matrix[0] *= scaleX;\n            matrix[1] *= scaleX;\n            matrix[2] *= scaleX;\n            matrix[3] *= scaleX;\n\n            matrix[4] *= scaleY;\n            matrix[5] *= scaleY;\n            matrix[6] *= scaleY;\n            matrix[7] *= scaleY;\n        }\n    }, {\n        key: 'translateProjection',\n        value: function translateProjection(matrix, tx, ty) {\n            // translation is in last row of matrix\n            matrix[12] += matrix[0] * tx + matrix[4] * ty;\n            matrix[13] += matrix[1] * tx + matrix[5] * ty;\n            matrix[14] += matrix[2] * tx + matrix[6] * ty;\n            matrix[15] += matrix[3] * tx + matrix[7] * ty;\n        }\n    }, {\n        key: 'latLongToPixelXY',\n        value: function latLongToPixelXY(longitude, latitude) {\n            var pi_180 = Math.PI / 180.0;\n            var pi_4 = Math.PI * 4;\n            var sinLatitude = Math.sin(latitude * pi_180);\n            var pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / pi_4) * 256;\n            var pixelX = (longitude + 180) / 360 * 256;\n\n            var pixel = { x: pixelX, y: pixelY };\n\n            return pixel;\n        }\n    }, {\n        key: 'clear',\n        value: function clear() {\n            var gl = this._webgl.gl;\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.disable(gl.DEPTH_TEST);\n        }\n    }, {\n        key: 'drawTriangles',\n        value: function drawTriangles(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawBorders',\n        value: function drawBorders(aes) {\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);\n\n            for (var i = 0; i < aes._features.length; i++) {\n                for (var y = 0; y < aes._features[i]._borders.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawPoints',\n        value: function drawPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);\n\n            for (var i = 0; i < aes._features.length && this.dynamic == true; i++) {\n                for (var y = 0; y < aes._features[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                    //1);\n                }\n            }\n\n            for (var i = 0; this.dynamic == false && aes._allFeatures != null && i < aes._allFeatures.length; i++) {\n                for (var y = 0; y < aes._allFeatures[i]._points.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);\n                    //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);\t\n                    //1);\n                }\n            }\n        }\n    }, {\n        key: 'drawContinuousPolygons',\n        value: function drawContinuousPolygons(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            //gl.clear(gl.COLOR_BUFFER_BIT);\n            //gl.disable(gl.DEPTH_TEST);\n\n            //gl.enable(gl.BLEND);\n            //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n\n            var currentZoom = this.map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 0.0);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n\n            for (var i = 0; i < aes._features.length; i++) {\n                var ucolor = void 0;\n                var color = void 0;\n                var diff = aes._features[i]._properties[this.attr];\n                if (diff == 0) color = aes.fillColor(0.5).rgb();else {\n                    if (diff > 0) {\n                        color = aes.fillColor(0.5 + diff / this.max / 2).rgb();\n                    } else {\n                        color = aes.fillColor(0.5 - diff / this.min / 2).rgb();\n                    }\n                }\n                ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];\n\n                gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);\n                for (var y = 0; y < aes._features[i]._triangles.length; y++) {\n\n                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);\n\n                    gl.enableVertexAttribArray(vertexCoordLocation);\n                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                    //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                    gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);\n                }\n            }\n        }\n    }, {\n        key: 'drawProporcionalPoints',\n        value: function drawProporcionalPoints(aes) {\n\n            var gl = this._webgl.gl;\n            if (gl == null) return;\n            var matrixProjection = new Float32Array(16);\n\n            gl.enable(gl.BLEND);\n            gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n            var currentZoom = this.map.getZoom();\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.program, 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.program, 'vertexCoord');\n\n            var vertexColorLocation = gl.getUniformLocation(this._webgl.program, \"u_color\");\n\n            var isPointLocation = gl.getUniformLocation(this._webgl.program, 'isPoint');\n            gl.uniform1f(isPointLocation, 1.0);\n\n            /** \r\n             * \r\n             *  Draw Polygons' Interior\r\n             *  **/\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n            //console.log(\"Numero de Buffers: \", buffers.length);\n\n            gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);\n\n            if (this.dynamic == true) {\n                for (var i in aes._features) {\n                    for (var y in aes._features[i]._points) {\n\n                        gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);\n                        var propvalue = parseFloat(aes._features[i]._properties[this.attr]);\n                        var temppointsize = (this.maxpointsize - this.minpointsize) / (this.max - this.min) * (propvalue - this.min);\n                        var pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);\n                        var vertexSizeLocation = gl.getAttribLocation(this._webgl.program, 'aPointSize');\n                        gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n                        gl.enableVertexAttribArray(vertexCoordLocation);\n                        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);\n                        //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);\n                        //gl.enableVertexAttribArray(vertexColorLocation);\n\n\n                        gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);\n                        //1);\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'initialize',\n        value: function initialize() {\n            this.max = null;\n            this.min = null;\n            this.createCanvas();\n            this.program();\n            var mappos = void 0;\n            for (var i = 0; i < maps.length; i++) {\n                if (maps[i].id == this.id) mappos = i;\n            }this.map.onEvent('move', function () {\n                console.log(\"@Rui: mudar o profiling do window para outra coisa?\");\n                if (window.profiling == true) var start = Date.now();\n                maps[mappos].draw();\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de Zoom/Pan (segundos):' + (end - start) / 1000);\n                }\n            });\n\n            this.setupOnclick(mappos);\n        }\n    }, {\n        key: 'setupOnclick',\n        value: function setupOnclick(mappos) {\n            console.log(\"@Rui: profiling mudar de window para? | Rtree e KdTree\");\n            maps[mappos].map.onEvent('click', function (e) {\n                if (window.profiling == true) var start = Date.now();\n                var lat = e.latlng.lat;\n                var lon = e.latlng.lng;\n\n                if (maps[mappos].rtree != undefined) {\n                    var bool = maps[0].rtree.search(lon, lat);\n                    if (bool == undefined) return;else {\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s); //todo\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n                if (maps[mappos].kdtree != undefined) {\n\n                    var nearest = maps[mappos].kdtree.nearest({ lat: lat, lon: lon }, 1, 128 / 2 ** (map.getZoom() * 2));\n                    if (nearest.length <= 0) return;else {\n                        var bool = nearest[0][0];\n                        //console.log\n                        var s = \"\";\n                        var first = true;\n                        if (maps[mappos].showPropertiesOnClick != null) {\n                            for (var i = 0; i < maps[mappos].showPropertiesOnClick.length; i += 2) {\n                                if (first) {\n                                    s += maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                    first = false;\n                                } else {\n                                    s += '\\n' + maps[mappos].showPropertiesOnClick[i + 1] + ': ' + bool.properties[maps[mappos].showPropertiesOnClick[i]];\n                                }\n                            }\n                        } else {\n\n                            var keys = Object.keys(bool.properties);\n\n                            for (var i = 0; i < keys.length; i++) {\n                                if (keys[i] != \"_gisplayid\") {\n                                    if (first) {\n                                        s += keys[i] + ': ' + bool.properties[keys[i]];\n                                        first = false;\n                                    } else {\n                                        s += '\\n' + keys[i] + ': ' + bool.properties[keys[i]];\n                                    }\n                                }\n                            }\n                        }\n                        if (maps[mappos].interactive == true) alert(s);\n                        if (maps[mappos].mapOnClickCall != undefined && maps[mappos].mapOnClickCall != null) maps[mappos].mapOnClickCall(bool);\n                    }\n                }\n\n                if (window.profiling == true) {\n                    var end = Date.now();\n                    window.console.log('Tempo de processamento de um click (segundos): ' + (end - start) / 1000);\n                }\n            });\n        }\n    }, {\n        key: 'fitFeature',\n        value: function fitFeature(properties) {\n            var result = [];\n            for (var a = 0; a < this.aesthetics.length; a++) {\n                if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true) result.push(a);\n            }\n            return result;\n        }\n    }, {\n        key: 'loadOptions',\n        value: function loadOptions(options, bgmap) {\n            if (options.customMapService == true) this.map = bgmap;else this.map = new _BGMapWrapper.BGMapWrapper(bgmap);\n            if (options.loader != false) this.loader();\n\n            if (options.showPropertiesOnClick == true) {\n                this.showPropertiesOnClick = null;\n                //append on bgmap object\n            } else if (options.showPropertiesOnClick == false) {\n                //nada\n            } else if (options.showPropertiesOnClick != undefined) {\n                this.showPropertiesOnClick = options.showPropertiesOnClick;\n            }\n            this.alpha = options.alpha != undefined ? options.alpha : 0.8;\n            this.interactive = options.interactive == undefined ? true : !options.interactive;\n            this.attr = options.attr;\n            this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;\n            this.maxfeatures = options.maxFeatures;\n            this.breaks = options.classBreaks;\n            this.colorscheme = options.colorScheme;\n            this.numberofclasses = options.numberOfClasses;\n            this.algorithm = options.classBreaksMethod;\n            this.legendOnClickCall = options.legendOnClickFunction;\n            this.mapOnClickCall = options.mapOnClickFunction;\n            this.minuend = options.minuend;\n            this.subtrahend = options.subtrahend;\n            this.legendTitle = options.legendTitle != undefined ? options.legendTitle : this.attr != undefined ? this.attr : this.minuend + ' - ' + this.subtrahend;\n            this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            this.map.loader();\n        }\n    }, {\n        key: 'drawHeatPoints',\n        value: function drawHeatPoints(aes) {\n            var gl = this._webgl.gl;\n\n            if (gl == null) return;\n            gl.useProgram(this._webgl.heatmapProgram[0]);\n            var matrixProjection = new Float32Array(16);\n\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            gl.enable(gl.BLEND);\n\n            gl.blendFunc(gl.ONE, gl.ONE);\n\n            var currentZoom = map.getZoom();\n            var pointSize = Math.max(currentZoom - 5.0, 1.0);\n\n            matrixProjection.set(this._webgl.projection);\n\n            var scale = 2 ** currentZoom;\n            this.scaleProjection(matrixProjection, scale, scale);\n\n            var offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());\n            this.translateProjection(matrixProjection, -offset.x, -offset.y);\n\n            var projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], 'projection');\n            gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);\n\n            var vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'position');\n            var deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'delta');\n            var intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'intensity');\n            var vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], 'aPointSize');\n\n            gl.vertexAttrib1f(vertexSizeLocation, pointSize);\n\n            gl.enableVertexAttribArray(vertexCoordLocation);\n            gl.enableVertexAttribArray(deltaLocation);\n            gl.enableVertexAttribArray(intensityLoc);\n\n            var fsize = Float32Array.BYTES_PER_ELEMENT;\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);\n            gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);\n            gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);\n            gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);\n\n            console.log(aes._allFeatures[0]._points[0].numItems);\n            gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);\n\n            gl.useProgram(this._webgl.heatmapProgram[1]);\n\n            gl.disable(gl.BLEND);\n\n            //console.log(\"fase 1 concluida\");\n\n            var canvas = document.getElementById('mapCanvas' + this.id);\n\n            var source = gl.createTexture();\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, source);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n\n            function isPowerOf2(value) {\n                return (value & value - 1) == 0;\n            };\n\n            function steupTextureFilteringAndMips(width, height, gl) {\n                if (isPowerOf2(width) && isPowerOf2(height)) {\n                    // the dimensions are power of 2 so generate mips and turn on \n                    // tri-linear filtering.\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                } else {\n                    // at least one of the dimensions is not a power of 2 so set the filtering\n                    // so WebGL will render it.\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n            };\n\n            steupTextureFilteringAndMips(canvas.width, canvas.height, gl);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n            var vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);\n            var buffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n            var positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], 'position');\n            var sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], 'source');\n            gl.enableVertexAttribArray(positionLoc);\n            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);\n            gl.uniform1i(sourceLoc, 0);\n            gl.drawArrays(gl.TRIANGLES, 0, 6);\n\n            gl.disableVertexAttribArray(positionLoc);\n            //defaults to general program\n            //console.log(\"fase 2 concluida\");\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n            this._webgl.gl.useProgram(this._webgl.program);\n        }\n    }, {\n        key: 'getNumberOfPolygons',\n        value: function getNumberOfPolygons() {\n            var count = 0;\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                for (var z = 0; z < this.aesthetics[i]._features.length; z++) {\n                    count += this.aesthetics[i]._features[z]._triangles.length;\n                }\n            }\n            return count;\n        }\n    }]);\n\n    return Map;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL01hcC5qcz8xZDYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJHTWFwV3JhcHBlciB9IGZyb20gJy4vQkdNYXBXcmFwcGVyJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKiBcclxuICogRVM1IGxpYnJhcmllcyBjYW4gYmUgdXNlZCBlaXRoZXIgd2l0aCBcclxuICogMSlpbXBvcnQgaWYgdGhleSBhcmUganVzdCBmdW5jdGlvbnMgb3IgaW4gdGhlIGNhc2Ugb2YgcnRyZWUgYW5kIGt0cmVlIGEgXHJcbiAqIHdlYnBhY2sgbG9hZGVyIGlzIG5lZWRlZCBcInNjcmlwdC1sb2FkZXJcIlwiIGNhbiBkbyB0aGF0LlxyXG4gKiAyKSBBZGRlZCBhcyA8c2NyaXB0PiB0YWcgb24gaW5kZXguaHRtbCBmaWxlXHJcbiAqIFRoZSBmb3JtZXIgYXMgY2hvb3Nlbi5cclxuaW1wb3J0IGNocm9tYSBmcm9tICcuLi8uLi9saWIvY2hyb21hLm1pbic7XHJcbmltcG9ydCBlYXJjdXQgZnJvbSAnLi4vLi4vbGliL2VhcmN1dCdcclxuaW1wb3J0IHtQb2x5Z29uTG9va3VwfSBmcm9tICcuLi8uLi9saWIvcnRyZWUnO1xyXG4qL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgY29udGFpbnMgdGhlIE1hcCBjbGFzcyB3aGljaCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG1hcC5cclxuICogRWFjaCBtYXAgaGFzIGEgZ3JvdXAgb2YgZnVuY3Rpb25zIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJNYXAgY29uc3RydWN0b3IgY2FsbGVkIC0+IHN1cGVyKClcIilcclxuICAgICAgICAvKiByZXR1cm4gdGhpczsqLyAvL0BUT0RPIFJlbW92ZSBpc250IGRvaW5nIGFueXRoaW5nPyBvciBpcyBpdCBzYXZpbmcgdGhlIDMgcGFyYW1ldGVycz9cclxuICAgIH1cclxuXHJcbiAgICBwcm9ncmFtKCkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2dyYW0gPSB0aGlzLl93ZWJnbC5nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW0gPSBbXTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSA9IHRoaXMuX3dlYmdsLmdsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlX2NvZGUgPSB0aGlzLmdlbmVyYXRlU2hhZGVycygpO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuVkVSVEVYX1NIQURFUiwgc291cmNlX2NvZGUudmVydGV4LCB0aGlzLl93ZWJnbCk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRfc2hhZGVyID0gdGhpcy5zaGFkZXIodGhpcy5fd2ViZ2wuZ2wuRlJBR01FTlRfU0hBREVSLCBzb3VyY2VfY29kZS5mcmFnbWVudCwgdGhpcy5fd2ViZ2wpO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5hdHRhY2hTaGFkZXIodGhpcy5fd2ViZ2wucHJvZ3JhbSwgdmVydGV4X3NoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3dlYmdsLnByb2dyYW0sIGZyYWdtZW50X3NoYWRlcik7XHJcblxyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLmxpbmtQcm9ncmFtKHRoaXMuX3dlYmdsLnByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLmdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wucHJvZ3JhbSk7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIHNoYWRlcih0eXBlLCBzb3VyY2VfY29kZSwgX3dlYmdsKSB7IC8vQWRkZWQgSEVSRSBieSBSdWlcclxuICAgICAgICB2YXIgc2hhZGVyID0gX3dlYmdsLmdsLmNyZWF0ZVNoYWRlcih0eXBlKTtcclxuXHJcbiAgICAgICAgX3dlYmdsLmdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZV9jb2RlKTtcclxuICAgICAgICBfd2ViZ2wuZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhcInNoYWRlciBcIiArICh0eXBlLnZhbHVlT2YoKSA9PSAzNTYzMyA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIpICsgXCI6IFwiICsgX3dlYmdsLmdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcblxyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcblxyXG4gICAgZ2VuZXJhdGVTaGFkZXJzKCkgeyAvL0FkZGVkIEhFUkUgYnkgUnVpIEBUT0RPIFJlZmFjdG9yIHRvIHVzZSBFUzYgYGAgaW5zdGVhZCBvZiArPVxyXG4gICAgICAgIC8vZ2VuZXJhbFxyXG5cclxuICAgICAgICBsZXQgdmVydGV4U291cmNlQ29kZSA9IFwiIGF0dHJpYnV0ZSB2ZWM0IHZlcnRleENvb3JkOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRhdHRyaWJ1dGUgZmxvYXQgYVBvaW50U2l6ZTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0dW5pZm9ybSBtYXQ0IHByb2plY3Rpb247IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdGF0dHJpYnV0ZSBmbG9hdCBhX29wYWNpdHk7IFwiO1xyXG4gICAgICAgIHZlcnRleFNvdXJjZUNvZGUgKz0gXCJcXG5cdHZhcnlpbmcgZmxvYXQgdl9vcGFjaXR5OyBcIjtcclxuICAgICAgICAvL3ZlcnRleFNvdXJjZUNvZGUrPSBcIlxcblx0dmFyeWluZyB2ZWM0IHVfY29sb3I7IFwiIDsgLy9kZWxldGVcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHR2b2lkIG1haW4oKSB7XCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcblx0XHRnbF9Qb3NpdGlvbiA9IChwcm9qZWN0aW9uICogdmVydGV4Q29vcmQpOyBcIjtcclxuICAgICAgICB2ZXJ0ZXhTb3VyY2VDb2RlICs9IFwiXFxuXHRcdGdsX1BvaW50U2l6ZSA9IGFQb2ludFNpemU7IHZfb3BhY2l0eSA9IGFfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgdmVydGV4U291cmNlQ29kZSArPSBcIlxcbn1cIjtcclxuXHJcbiAgICAgICAgbGV0IGZyYWdtZW50U291cmNlQ29kZSA9IFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHVuaWZvcm0gdmVjNCB1X2NvbG9yO1wiOy8vdW5pZm9ybVxyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR2YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTsgXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuIFx0XHR1bmlmb3JtIGZsb2F0IGlzUG9pbnQ7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdHZvaWQgbWFpbigpe1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGZsb2F0IGJvcmRlciA9IDAuNTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCByYWRpdXMgPSAwLjU7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZmxvYXQgY2VudGVyRGlzdCA9IGxlbmd0aChnbF9Qb2ludENvb3JkIC0gMC41KTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRmbG9hdCBhbHBoYTtcIjtcclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRpZiAodV9jb2xvclszXSA9PSAtMS4wKXtcIjsgICAvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHZfb3BhY2l0eSAqIHN0ZXAoY2VudGVyRGlzdCwgcmFkaXVzKTtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHR9XCI7Ly91bm5lY2Vzc2FyeT8/XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0ZWxzZXtcIjsvL3VubmVjZXNzYXJ5Pz9cclxuICAgICAgICBmcmFnbWVudFNvdXJjZUNvZGUgKz0gXCJcXG5cdFx0XHRcdGFscGhhID0gIHVfY29sb3JbM10gKiBzdGVwKGNlbnRlckRpc3QsIHJhZGl1cyk7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0fVwiOy8vdW5uZWNlc3Nhcnk/P1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdGlmKGlzUG9pbnQgPT0gMS4wICl7XCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0aWYgKGFscGhhIDwgMC4xKSBkaXNjYXJkO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHRcdFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCh1X2NvbG9yWzBdLCB1X2NvbG9yWzFdLCB1X2NvbG9yWzJdLCBhbHBoYSk7fVwiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcbiBcdFx0XHRlbHNlXCI7XHJcbiAgICAgICAgZnJhZ21lbnRTb3VyY2VDb2RlICs9IFwiXFxuXHRcdFx0XHRnbF9GcmFnQ29sb3IgPSB2ZWM0KHVfY29sb3JbMF0sIHVfY29sb3JbMV0sIHVfY29sb3JbMl0sIHVfY29sb3JbM10pO1wiO1xyXG4gICAgICAgIGZyYWdtZW50U291cmNlQ29kZSArPSBcIlxcblx0XHR9XCI7XHJcblxyXG4gICAgICAgIHJldHVybiB7IHZlcnRleDogdmVydGV4U291cmNlQ29kZSwgZnJhZ21lbnQ6IGZyYWdtZW50U291cmNlQ29kZSB9O1xyXG4gICAgfVxyXG5cclxuICAgIGFkZEFlc3RoZXRpYyhhZXMpIHtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MucHVzaChhZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldEFlc3RoZXRpYyhpZCwgYWVzKSB7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpZCA9PSBhZXN0aGV0aWNzW2ldLmlkKSB7XHJcbiAgICAgICAgICAgICAgICBhZXN0aGV0aWNzW2ldID0gYWVzO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgYnVpbGRMZWdlbmQoKSB7XHJcbiAgICAgICAgY29uc3QgbWFwQ2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYG1hcENhbnZhcyR7dGhpcy5pZH1gKTtcclxuICAgICAgICBjb25zdCBsZWdlbmREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBsZWdlbmREaXYuaWQgPSBgbGVnZW5kRGl2JHt0aGlzLmlkfWA7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3doaXRlJztcclxuICAgICAgICAvL2xlZ2VuZERpdi5zdHlsZS5oZWlnaHQgPSAyMDA7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUud2lkdGggPSAyNTA7Ly8obWFwQ2FudmFzLndpZHRoIC8gMTApO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3R0b20gPSAyMDtcclxuICAgICAgICBsZWdlbmREaXYuc3R5bGUucmlnaHQgPSAwO1xyXG4gICAgICAgIGxlZ2VuZERpdi5zdHlsZS5ib3JkZXJDb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgbGVnZW5kRGl2LnN0eWxlLmJvcmRlciA9ICdzb2xpZCc7XHJcblxyXG4gICAgICAgIGNvbnN0IHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcclxuICAgICAgICBjb25zdCB0aHZhbHVlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICBjb25zdCB0aGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGgnKTtcclxuICAgICAgICAvL3RodmFsdWUuc3R5bGUud2lkdGggPSAxMjU7XHJcbiAgICAgICAgdGFibGUuc3R5bGUuekluZGV4ID0gXCIyMDAwXCI7XHJcbiAgICAgICAgdGhjb2xvci5zdHlsZS53aWR0aCA9IDEwMDtcclxuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0aGNvbG9yKTtcclxuICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZCh0aHZhbHVlKTtcclxuXHJcblxyXG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudGFlcyBvZiB0aGlzLmFlc3RoZXRpY3MpIHtcclxuICAgICAgICAgICAgLy9pZihjdXJyZW50YWVzLl9mZWF0dXJlcy5sZW5ndGggPiAwIHx8IGN1cnJlbnRhZXMuX2FsbEZlYXR1cmVzLmxlbmd0aCA+IDApe1xyXG4gICAgICAgICAgICBjb25zdCByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcclxuICAgICAgICAgICAgY29uc3QgcHRleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XHJcbiAgICAgICAgICAgIGxldCB0ZXh0O1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJlbnRhZXMucmFuZ2VbMF0gPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGBbJHtjdXJyZW50YWVzLnJhbmdlWzBdfSwgJHtjdXJyZW50YWVzLnJhbmdlWzFdfVtgKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgdGV4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGN1cnJlbnRhZXMucmFuZ2VbMF0pO1xyXG4gICAgICAgICAgICBwdGV4dC5hcHBlbmRDaGlsZCh0ZXh0KTtcclxuICAgICAgICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQocHRleHQpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgY29sb3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xyXG4gICAgICAgICAgICBjb25zdCByZ2JjID0gYHJnYmEoJHtjdXJyZW50YWVzLmZpbGxDb2xvclswXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsxXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclsyXX0sJHtjdXJyZW50YWVzLmZpbGxDb2xvclszXX0pYDtcclxuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhyZ2JjKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGVbJ2JhY2tncm91bmRDb2xvciddID0gcmdiYztcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUuaGVpZ2h0ID0gMjU7Ly8obWFwQ2FudmFzLmhlaWdodCAvIDEwKTtcclxuICAgICAgICAgICAgY29sb3JEaXYuc3R5bGUud2lkdGggPSA4MDsvLyhtYXBDYW52YXMud2lkdGggLyAxMCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbG9yLmFwcGVuZENoaWxkKGNvbG9yRGl2KTtcclxuXHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChjb2xvcik7XHJcbiAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh2YWx1ZSk7XHJcblxyXG4gICAgICAgICAgICB0YWJsZS5hcHBlbmRDaGlsZChyb3cpO1xyXG4gICAgICAgICAgICAvL31cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGxlZ2VuZERpdi5hcHBlbmRDaGlsZCh0YWJsZSk7XHJcbiAgICAgICAgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkuYXBwZW5kQ2hpbGQobGVnZW5kRGl2KTtcclxuICAgIH1cclxuXHJcbiAgICBwcmVQcm9jZXNzRGF0YShnZW9qc29uLCBudW1iZXJPZiwgYWxnb3JpdGhtLCBjb2xvcnNjaGVtZSkge1xyXG5cclxuICAgICAgICBjb25zdCBhZXNhcnJheSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSBbXTtcclxuICAgICAgICBsZXQgYnJlYWtzO1xyXG4gICAgICAgIGxldCBmY29sb3I7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgaWYgKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdICE9IG51bGwgJiYgdHlwZW9mIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdID09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1pbiA9IE1hdGgubWluKHRoaXMubWluLCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5hdHRyXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgaWYgKCFzdHJpbmdzLmluY2x1ZGVzKGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLmF0dHJdKSlcclxuICAgICAgICAgICAgICAgICAgICBzdHJpbmdzLnB1c2goZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuYXR0cl0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHsvL3F1YW50aXRhdGl2ZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5icmVha3MgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobnVtYmVyT2YgPiAxKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrcyA9IHRoaXMuY2FsY0NsYXNzQnJlYWtzKHZhbHVlcywgYWxnb3JpdGhtLCBudW1iZXJPZik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWtzID0gW3RoaXMubWluLCB0aGlzLm1heF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSB0aGlzLmJyZWFrcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoYnJlYWtzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnJlYWtzLmxlbmd0aCAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IGNocm9tYShmY29sb3JbaV0pLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpICE9IGJyZWFrcy5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbaV0sIGJyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZXMgPSBuZXcgQWVzdGhldGljKGksIHRoaXMuYXR0ciwgW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdLCBbMCwgMCwgMCwgMV0sIG51bGwsIFticmVha3NbaV0sIGJyZWFrc1tpICsgMV1dKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBjaHJvbWEoY29sb3JzY2hlbWVbMF0pLnJnYigpO1xyXG4gICAgICAgICAgICAgICAgdmFyIGFlcyA9IG5ldyBBZXN0aGV0aWMoaSwgdGhpcy5hdHRyLCBbTWF0aC5yb3VuZChjb2xvclswXSksIE1hdGgucm91bmQoY29sb3JbMV0pLCBNYXRoLnJvdW5kKGNvbG9yWzJdKSwgdGhpcy5hbHBoYV0sIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1swXSwgYnJlYWtzWzFdXSk7XHJcbiAgICAgICAgICAgICAgICBhZXMub3V0ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgYWVzYXJyYXkucHVzaChhZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlbHNlIHsvL3F1YWxpdGF0aXZlXHJcbiAgICAgICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrcyA9IHN0cmluZ3M7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbG9yc2NoZW1lID09PSAnc3RyaW5nJykgey8vc3RyaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKS5jb2xvcnMoYnJlYWtzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHsgLy9hcnJheVxyXG4gICAgICAgICAgICAgICAgICAgIGZjb2xvciA9IGNocm9tYS5zY2FsZShjb2xvcnNjaGVtZSkuY29sb3JzKGJyZWFrcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmVha3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29sb3IgPSBjaHJvbWEoZmNvbG9yW2ldKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYWVzID0gbmV3IEFlc3RoZXRpYyhpLCB0aGlzLmF0dHIsIFtNYXRoLnJvdW5kKGNvbG9yWzBdKSwgTWF0aC5yb3VuZChjb2xvclsxXSksIE1hdGgucm91bmQoY29sb3JbMl0pLCAxXSwgWzAsIDAsIDAsIDFdLCBudWxsLCBbc3RyaW5nc1tpXV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGFlc2FycmF5LnB1c2goYWVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gYWVzYXJyYXk7XHJcbiAgICAgICAgLy9yZXR1cm4gYWVzYXJyYXk7XHJcbiAgICB9XHJcblxyXG4gICAgY2FsY0NsYXNzQnJlYWtzKHZhbHVlcywgYWxnb3JpdGhtLCBudW1iZXJPZikge1xyXG4gICAgICAgIGxldCBicmVha3M7XHJcbiAgICAgICAgc3dpdGNoIChhbGdvcml0aG0pIHtcclxuICAgICAgICAgICAgY2FzZSAnZXF1aWRpc3RhbnQnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdlJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBjYXNlICdxdWFudGlsZSc6XHJcbiAgICAgICAgICAgICAgICBicmVha3MgPSBjaHJvbWEubGltaXRzKHZhbHVlcywgJ3EnLCBudW1iZXJPZik7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgIGNhc2UgJ2stbWVhbnMnOlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdrJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWtzID0gY2hyb21hLmxpbWl0cyh2YWx1ZXMsICdxJywgbnVtYmVyT2YpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBicmVha3M7XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICBsZXQgZmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uY2hlY2tQcm9wZXJ0eShwcm9wZXJ0aWVzW3RoaXMuYWVzdGhldGljc1tpXS5nZXRBdHRyKCldKSA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFlc3RoZXRpY3NbaV0uYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpO1xyXG4gICAgICAgICAgICAgICAgZmxhZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFmbGFnKSB7XHJcbiAgICAgICAgICAgIC8vVE9ET1xyXG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiVE9ETzogZmVhdHVyZSBkb2VzIG5vdCBmaXQgaW50byBhbnkgb2YgdGhlIGFlc3RoZXRpY3MgZGVmaW5lZC5cXG4gVmFsdWU6IFwiICsgcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5zZXJ0R3JvdXBlZEZlYXR1cmUoaWRhZXMsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSB7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzW2lkYWVzXS5hZGRHcm91cGVkRmVhdHVyZShudWxsLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cyk7XHJcbiAgICB9XHJcblxyXG4gICAgZHJhdygpIHtcclxuICAgICAgICBhbGVydChcImRyYXcoKSBub3QgaW1wbGVtZW50ZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcHJvY2Vzc1BvbHlnb24ocG9seWdvbikge1xyXG5cclxuICAgICAgICBpZiAocG9seWdvbi5nZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiKSB7XHJcbiAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XHJcblxyXG4gICAgICAgICAgICB2YXIgaW5zaWRlcG9seWdvbnMgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDE7IGsgPCBwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aDsgaysrKSB7XHJcbiAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgIC8vaW5zaWRlcG9seWdvbnMucHVzaChwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2tdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgdGVtcFZlcnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICB0ZW1wVmVydHMucHVzaChvdXRzaWRlcG9seWdvbltvdXRdWzBdLCBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIF92ZXJ0ZXhjb3VudCArPSAob3V0c2lkZXBvbHlnb24ubGVuZ3RoICsgMSkgLyAyO1xyXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcImxvbjogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzBdICsgXCIgbGF0OiBcIiArIG91dHNpZGVwb2x5Z29uW291dF1bMV0pO1xyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG4gICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICBwb2x5YXJyYXkucHVzaCh7IHRyaWFuZ2xlczogdHJpYW5nbGVzX3ZlcnQsIHZlcnRleDogdGVtcFZlcnRzIH0pO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICBlbHNlIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB2YXIgcG9seWFycmF5ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBvdXRzaWRlcG9seWdvbiA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1bMF07XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGluc2lkZXBvbHlnb25zID0gW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMTsgayA8IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAvL3RvZG8gaW5zaWRlIHBvbHlnb25cclxuICAgICAgICAgICAgICAgICAgICBpbnNpZGVwb2x5Z29ucy5wdXNoKHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV1ba10pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFyIHRlbXBWZXJ0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICAgICAgX3ZlcnRleGNvdW50ICs9IG91dHNpZGVwb2x5Z29uLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIG91dCA9IDA7IG91dCA8IG91dHNpZGVwb2x5Z29uLmxlbmd0aCAtIDE7IG91dCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFZlcnRzLnB1c2gob3V0c2lkZXBvbHlnb25bb3V0XVswXSwgb3V0c2lkZXBvbHlnb25bb3V0XVsxXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJsb246IFwiICsgb3V0c2lkZXBvbHlnb25bb3V0XVswXSArIFwiIGxhdDogXCIgKyBvdXRzaWRlcG9seWdvbltvdXRdWzFdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIHZhciB0cmlhbmdsZXNfdmVydCA9IGVhcmN1dCh0ZW1wVmVydHMpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vdmFyIHRlbXAgPSBlYXJjdXQuZmxhdHRlbihwb2x5Z29uLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldKTtcclxuICAgICAgICAgICAgICAgIC8vdmFyIHRyaWFuZ2xlc192ZXJ0ID0gZWFyY3V0KHRlbXAudmVydGljZXMsIHRlbXAuaG9sZXMsIHRlbXAuZGltZW5zaW9ucyk7XHJcbiAgICAgICAgICAgICAgICBfdHJpY291bnQgKz0gKHRyaWFuZ2xlc192ZXJ0Lmxlbmd0aCAvIDMpO1xyXG4gICAgICAgICAgICAgICAgcG9seWFycmF5LnB1c2goeyB0cmlhbmdsZXM6IHRyaWFuZ2xlc192ZXJ0LCB2ZXJ0ZXg6IHRlbXBWZXJ0cyB9KTtcclxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cocG9seWFycmF5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBwb2x5YXJyYXk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH1cclxuXHJcbiAgICBwcm9jZXNzRGF0YShnZW9qc29uKSB7XHJcbiAgICAgICAgdGhpcy5sb2FkR2VvSlNPTihnZW9qc29uKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVBbmRJbnNlcnRGZWF0dXJlKGlkLCBnZW9tZXRyeSwgcHJvcGVydGllcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKHRoaXMubWludWVuZCAhPSB1bmRlZmluZWQgJiYgdGhpcy5zdWJ0cmFoZW5kICE9IHVuZGVmaW5lZCAmJiB0eXBlb2YgcHJvcGVydGllc1t0aGlzLm1pbnVlbmRdID09ICdudW1iZXInXHJcbiAgICAgICAgICAgICYmIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSB1bmRlZmluZWQgJiYgdHlwZW9mIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAmJiBwcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0gIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHByb3BlcnRpZXNbdGhpcy5hdHRyXSA9IHByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAtIHByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09IFwiUG9seWdvblwiIHx8IGdlb21ldHJ5LnR5cGUgPT0gXCJNdWx0aVBvbHlnb25cIikge1xyXG4gICAgICAgICAgICB0aGlzLmhhc1BvbHlnb25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3QgcG9seWdvbnMgPSB0aGlzLnByb2Nlc3NQb2x5Z29uKHsgZ2VvbWV0cnksIHByb3BlcnRpZXMgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Qm9yZGVycyA9IFtdO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VHJpYW5nbGVzID0gW107XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1ZmZlclQgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYnVmZmVyQiA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwb2x5Z29ucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdHJpYW5nbGVzcG9seWdvbiA9IHBvbHlnb25zW2pdLnRyaWFuZ2xlcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvcmRlciA9IHBvbHlnb25zW2pdLnZlcnRleDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmlhbmdsZXNbal0gPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2pdID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBoID0gMDsgaCA8IHRyaWFuZ2xlc3BvbHlnb24ubGVuZ3RoOyBoKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoYm9yZGVyW3RyaWFuZ2xlc3BvbHlnb25baF0gKiAyXSwgYm9yZGVyW3RyaWFuZ2xlc3BvbHlnb25baF0gKiAyICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRUcmlhbmdsZXNbal0ucHVzaChwaXhlbC54LCBwaXhlbC55KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPT0gdHJpYW5nbGVzcG9seWdvbi5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclQucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50VHJpYW5nbGVzW2pdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyVFtqXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlclRbal0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJUW2pdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGJvcmRlci5sZW5ndGg7IHkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShib3JkZXJbeV0sIGJvcmRlclt5ICsgMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCb3JkZXJzW2pdLnB1c2gocGl4ZWwueCwgcGl4ZWwueSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh5ID09IGJvcmRlci5sZW5ndGggLSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckIucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50Qm9yZGVyc1tqXSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5mc2l6ZSA9IHZlcnRBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlckJbal0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdmVydEFycmF5LCBnbC5TVEFUSUNfRFJBVyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJCW2pdLml0ZW1TaXplID0gMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyQltqXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy9wb2x5Z29uXHJcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0RmVhdHVyZShpZCwgcHJvcGVydGllcywgYnVmZmVyVCwgYnVmZmVyQiwgW10pO1xyXG5cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT0gXCJQb2ludFwiICYmIHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIC8vZHVtXHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgICAgICB2YXIgcGl4ZWwgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcclxuICAgICAgICAgICAgY3VycmVudFBvaW50c1swXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG4gICAgICAgICAgICBjb25zdCBidWZmZXJQID0gW107XHJcbiAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgdmVydEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShjdXJyZW50UG9pbnRzWzBdKTtcclxuXHJcbiAgICAgICAgICAgIGdsLmZzaXplID0gdmVydEFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyUFswXSk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgIGJ1ZmZlclBbMF0uaXRlbVNpemUgPSAyO1xyXG4gICAgICAgICAgICBidWZmZXJQWzBdLm51bUl0ZW1zID0gdmVydEFycmF5Lmxlbmd0aCAvIDI7XHJcblxyXG4gICAgICAgICAgICB0aGlzLmluc2VydEZlYXR1cmUoaWQsIHByb3BlcnRpZXMsIFtdLCBbXSwgYnVmZmVyUCk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzID09IG51bGwgfHwgdGhpcy50cmVlcG9pbnRzID09IHVuZGVmaW5lZCkgdGhpcy50cmVlcG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMudHJlZXBvaW50cy5wdXNoKHsgbG9uOiBnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgbGF0OiBnZW9tZXRyeS5jb29yZGluYXRlc1sxXSwgcHJvcGVydGllcyB9KTtcclxuXHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PSBcIlBvaW50XCIgJiYgdGhpcy5keW5hbWljID09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIC8vZGVidWdnZXI7XHJcbiAgICAgICAgICAgIHZhciBwaXhlbCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWShnZW9tZXRyeS5jb29yZGluYXRlc1swXSwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0pO1xyXG4gICAgICAgICAgICBpZiAodGhpcy50ZW1wUG9pbnRzID09IG51bGwgfHwgdGhpcy50ZW1wUG9pbnRzID09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50ZW1wUG9pbnRzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGErKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGVtcFBvaW50c1thXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhZXNhcnJheXMgPSB0aGlzLmZpdEZlYXR1cmUocHJvcGVydGllcyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgYWVzYXJyYXlzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRlbXBQb2ludHNbYWVzYXJyYXlzW3ldXS5wdXNoKHBpeGVsLngsIHBpeGVsLnkpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy50cmVlcG9pbnRzID09IG51bGwpIHRoaXMudHJlZXBvaW50cyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLnRyZWVwb2ludHMucHVzaCh7IGxvbjogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGxhdDogZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sIHByb3BlcnRpZXMgfSk7XHJcblxyXG5cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBidWlsZFRyZWVzKGdlb2pzb24pIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmICh0aGlzLnRlbXBQb2ludHMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMudGVtcFBvaW50cy5sZW5ndGg7IHQrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGVtcFBvaW50c1t0XS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyUCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclAucHVzaChnbC5jcmVhdGVCdWZmZXIoKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy50ZW1wUG9pbnRzW3RdKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuZnNpemUgPSB2ZXJ0QXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlclBbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5pdGVtU2l6ZSA9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyUFswXS5udW1JdGVtcyA9IHZlcnRBcnJheS5sZW5ndGggLyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0R3JvdXBlZEZlYXR1cmUodCwgW10sIFtdLCBidWZmZXJQKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhnZW9qc29uKVxyXG4gICAgICAgIGlmICh0aGlzLnRyZWVwb2ludHMgIT0gbnVsbClcclxuICAgICAgICAgICAgdGhpcy5rZHRyZWUgPSBuZXcga2RUcmVlKHRoaXMudHJlZXBvaW50cywgKGEsIGIpID0+IChhLmxvbiAtIGIubG9uKSAqKiAyICsgKGEubGF0IC0gYi5sYXQpICoqIDIsIFtcImxvblwiLCBcImxhdFwiLCBcInByb3BlcnRpZXNcIl0pO1xyXG4gICAgICAgIGlmICh0aGlzLmhhc1BvbHlnb25zID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMucnRyZWUgPSBuZXcgUG9seWdvbkxvb2t1cChnZW9qc29uKTsvL2NvbnNvbGUubG9nKFwiQFJ1aSBMT09LIEkgV0FTIFJFTU9WRURcIik7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZEdlb0pTT04oZ2VvanNvbikge1xyXG4gICAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggJiYgKHRoaXMubWF4ZmVhdHVyZXMgPT0gdW5kZWZpbmVkIHx8IGcgPCB0aGlzLm1heGZlYXR1cmVzKTsgZysrKSB7XHJcbiAgICAgICAgICAgIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1snX2dpc3BsYXlpZCddID0gZztcclxuICAgICAgICAgICAgY29uc3QgZ2VvbWV0cnkgPSBnZW9qc29uLmZlYXR1cmVzW2ddLmdlb21ldHJ5O1xyXG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzO1xyXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZEluc2VydEZlYXR1cmUoZywgZ2VvbWV0cnksIHByb3BlcnRpZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmJ1aWxkVHJlZXMoZ2VvanNvbik7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIGNyZWF0ZUNhbnZhcygpIHtcclxuICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLm1hcC5jcmVhdGVDYW52YXModGhpcy5pZCk7XHJcblxyXG4gICAgICAgIC8vaW5pdCB3ZWJnbCBwcm9wZXJ0aWVzXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wgPSB7XHJcbiAgICAgICAgICAgIGdsOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9ncmFtOiBudWxsLFxyXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiBudWxsXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIpO1xyXG4gICAgICAgIHRoaXMuX3dlYmdsLnByb2plY3Rpb24gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5wcm9qZWN0aW9uLnNldChbMiAvIGNhbnZhcy53aWR0aCwgMCwgMCwgMCwgMCwgLTIgLyBjYW52YXMuaGVpZ2h0LCAwLCAwLCAwLCAwLCAwLCAwLCAtMSwgMSwgMCwgMV0pO1xyXG5cclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLm1hcC5nZXRDb250YWluZXIoKS5vZmZzZXRXaWR0aCwgdGhpcy5tYXAuZ2V0Q29udGFpbmVyKCkub2Zmc2V0SGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl93ZWJnbC5nbC5kaXNhYmxlKHRoaXMuX3dlYmdsLmdsLkRFUFRIX1RFU1QpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldE51bWJlck9mRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvdW50O1xyXG4gICAgfVxyXG5cclxuICAgIHNjYWxlUHJvamVjdGlvbihtYXRyaXgsIHNjYWxlWCwgc2NhbGVZKSB7XHJcbiAgICAgICAgLy8gc2NhbGluZyB4IGFuZCB5LCB3aGljaCBpcyBqdXN0IHNjYWxpbmcgZmlyc3QgdHdvIHJvd3Mgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzBdICo9IHNjYWxlWDtcclxuICAgICAgICBtYXRyaXhbMV0gKj0gc2NhbGVYO1xyXG4gICAgICAgIG1hdHJpeFsyXSAqPSBzY2FsZVg7XHJcbiAgICAgICAgbWF0cml4WzNdICo9IHNjYWxlWDtcclxuXHJcbiAgICAgICAgbWF0cml4WzRdICo9IHNjYWxlWTtcclxuICAgICAgICBtYXRyaXhbNV0gKj0gc2NhbGVZO1xyXG4gICAgICAgIG1hdHJpeFs2XSAqPSBzY2FsZVk7XHJcbiAgICAgICAgbWF0cml4WzddICo9IHNjYWxlWTtcclxuICAgIH1cclxuXHJcbiAgICB0cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeCwgdHgsIHR5KSB7XHJcbiAgICAgICAgLy8gdHJhbnNsYXRpb24gaXMgaW4gbGFzdCByb3cgb2YgbWF0cml4XHJcbiAgICAgICAgbWF0cml4WzEyXSArPSBtYXRyaXhbMF0gKiB0eCArIG1hdHJpeFs0XSAqIHR5O1xyXG4gICAgICAgIG1hdHJpeFsxM10gKz0gbWF0cml4WzFdICogdHggKyBtYXRyaXhbNV0gKiB0eTtcclxuICAgICAgICBtYXRyaXhbMTRdICs9IG1hdHJpeFsyXSAqIHR4ICsgbWF0cml4WzZdICogdHk7XHJcbiAgICAgICAgbWF0cml4WzE1XSArPSBtYXRyaXhbM10gKiB0eCArIG1hdHJpeFs3XSAqIHR5O1xyXG4gICAgfVxyXG5cclxuICAgIGxhdExvbmdUb1BpeGVsWFkobG9uZ2l0dWRlLCBsYXRpdHVkZSkge1xyXG4gICAgICAgIGNvbnN0IHBpXzE4MCA9IE1hdGguUEkgLyAxODAuMDtcclxuICAgICAgICBjb25zdCBwaV80ID0gTWF0aC5QSSAqIDQ7XHJcbiAgICAgICAgY29uc3Qgc2luTGF0aXR1ZGUgPSBNYXRoLnNpbihsYXRpdHVkZSAqIHBpXzE4MCk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxZID0gKDAuNSAtIE1hdGgubG9nKCgxICsgc2luTGF0aXR1ZGUpIC8gKDEgLSBzaW5MYXRpdHVkZSkpIC8gKHBpXzQpKSAqIDI1NjtcclxuICAgICAgICBjb25zdCBwaXhlbFggPSAoKGxvbmdpdHVkZSArIDE4MCkgLyAzNjApICogMjU2O1xyXG5cclxuICAgICAgICBjb25zdCBwaXhlbCA9IHsgeDogcGl4ZWxYLCB5OiBwaXhlbFkgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHBpeGVsO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3VHJpYW5nbGVzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9mZWF0dXJlc1tpXS5fdHJpYW5nbGVzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdCb3JkZXJzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IHRoaXMubWFwLmdldFpvb20oKTtcclxuICAgICAgICBjb25zdCBwb2ludFNpemUgPSBNYXRoLm1heChjdXJyZW50Wm9vbSAtIDUuMCwgMS4wKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAwLjApO1xyXG5cclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuc3Ryb2tlQ29sb3JbMF0gLyAyNTUsIGFlcy5zdHJva2VDb2xvclsxXSAvIDI1NSwgYWVzLnN0cm9rZUNvbG9yWzJdIC8gMjU1LCBhZXMuc3Ryb2tlQ29sb3JbM10pO1xyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBhZXMuX2ZlYXR1cmVzW2ldLl9ib3JkZXJzLmxlbmd0aDsgeSsrKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FX0xPT1AsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX2JvcmRlcnNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICB9XHJcblxyXG4gICAgZHJhd1BvaW50cyhhZXMpIHtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG5cclxuICAgICAgICAvL2dsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIC8vZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcclxuXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSB0aGlzLm1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA0LjAgKyBhZXMucG9pbnRTaXplLCBhZXMucG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAndmVydGV4Q29vcmQnKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvbG9yTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgXCJ1X2NvbG9yXCIpO1xyXG5cclxuICAgICAgICBjb25zdCBpc1BvaW50TG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2lzUG9pbnQnKTtcclxuICAgICAgICBnbC51bmlmb3JtMWYoaXNQb2ludExvY2F0aW9uLCAxLjApO1xyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIGFlcy5maWxsQ29sb3JbMF0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMV0gLyAyNTUsIGFlcy5maWxsQ29sb3JbMl0gLyAyNTUsIGFlcy5maWxsQ29sb3JbM10pO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWVzLl9mZWF0dXJlcy5sZW5ndGggJiYgdGhpcy5keW5hbWljID09IHRydWU7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50cy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5QT0lOVFMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3BvaW50c1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgICAgICAvLzEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuZHluYW1pYyA9PSBmYWxzZSAmJiBhZXMuX2FsbEZlYXR1cmVzICE9IG51bGwgJiYgaSA8IGFlcy5fYWxsRmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHMubGVuZ3RoOyB5KyspIHtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYWVzLl9hbGxGZWF0dXJlc1tpXS5fcG9pbnRzW3ldKTtcclxuXHJcbiAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnRleENvbG9yTG9jYXRpb24sIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA2LCBmc2l6ZSAqIDIpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0ZXhDb2xvckxvY2F0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgLy9nbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFX1NUUklQLCAwLCBhZXMuX2FsbEZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMtMik7XHRcclxuICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgfVxyXG5cclxuICAgIGRyYXdDb250aW51b3VzUG9seWdvbnMoYWVzKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcbiAgICAgICAgaWYgKGdsID09IG51bGwpIHJldHVybjtcclxuICAgICAgICBjb25zdCBtYXRyaXhQcm9qZWN0aW9uID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcblxyXG4gICAgICAgIC8vZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy9nbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xyXG5cclxuICAgICAgICAvL2dsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgLy9nbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNS4wLCAxLjApO1xyXG5cclxuICAgICAgICBtYXRyaXhQcm9qZWN0aW9uLnNldCh0aGlzLl93ZWJnbC5wcm9qZWN0aW9uKTtcclxuXHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAyICoqIGN1cnJlbnRab29tO1xyXG4gICAgICAgIHRoaXMuc2NhbGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIHNjYWxlLCBzY2FsZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMubGF0TG9uZ1RvUGl4ZWxYWSh0aGlzLm1hcC5nZXRMbmdCb3VuZCgpLCB0aGlzLm1hcC5nZXRMYXRCb3VuZCgpKTtcclxuICAgICAgICB0aGlzLnRyYW5zbGF0ZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3Byb2plY3Rpb24nKTtcclxuICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHByb2plY3Rpb25Mb2NhdGlvbiwgZmFsc2UsIG1hdHJpeFByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaXplTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5wcm9ncmFtLCAnYVBvaW50U2l6ZScpO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYjFmKHZlcnRleFNpemVMb2NhdGlvbiwgcG9pbnRTaXplKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMC4wKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKiogXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogIERyYXcgUG9seWdvbnMnIEludGVyaW9yXHJcbiAgICAgICAgICogICoqL1xyXG4gICAgICAgIGNvbnN0IGZzaXplID0gRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOdW1lcm8gZGUgQnVmZmVyczogXCIsIGJ1ZmZlcnMubGVuZ3RoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFlcy5fZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IHVjb2xvcjtcclxuICAgICAgICAgICAgbGV0IGNvbG9yO1xyXG4gICAgICAgICAgICBjb25zdCBkaWZmID0gYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdO1xyXG4gICAgICAgICAgICBpZiAoZGlmZiA9PSAwKVxyXG4gICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSkucmdiKCk7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBhZXMuZmlsbENvbG9yKDAuNSArIGRpZmYgLyB0aGlzLm1heCAvIDIpLnJnYigpO1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yID0gYWVzLmZpbGxDb2xvcigwLjUgLSBkaWZmIC8gdGhpcy5taW4gLyAyKS5yZ2IoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdWNvbG9yID0gW01hdGgucm91bmQoY29sb3JbMF0pLCBNYXRoLnJvdW5kKGNvbG9yWzFdKSwgTWF0aC5yb3VuZChjb2xvclsyXSksIHRoaXMuYWxwaGFdO1xyXG5cclxuICAgICAgICAgICAgZ2wudW5pZm9ybTRmKHZlcnRleENvbG9yTG9jYXRpb24sIHVjb2xvclswXSAvIDI1NSwgdWNvbG9yWzFdIC8gMjU1LCB1Y29sb3JbMl0gLyAyNTUsIHRoaXMuYWxwaGEpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlcy5sZW5ndGg7IHkrKykge1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl90cmlhbmdsZXNbeV0pO1xyXG5cclxuICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogMiwgMCk7XHJcbiAgICAgICAgICAgICAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29sb3JMb2NhdGlvbiwgNCwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDYsIGZzaXplICogMik7XHJcbiAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGFlcy5fZmVhdHVyZXNbaV0uX3RyaWFuZ2xlc1t5XS5udW1JdGVtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH1cclxuXHJcbiAgICBkcmF3UHJvcG9yY2lvbmFsUG9pbnRzKGFlcykge1xyXG5cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX3dlYmdsLmdsO1xyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuXHJcblxyXG4gICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XHJcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRab29tID0gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHJcbiAgICAgICAgbWF0cml4UHJvamVjdGlvbi5zZXQodGhpcy5fd2ViZ2wucHJvamVjdGlvbik7XHJcblxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gMiAqKiBjdXJyZW50Wm9vbTtcclxuICAgICAgICB0aGlzLnNjYWxlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCBzY2FsZSwgc2NhbGUpO1xyXG5cclxuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLmxhdExvbmdUb1BpeGVsWFkodGhpcy5tYXAuZ2V0TG5nQm91bmQoKSwgdGhpcy5tYXAuZ2V0TGF0Qm91bmQoKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2xhdGVQcm9qZWN0aW9uKG1hdHJpeFByb2plY3Rpb24sIC1vZmZzZXQueCwgLW9mZnNldC55KTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJvamVjdGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb29yZExvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ3ZlcnRleENvb3JkJyk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCB2ZXJ0ZXhDb2xvckxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sIFwidV9jb2xvclwiKTtcclxuXHJcbiAgICAgICAgY29uc3QgaXNQb2ludExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMuX3dlYmdsLnByb2dyYW0sICdpc1BvaW50Jyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybTFmKGlzUG9pbnRMb2NhdGlvbiwgMS4wKTtcclxuXHJcbiAgICAgICAgLyoqIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqICBEcmF3IFBvbHlnb25zJyBJbnRlcmlvclxyXG4gICAgICAgICAqICAqKi9cclxuICAgICAgICBjb25zdCBmc2l6ZSA9IEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiTnVtZXJvIGRlIEJ1ZmZlcnM6IFwiLCBidWZmZXJzLmxlbmd0aCk7XHJcblxyXG4gICAgICAgIGdsLnVuaWZvcm00Zih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCBhZXMuZmlsbENvbG9yWzBdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzFdIC8gMjU1LCBhZXMuZmlsbENvbG9yWzJdIC8gMjU1LCB0aGlzLmFscGhhKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pYyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgaSBpbiBhZXMuX2ZlYXR1cmVzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHkgaW4gYWVzLl9mZWF0dXJlc1tpXS5fcG9pbnRzKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3B2YWx1ZSA9IHBhcnNlRmxvYXQoYWVzLl9mZWF0dXJlc1tpXS5fcHJvcGVydGllc1t0aGlzLmF0dHJdKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wcG9pbnRzaXplID0gKCh0aGlzLm1heHBvaW50c2l6ZSAtIHRoaXMubWlucG9pbnRzaXplKSAvICh0aGlzLm1heCAtIHRoaXMubWluKSkgKiAocHJvcHZhbHVlIC0gdGhpcy5taW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50U2l6ZSA9IE1hdGgubWF4KGN1cnJlbnRab29tIC0gNC4wICsgdGVtcHBvaW50c2l6ZSAqIGN1cnJlbnRab29tIC8gNCwgMik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVydGV4U2l6ZUxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wucHJvZ3JhbSwgJ2FQb2ludFNpemUnKTtcclxuICAgICAgICAgICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDIsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcih2ZXJ0ZXhDb2xvckxvY2F0aW9uLCA0LCBnbC5GTE9BVCwgZmFsc2UsIGZzaXplICogNiwgZnNpemUgKiAyKTtcclxuICAgICAgICAgICAgICAgICAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvbG9yTG9jYXRpb24pO1xyXG5cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCBhZXMuX2ZlYXR1cmVzW2ldLl9wb2ludHNbeV0ubnVtSXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLm1heCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5taW4gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY3JlYXRlQ2FudmFzKCk7XHJcbiAgICAgICAgdGhpcy5wcm9ncmFtKCk7XHJcbiAgICAgICAgbGV0IG1hcHBvcztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgICAgIGlmIChtYXBzW2ldLmlkID09IHRoaXMuaWQpXHJcbiAgICAgICAgICAgICAgICBtYXBwb3MgPSBpO1xyXG4gICAgICAgIHRoaXMubWFwLm9uRXZlbnQoJ21vdmUnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQFJ1aTogbXVkYXIgbyBwcm9maWxpbmcgZG8gd2luZG93IHBhcmEgb3V0cmEgY29pc2E/XCIpXHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBtYXBzW21hcHBvc10uZHJhdygpO1xyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIFpvb20vUGFuIChzZWd1bmRvcyk6JHsoZW5kIC0gc3RhcnQpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0aGlzLnNldHVwT25jbGljayhtYXBwb3MpO1xyXG4gICAgfVxyXG5cclxuICAgIHNldHVwT25jbGljayhtYXBwb3MpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkBSdWk6IHByb2ZpbGluZyBtdWRhciBkZSB3aW5kb3cgcGFyYT8gfCBSdHJlZSBlIEtkVHJlZVwiKVxyXG4gICAgICAgIG1hcHNbbWFwcG9zXS5tYXAub25FdmVudCgnY2xpY2snLCBlID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGxhdCA9IGUubGF0bG5nLmxhdDtcclxuICAgICAgICAgICAgY29uc3QgbG9uID0gZS5sYXRsbmcubG5nO1xyXG5cclxuICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5ydHJlZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBib29sID0gbWFwc1swXS5ydHJlZS5zZWFyY2gobG9uLCBsYXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvb2wgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2dcclxuICAgICAgICAgICAgICAgICAgICB2YXIgcyA9IFwiXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZpcnN0ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljayAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGljay5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7bWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpICsgMV19OiAke2Jvb2wucHJvcGVydGllc1ttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYm9vbC5wcm9wZXJ0aWVzKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleXNbaV0gIT0gXCJfZ2lzcGxheWlkXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgKz0gYFxcbiR7a2V5c1tpXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW2tleXNbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uaW50ZXJhY3RpdmUgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQocyk7Ly90b2RvXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbCAhPSB1bmRlZmluZWQgJiYgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHNbbWFwcG9zXS5tYXBPbkNsaWNrQ2FsbChib29sKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLmtkdHJlZSAhPSB1bmRlZmluZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZWFyZXN0ID0gbWFwc1ttYXBwb3NdLmtkdHJlZS5uZWFyZXN0KHsgbGF0LCBsb24gfSwgMSwgMTI4IC8gKCgyICoqIChtYXAuZ2V0Wm9vbSgpICogMikpKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmVhcmVzdC5sZW5ndGggPD0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYm9vbCA9IG5lYXJlc3RbMF1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZ1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBzID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3QpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaSArIDFdfTogJHtib29sLnByb3BlcnRpZXNbbWFwc1ttYXBwb3NdLnNob3dQcm9wZXJ0aWVzT25DbGlja1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHttYXBzW21hcHBvc10uc2hvd1Byb3BlcnRpZXNPbkNsaWNrW2kgKyAxXX06ICR7Ym9vbC5wcm9wZXJ0aWVzW21hcHNbbWFwcG9zXS5zaG93UHJvcGVydGllc09uQ2xpY2tbaV1dfWA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhib29sLnByb3BlcnRpZXMpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5c1tpXSAhPSBcIl9naXNwbGF5aWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IGAke2tleXNbaV19OiAke2Jvb2wucHJvcGVydGllc1trZXlzW2ldXX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcyArPSBgXFxuJHtrZXlzW2ldfTogJHtib29sLnByb3BlcnRpZXNba2V5c1tpXV19YDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcHNbbWFwcG9zXS5pbnRlcmFjdGl2ZSA9PSB0cnVlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGVydChzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsICE9IHVuZGVmaW5lZCAmJiBtYXBzW21hcHBvc10ubWFwT25DbGlja0NhbGwgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwc1ttYXBwb3NdLm1hcE9uQ2xpY2tDYWxsKGJvb2wpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93LnByb2ZpbGluZyA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGBUZW1wbyBkZSBwcm9jZXNzYW1lbnRvIGRlIHVtIGNsaWNrIChzZWd1bmRvcyk6ICR7KGVuZCAtIHN0YXJ0KSAvIDEwMDB9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgZml0RmVhdHVyZShwcm9wZXJ0aWVzKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBhKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljc1thXS5jaGVja1Byb3BlcnR5KHByb3BlcnRpZXNbdGhpcy5hZXN0aGV0aWNzW2FdLmdldEF0dHIoKV0pID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBsb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCkge1xyXG4gICAgICAgIGlmIChvcHRpb25zLmN1c3RvbU1hcFNlcnZpY2UgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5tYXAgPSBiZ21hcDtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHRoaXMubWFwID0gbmV3IEJHTWFwV3JhcHBlcihiZ21hcCk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVyICE9IGZhbHNlKVxyXG4gICAgICAgICAgICB0aGlzLmxvYWRlcigpO1xyXG5cclxuICAgICAgICBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNob3dQcm9wZXJ0aWVzT25DbGljayA9IG51bGw7XHJcbiAgICAgICAgICAgIC8vYXBwZW5kIG9uIGJnbWFwIG9iamVjdFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnNob3dQcm9wZXJ0aWVzT25DbGljayA9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAvL25hZGFcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2sgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvd1Byb3BlcnRpZXNPbkNsaWNrID0gb3B0aW9ucy5zaG93UHJvcGVydGllc09uQ2xpY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWxwaGEgPSBvcHRpb25zLmFscGhhICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMuYWxwaGEgOiAwLjg7XHJcbiAgICAgICAgdGhpcy5pbnRlcmFjdGl2ZSA9IG9wdGlvbnMuaW50ZXJhY3RpdmUgPT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICFvcHRpb25zLmludGVyYWN0aXZlO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IG9wdGlvbnMuYXR0cjtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLm1lbW9yeVNhdmVyID09IHVuZGVmaW5lZCA/IGZhbHNlIDogIW9wdGlvbnMubWVtb3J5U2F2ZXI7XHJcbiAgICAgICAgdGhpcy5tYXhmZWF0dXJlcyA9IG9wdGlvbnMubWF4RmVhdHVyZXM7XHJcbiAgICAgICAgdGhpcy5icmVha3MgPSBvcHRpb25zLmNsYXNzQnJlYWtzO1xyXG4gICAgICAgIHRoaXMuY29sb3JzY2hlbWUgPSBvcHRpb25zLmNvbG9yU2NoZW1lO1xyXG4gICAgICAgIHRoaXMubnVtYmVyb2ZjbGFzc2VzID0gb3B0aW9ucy5udW1iZXJPZkNsYXNzZXM7XHJcbiAgICAgICAgdGhpcy5hbGdvcml0aG0gPSBvcHRpb25zLmNsYXNzQnJlYWtzTWV0aG9kO1xyXG4gICAgICAgIHRoaXMubGVnZW5kT25DbGlja0NhbGwgPSBvcHRpb25zLmxlZ2VuZE9uQ2xpY2tGdW5jdGlvbjtcclxuICAgICAgICB0aGlzLm1hcE9uQ2xpY2tDYWxsID0gb3B0aW9ucy5tYXBPbkNsaWNrRnVuY3Rpb247XHJcbiAgICAgICAgdGhpcy5taW51ZW5kID0gb3B0aW9ucy5taW51ZW5kO1xyXG4gICAgICAgIHRoaXMuc3VidHJhaGVuZCA9IG9wdGlvbnMuc3VidHJhaGVuZDtcclxuICAgICAgICB0aGlzLmxlZ2VuZFRpdGxlID0gb3B0aW9ucy5sZWdlbmRUaXRsZSAhPSB1bmRlZmluZWQgPyBvcHRpb25zLmxlZ2VuZFRpdGxlIDogKHRoaXMuYXR0ciAhPSB1bmRlZmluZWQgPyB0aGlzLmF0dHIgOiBgJHt0aGlzLm1pbnVlbmR9IC0gJHt0aGlzLnN1YnRyYWhlbmR9YCk7XHJcbiAgICAgICAgdGhpcy5udW1iZXJPZkxlZ2VuZEl0ZW1zID0gb3B0aW9ucy5udW1iZXJPZkxlZ2VuZEl0ZW1zICE9IHVuZGVmaW5lZCA/IG9wdGlvbnMubnVtYmVyT2ZMZWdlbmRJdGVtcyA6IDI7XHJcbiAgICB9XHJcblxyXG4gICAgbG9hZGVyKCkge1xyXG4gICAgICAgIHRoaXMubWFwLmxvYWRlcigpO1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXdIZWF0UG9pbnRzKGFlcykge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fd2ViZ2wuZ2w7XHJcblxyXG4gICAgICAgIGlmIChnbCA9PSBudWxsKSByZXR1cm47XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSk7XHJcbiAgICAgICAgY29uc3QgbWF0cml4UHJvamVjdGlvbiA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG5cclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG5cclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkUpO1xyXG5cclxuICAgICAgICBjb25zdCBjdXJyZW50Wm9vbSA9IG1hcC5nZXRab29tKCk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRTaXplID0gTWF0aC5tYXgoY3VycmVudFpvb20gLSA1LjAsIDEuMCk7XHJcblxyXG4gICAgICAgIG1hdHJpeFByb2plY3Rpb24uc2V0KHRoaXMuX3dlYmdsLnByb2plY3Rpb24pO1xyXG5cclxuICAgICAgICBjb25zdCBzY2FsZSA9IDIgKiogY3VycmVudFpvb207XHJcbiAgICAgICAgdGhpcy5zY2FsZVByb2plY3Rpb24obWF0cml4UHJvamVjdGlvbiwgc2NhbGUsIHNjYWxlKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5sYXRMb25nVG9QaXhlbFhZKHRoaXMubWFwLmdldExuZ0JvdW5kKCksIHRoaXMubWFwLmdldExhdEJvdW5kKCkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNsYXRlUHJvamVjdGlvbihtYXRyaXhQcm9qZWN0aW9uLCAtb2Zmc2V0LngsIC1vZmZzZXQueSk7XHJcblxyXG5cclxuICAgICAgICBjb25zdCBwcm9qZWN0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMF0sICdwcm9qZWN0aW9uJyk7XHJcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdihwcm9qZWN0aW9uTG9jYXRpb24sIGZhbHNlLCBtYXRyaXhQcm9qZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3QgZGVsdGFMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnZGVsdGEnKTtcclxuICAgICAgICBjb25zdCBpbnRlbnNpdHlMb2MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVswXSwgJ2ludGVuc2l0eScpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNpemVMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3dlYmdsLmhlYXRtYXBQcm9ncmFtWzBdLCAnYVBvaW50U2l6ZScpO1xyXG5cclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWIxZih2ZXJ0ZXhTaXplTG9jYXRpb24sIHBvaW50U2l6ZSk7XHJcblxyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHZlcnRleENvb3JkTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGRlbHRhTG9jYXRpb24pO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGludGVuc2l0eUxvYyk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgZnNpemUgPSBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XHJcblxyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBhZXMuX2FsbEZlYXR1cmVzWzBdLl9wb2ludHNbMF0pO1xyXG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCBmc2l6ZSAqIDgsIDAgKiAyKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGRlbHRhTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCAyICogNCk7XHJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihpbnRlbnNpdHlMb2MsIDQsIGdsLkZMT0FULCBmYWxzZSwgZnNpemUgKiA4LCA0ICogNCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgYWVzLl9hbGxGZWF0dXJlc1swXS5fcG9pbnRzWzBdLm51bUl0ZW1zKTtcclxuXHJcblxyXG4gICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0pO1xyXG5cclxuICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcclxuXHJcbiAgICAgICAgLy9jb25zb2xlLmxvZyhcImZhc2UgMSBjb25jbHVpZGFcIik7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke3RoaXMuaWR9YCk7XHJcblxyXG5cclxuXHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cclxuICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzb3VyY2UpO1xyXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY2FudmFzKTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gaXNQb3dlck9mMih2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlICYgKHZhbHVlIC0gMSkpID09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZnVuY3Rpb24gc3RldXBUZXh0dXJlRmlsdGVyaW5nQW5kTWlwcyh3aWR0aCwgaGVpZ2h0LCBnbCkge1xyXG4gICAgICAgICAgICBpZiAoaXNQb3dlck9mMih3aWR0aCkgJiYgaXNQb3dlck9mMihoZWlnaHQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgZGltZW5zaW9ucyBhcmUgcG93ZXIgb2YgMiBzbyBnZW5lcmF0ZSBtaXBzIGFuZCB0dXJuIG9uIFxyXG4gICAgICAgICAgICAgICAgLy8gdHJpLWxpbmVhciBmaWx0ZXJpbmcuXHJcbiAgICAgICAgICAgICAgICBnbC5nZW5lcmF0ZU1pcG1hcChnbC5URVhUVVJFXzJEKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBhdCBsZWFzdCBvbmUgb2YgdGhlIGRpbWVuc2lvbnMgaXMgbm90IGEgcG93ZXIgb2YgMiBzbyBzZXQgdGhlIGZpbHRlcmluZ1xyXG4gICAgICAgICAgICAgICAgLy8gc28gV2ViR0wgd2lsbCByZW5kZXIgaXQuXHJcbiAgICAgICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgICAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcblxyXG4gICAgICAgIHN0ZXVwVGV4dHVyZUZpbHRlcmluZ0FuZE1pcHMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0LCBnbCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XHJcblxyXG4gICAgICAgIGNvbnN0IHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgLTEsIDEsIC0xLCAtMSwgMSwgMSwgLTEsIC0xLCAxLCAtMV0pO1xyXG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xyXG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcpO1xyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uTG9jID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5fd2ViZ2wuaGVhdG1hcFByb2dyYW1bMV0sICdwb3NpdGlvbicpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl93ZWJnbC5oZWF0bWFwUHJvZ3JhbVsxXSwgJ3NvdXJjZScpO1xyXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uTG9jKTtcclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIGdsLnVuaWZvcm0xaShzb3VyY2VMb2MsIDApO1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuXHJcblxyXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvYyk7XHJcbiAgICAgICAgLy9kZWZhdWx0cyB0byBnZW5lcmFsIHByb2dyYW1cclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiZmFzZSAyIGNvbmNsdWlkYVwiKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2wuZ2wudXNlUHJvZ3JhbSh0aGlzLl93ZWJnbC5wcm9ncmFtKTtcclxuICAgIH1cclxuXHJcbiAgICBnZXROdW1iZXJPZlBvbHlnb25zKCkge1xyXG4gICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFlc3RoZXRpY3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeiA9IDA7IHogPCB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzLmxlbmd0aDsgeisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb3VudCArPSB0aGlzLmFlc3RoZXRpY3NbaV0uX2ZlYXR1cmVzW3pdLl90cmlhbmdsZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb3VudDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUNBOzs7Ozs7Ozs7OztBQVdBOzs7O0FBSUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBckJBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUF1QkE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdERBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQXVEQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBR0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUlBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Gisplay.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Gisplay = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Choropleth = __webpack_require__(/*! ./Maps/Choropleth */ 6);\n\nvar _DotMap = __webpack_require__(/*! ./Maps/DotMap */ 7);\n\nvar _ChangeMap = __webpack_require__(/*! ./Maps/ChangeMap */ 9);\n\nvar _ProportionalSymbolsMap = __webpack_require__(/*! ./Maps/ProportionalSymbolsMap */ 10);\n\nvar _ChorochromaticMap = __webpack_require__(/*! ./Maps/ChorochromaticMap */ 11);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\r\n * Gisplay API with one method for each map available.\r\n */\nvar Gisplay = exports.Gisplay = function () {\n    function Gisplay() {\n        _classCallCheck(this, Gisplay);\n\n        console.log(\"Gisplay Class constructor\");\n        window.profiling = true;\n        window.maps = new Array();\n        window.mapcount = 0;\n\n        //WebGL API\n        window._vertexcount = 0;\n        window._tricount = 0;\n        /*return this;*/\n    }\n\n    _createClass(Gisplay, [{\n        key: 'makeChoropleth',\n        value: function makeChoropleth(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            /*console.log(options)*/\n            var gismap = new _Choropleth.Choropleth(bgmap, geometry, options);\n            this.makeMap(gismap, options); //options.defaultid);\n        }\n    }, {\n        key: 'makeDotMap',\n        value: function makeDotMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _DotMap.DotMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n    }, {\n        key: 'makeChangeMap',\n        value: function makeChangeMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChangeMap.ChangeMap(bgmap, geometry, options);\n            this.makeMap(gismap, options);\n        }\n    }, {\n        key: 'makeProportionalSymbolsMap',\n        value: function makeProportionalSymbolsMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ProportionalSymbolsMap.ProportionalSymbolsMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui add options (n tinha WUT)\n        }\n    }, {\n        key: 'makeChorochromaticMap',\n        value: function makeChorochromaticMap(bgmap, geometry, options) {\n            if (this.profiling == true) this.startTimeStamp = Date.now();\n            var gismap = new _ChorochromaticMap.ChorochromaticMap(bgmap, geometry, options);\n            this.makeMap(gismap, options); //@Rui .defaultid);\n        }\n    }, {\n        key: 'makeMap',\n        value: function makeMap(gismap, options) {\n            var _this = this;\n\n            var defaultid = options.defaultid != null ? defaultid : 1;\n            setTimeout(function (console) {\n                /*alert(this.profiling);*/\n                var start = 0;\n                if (_this.profiling == true) start = Date.now();\n                /*defaultid = defaultid != null ? defaultid : 1;*/\n                if (gismap.colorscheme == undefined) gismap.colorscheme = gismap.defaults(defaultid).colorScheme;\n                if (gismap.classbreaks == undefined) {\n                    if (gismap.numberofclasses == undefined) {\n                        gismap.numberofclasses = gismap.defaults(defaultid).numberOfClasses;\n                    }\n                    gismap.preProcessData(gismap.geometry, gismap.numberofclasses, gismap.algorithm, gismap.colorscheme);\n                }\n\n                //gismap.processData(gismap.geometry);\n                gismap.loadGeoJSON(gismap.geometry);\n                var start2 = 0;\n                if (_this.profiling == true) {\n                    start2 = Date.now();\n                    window.console.log('Tempo de processamento do dados (segundos): ' + (start2 - start) / 1000);\n                }\n                gismap.draw();\n\n                var end = 0;\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo de desenho do mapa (segundos): ' + (end - start2) / 1000);\n                }\n                if (options.legend != false) gismap.buildLegend();\n                if (options.loader != false) {\n                    gismap.loader();\n                }\n                if (_this.profiling == true) {\n                    end = Date.now();\n                    window.console.log('Tempo total (segundos): ' + (end - _this.startTimeStamp) / 1000);\n                }\n            }, 1);\n        }\n    }, {\n        key: 'changemapDefaults',\n        value: function changemapDefaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Gisplay;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9HaXNwbGF5LmpzPzA1YTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hvcm9wbGV0aCB9IGZyb20gJy4vTWFwcy9DaG9yb3BsZXRoJztcclxuaW1wb3J0IHsgRG90TWFwIH0gZnJvbSAnLi9NYXBzL0RvdE1hcCc7XHJcbmltcG9ydCB7IENoYW5nZU1hcCB9IGZyb20gJy4vTWFwcy9DaGFuZ2VNYXAnO1xyXG5pbXBvcnQgeyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIH0gZnJvbSAnLi9NYXBzL1Byb3BvcnRpb25hbFN5bWJvbHNNYXAnXHJcbmltcG9ydCB7IENob3JvY2hyb21hdGljTWFwIH0gZnJvbSAnLi9NYXBzL0Nob3JvY2hyb21hdGljTWFwJztcclxuXHJcbi8qKlxyXG4gKiBHaXNwbGF5IEFQSSB3aXRoIG9uZSBtZXRob2QgZm9yIGVhY2ggbWFwIGF2YWlsYWJsZS5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBHaXNwbGF5IHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIkdpc3BsYXkgQ2xhc3MgY29uc3RydWN0b3JcIik7XHJcbiAgICAgICAgd2luZG93LnByb2ZpbGluZyA9IHRydWU7XHJcbiAgICAgICAgd2luZG93Lm1hcHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB3aW5kb3cubWFwY291bnQgPSAwO1xyXG5cclxuICAgICAgICAvL1dlYkdMIEFQSVxyXG4gICAgICAgIHdpbmRvdy5fdmVydGV4Y291bnQgPSAwO1xyXG4gICAgICAgIHdpbmRvdy5fdHJpY291bnQgPSAwO1xyXG4gICAgICAgIC8qcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBtYWtlQ2hvcm9wbGV0aChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgLypjb25zb2xlLmxvZyhvcHRpb25zKSovXHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IENob3JvcGxldGgoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTsvL29wdGlvbnMuZGVmYXVsdGlkKTtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlRG90TWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgRG90TWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tYWtlTWFwKGdpc21hcCwgb3B0aW9ucyk7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIG1ha2VDaGFuZ2VNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGNvbnN0IGdpc21hcCA9IG5ldyBDaGFuZ2VNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICBtYWtlUHJvcG9ydGlvbmFsU3ltYm9sc01hcChiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVTdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc3QgZ2lzbWFwID0gbmV3IFByb3BvcnRpb25hbFN5bWJvbHNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTsgLy9AUnVpIGFkZCBvcHRpb25zIChuIHRpbmhhIFdVVClcclxuXHJcbiAgICB9XHJcblxyXG4gICAgbWFrZUNob3JvY2hyb21hdGljTWFwKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0aGlzLnByb2ZpbGluZyA9PSB0cnVlKVxyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZVN0YW1wID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBjb25zdCBnaXNtYXAgPSBuZXcgQ2hvcm9jaHJvbWF0aWNNYXAoYmdtYXAsIGdlb21ldHJ5LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLm1ha2VNYXAoZ2lzbWFwLCBvcHRpb25zKTsvL0BSdWkgLmRlZmF1bHRpZCk7XHJcbiAgICB9XHJcblxyXG4gICAgbWFrZU1hcChnaXNtYXAsIG9wdGlvbnMpIHtcclxuICAgICAgICBsZXQgZGVmYXVsdGlkID0gb3B0aW9ucy5kZWZhdWx0aWQgIT0gbnVsbCA/IGRlZmF1bHRpZCA6IDE7XHJcbiAgICAgICAgc2V0VGltZW91dChjb25zb2xlID0+IHtcclxuICAgICAgICAgICAgLyphbGVydCh0aGlzLnByb2ZpbGluZyk7Ki9cclxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpXHJcbiAgICAgICAgICAgICAgICBzdGFydCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIC8qZGVmYXVsdGlkID0gZGVmYXVsdGlkICE9IG51bGwgPyBkZWZhdWx0aWQgOiAxOyovXHJcbiAgICAgICAgICAgIGlmIChnaXNtYXAuY29sb3JzY2hlbWUgPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgZ2lzbWFwLmNvbG9yc2NoZW1lID0gZ2lzbWFwLmRlZmF1bHRzKGRlZmF1bHRpZCkuY29sb3JTY2hlbWU7XHJcbiAgICAgICAgICAgIGlmIChnaXNtYXAuY2xhc3NicmVha3MgPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2lzbWFwLm51bWJlcm9mY2xhc3NlcyA9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBnaXNtYXAubnVtYmVyb2ZjbGFzc2VzID0gZ2lzbWFwLmRlZmF1bHRzKGRlZmF1bHRpZCkubnVtYmVyT2ZDbGFzc2VzO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZ2lzbWFwLnByZVByb2Nlc3NEYXRhKGdpc21hcC5nZW9tZXRyeSwgZ2lzbWFwLm51bWJlcm9mY2xhc3NlcywgZ2lzbWFwLmFsZ29yaXRobSwgZ2lzbWFwLmNvbG9yc2NoZW1lKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy9naXNtYXAucHJvY2Vzc0RhdGEoZ2lzbWFwLmdlb21ldHJ5KTtcclxuICAgICAgICAgICAgZ2lzbWFwLmxvYWRHZW9KU09OKGdpc21hcC5nZW9tZXRyeSk7XHJcbiAgICAgICAgICAgIGxldCBzdGFydDIgPSAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9maWxpbmcgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQyID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhgVGVtcG8gZGUgcHJvY2Vzc2FtZW50byBkbyBkYWRvcyAoc2VndW5kb3MpOiAkeyhzdGFydDIgLSBzdGFydCkgLyAxMDAwfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGdpc21hcC5kcmF3KCk7XHJcblxyXG4gICAgICAgICAgICBsZXQgZW5kID0gMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIGRlIGRlc2VuaG8gZG8gbWFwYSAoc2VndW5kb3MpOiAkeyhlbmQgLSBzdGFydDIpIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWdlbmQgIT0gZmFsc2UpXHJcbiAgICAgICAgICAgICAgICBnaXNtYXAuYnVpbGRMZWdlbmQoKTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9hZGVyICE9IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBnaXNtYXAubG9hZGVyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZmlsaW5nID09IHRydWUpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5sb2coYFRlbXBvIHRvdGFsIChzZWd1bmRvcyk6ICR7KGVuZCAtIHRoaXMuc3RhcnRUaW1lU3RhbXApIC8gMTAwMH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNoYW5nZW1hcERlZmF1bHRzKGRlZmF1bHRpZCkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKGRlZmF1bHRpZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9HaXNwbGF5LmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7O0FBQ0E7OztBQUdBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* unknown exports provided */
/* all exports used */
/*!**********************************!*\
  !*** ./src/Gisplay/Aesthetic.js ***!
  \**********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Aesthetic = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Feature = __webpack_require__(/*! ./Feature */ 4);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Aesthetic = exports.Aesthetic = function () {\n    function Aesthetic(id, attr, fcolor, stroke, pointsize, range) {\n        _classCallCheck(this, Aesthetic);\n\n        this.id = id;\n        this.fillColor = fcolor;\n        this.strokeColor = stroke;\n        this.range = range;\n        this._attr = attr;\n        this.pointSize = pointsize == null ? 1.0 : parseFloat(pointsize);\n        this._features = new Array();\n        this._allFeatures = null;\n        this.enabled = true;\n        this.outer = false;\n        return this;\n    }\n\n    _createClass(Aesthetic, [{\n        key: 'addFeature',\n        value: function addFeature(id, properties, triangles, borders, points) {\n            this._features.push(new _Feature.Feature(id, properties, triangles, borders, points));\n        }\n    }, {\n        key: 'getAttr',\n        value: function getAttr() {\n            return this._attr;\n        }\n    }, {\n        key: 'checkProperty',\n        value: function checkProperty(value) {\n            if (this.range == null) return true;else {\n                if (typeof value === 'number') {\n\n                    return (this.range[0] == null || value >= this.range[0]) && (this.range[1] == null || value < this.range[1] || value <= this.range[1] && this.outer == true);\n                } else return value == this.range[0];\n            }\n        }\n    }, {\n        key: 'addGroupedFeature',\n        value: function addGroupedFeature(id, triangles, borders, points) {\n            if (this._allFeatures == null) {\n                this._allFeatures = new Array();\n                this._allFeatures.push(new _Feature.Feature(id, null, triangles, borders, points));\n            } else {\n                var cursor = 0; //TODO\n                //this._allFeatures[0]._properties.push(properties);\n                this._allFeatures[cursor].push(new _Feature.Feature(id, null, triangles, borders, points));\n                //this._allFeatures[cursor]._triangles.concat(triangles);\n                //this._allFeatures[cursor]._borders.concat(borders);\n            }\n        }\n    }, {\n        key: 'enableDisable',\n        value: function enableDisable() {\n            this.enabled = !this.enabled;\n            return this.enabled;\n        }\n    }]);\n\n    return Aesthetic;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9BZXN0aGV0aWMuanM/NTllOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0ZlYXR1cmV9IGZyb20gJy4vRmVhdHVyZSc7XHJcblxyXG5leHBvcnQgY2xhc3MgQWVzdGhldGljIHtcclxuICAgIFxyXG4gICAgY29uc3RydWN0b3IoaWQsIGF0dHIsIGZjb2xvciwgc3Ryb2tlLCBwb2ludHNpemUsIHJhbmdlKSB7XHJcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuZmlsbENvbG9yID0gZmNvbG9yO1xyXG4gICAgICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBzdHJva2U7XHJcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xyXG4gICAgICAgIHRoaXMuX2F0dHIgPSBhdHRyO1xyXG4gICAgICAgIHRoaXMucG9pbnRTaXplID0gcG9pbnRzaXplID09IG51bGwgPyAxLjAgOiBwYXJzZUZsb2F0KHBvaW50c2l6ZSk7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLl9hbGxGZWF0dXJlcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm91dGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcblxyXG4gICAgYWRkRmVhdHVyZShpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9mZWF0dXJlcy5wdXNoKG5ldyBGZWF0dXJlKGlkLCBwcm9wZXJ0aWVzLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldEF0dHIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F0dHI7XHJcbiAgICB9XHJcblxyXG4gICAgY2hlY2tQcm9wZXJ0eSh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmdlID09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKHRoaXMucmFuZ2VbMF0gPT0gbnVsbCB8fCB2YWx1ZSA+PSB0aGlzLnJhbmdlWzBdKVxyXG4gICAgICAgICAgICAgICAgICAgICYmICh0aGlzLnJhbmdlWzFdID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlIDwgdGhpcy5yYW5nZVsxXSB8fCAodmFsdWUgPD0gdGhpcy5yYW5nZVsxXSAmJiB0aGlzLm91dGVyID09IHRydWUpKSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgPT0gdGhpcy5yYW5nZVswXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGFkZEdyb3VwZWRGZWF0dXJlKGlkLCB0cmlhbmdsZXMsIGJvcmRlcnMsIHBvaW50cykge1xyXG4gICAgICAgIGlmICh0aGlzLl9hbGxGZWF0dXJlcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FsbEZlYXR1cmVzLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJzb3IgPSAwOyAvL1RPRE9cclxuICAgICAgICAgICAgLy90aGlzLl9hbGxGZWF0dXJlc1swXS5fcHJvcGVydGllcy5wdXNoKHByb3BlcnRpZXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hbGxGZWF0dXJlc1tjdXJzb3JdLnB1c2gobmV3IEZlYXR1cmUoaWQsIG51bGwsIHRyaWFuZ2xlcywgYm9yZGVycywgcG9pbnRzKSk7XHJcbiAgICAgICAgICAgIC8vdGhpcy5fYWxsRmVhdHVyZXNbY3Vyc29yXS5fdHJpYW5nbGVzLmNvbmNhdCh0cmlhbmdsZXMpO1xyXG4gICAgICAgICAgICAvL3RoaXMuX2FsbEZlYXR1cmVzW2N1cnNvcl0uX2JvcmRlcnMuY29uY2F0KGJvcmRlcnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBlbmFibGVEaXNhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuZW5hYmxlZCA9ICF0aGlzLmVuYWJsZWQ7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5hYmxlZDtcclxuICAgIH1cclxufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9BZXN0aGV0aWMuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7OztBQUNBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFHQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* unknown exports provided */
/* all exports used */
/*!********************************!*\
  !*** ./src/Gisplay/Feature.js ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n//Intermediate API\n/**\r\n * \r\n */\nvar Feature = exports.Feature = function Feature(id, properties, triangles, borders, points) {\n    _classCallCheck(this, Feature);\n\n    this._id = id;\n    this._properties = properties;\n    this._triangles = triangles;\n    this._borders = borders;\n    this._points = points;\n    return this;\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9GZWF0dXJlLmpzP2ZiNWMiXSwic291cmNlc0NvbnRlbnQiOlsiLy9JbnRlcm1lZGlhdGUgQVBJXHJcbi8qKlxyXG4gKiBcclxuICovXHJcbmV4cG9ydCBjbGFzcyBGZWF0dXJlIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihpZCwgcHJvcGVydGllcywgdHJpYW5nbGVzLCBib3JkZXJzLCBwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IGlkO1xyXG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xyXG4gICAgICAgIHRoaXMuX3RyaWFuZ2xlcyA9IHRyaWFuZ2xlcztcclxuICAgICAgICB0aGlzLl9ib3JkZXJzID0gYm9yZGVycztcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBcclxufVxyXG5cclxuXHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9GZWF0dXJlLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 5 */
/* unknown exports provided */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Gisplay/Maps/BGMapWrapper.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar BGMapWrapper = exports.BGMapWrapper = function () {\n    function BGMapWrapper(map) {\n        _classCallCheck(this, BGMapWrapper);\n\n        console.log(\"BGMapWrapper constructor?\");\n        this.map = map;\n        /*return this;*/\n    }\n\n    _createClass(BGMapWrapper, [{\n        key: 'getContainer',\n        value: function getContainer() {\n            return this.map.getContainer();\n        }\n    }, {\n        key: 'createCanvas',\n        value: function createCanvas(id) {\n            var mapCanvas = document.createElement('canvas');\n            mapCanvas.id = 'mapCanvas' + id;\n            mapCanvas.style.position = 'absolute';\n\n            var mapDiv = this.map.getContainer();\n            mapCanvas.height = mapDiv.offsetHeight;\n            mapCanvas.width = mapDiv.offsetWidth;\n            //mapCanvas.style.zIndex = \"2\";\n\n            //case mapbox\n            mapDiv.insertBefore(mapCanvas, mapDiv.firstChild.nextSibling);\n\n            var canvas = document.getElementById('mapCanvas' + id);\n            return canvas;\n        }\n    }, {\n        key: 'getZoom',\n        value: function getZoom() {\n            return this.map.getZoom();\n        }\n    }, {\n        key: 'getLngBound',\n        value: function getLngBound() {\n            return this.map.getBounds().getNorthWest().lng;\n        }\n    }, {\n        key: 'getLatBound',\n        value: function getLatBound() {\n            return this.map.getBounds().getNorthWest().lat;\n        }\n    }, {\n        key: 'onEvent',\n        value: function onEvent(eventstr, eventfunction) {\n            this.map.on(eventstr, eventfunction);\n        }\n    }, {\n        key: 'loader',\n        value: function loader() {\n            if (this.loaderDiv === undefined) this.createLoader(this.map);else {\n                if (this.loaderDiv.style.display == 'none') this.loaderDiv.style.display = 'flex';else {\n                    this.loaderDiv.style.display = 'none';\n                }\n\n                if (this.loaderDiv.className.includes('_gisplayhidden')) {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayhidden(?!\\S)/g, '_gisplayLoaderOuterDiv');\n                } else {\n                    this.loaderDiv.className = this.loaderDiv.className.replace(/(?:^|\\s)_gisplayLoaderOuterDiv(?!\\S)/g, '_gisplayhidden');\n                }\n            }\n        }\n    }, {\n        key: 'createLoader',\n        value: function createLoader() {\n            var outerDiv = document.createElement('div');\n            var innerDiv = document.createElement('div');\n            innerDiv.className = '_gisplayloader';\n\n            var mapDiv = this.getContainer();\n\n            /*outerDiv.style = ' opacity: 0.5; background-color: grey; justify-content: center; display: flex;';\r\n            outerDiv.style.position = 'absolute';\r\n            outerDiv.style.zIndex = '999999999';*/\n            outerDiv.className = '_gisplayLoaderOuterDiv';\n            outerDiv.style.height = mapDiv.offsetHeight;\n            outerDiv.style.width = mapDiv.offsetWidth;\n            outerDiv.appendChild(innerDiv);\n            this.loaderDiv = outerDiv;\n\n            mapDiv.parentElement.insertBefore(outerDiv, mapDiv);\n        }\n    }]);\n\n    return BGMapWrapper;\n}();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcz9lMjZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5leHBvcnQgY2xhc3MgQkdNYXBXcmFwcGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG1hcCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQkdNYXBXcmFwcGVyIGNvbnN0cnVjdG9yP1wiKTtcclxuICAgICAgICB0aGlzLm1hcCA9IG1hcDtcclxuICAgICAgICAvKnJldHVybiB0aGlzOyovXHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Q29udGFpbmVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRDb250YWluZXIoKTtcclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVDYW52YXMoaWQpIHtcclxuICAgICAgICBjb25zdCBtYXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICBtYXBDYW52YXMuaWQgPSBgbWFwQ2FudmFzJHtpZH1gO1xyXG4gICAgICAgIG1hcENhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMubWFwLmdldENvbnRhaW5lcigpO1xyXG4gICAgICAgIG1hcENhbnZhcy5oZWlnaHQgPSBtYXBEaXYub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgIG1hcENhbnZhcy53aWR0aCA9IG1hcERpdi5vZmZzZXRXaWR0aDtcclxuICAgICAgICAvL21hcENhbnZhcy5zdHlsZS56SW5kZXggPSBcIjJcIjtcclxuXHJcbiAgICAgICAgLy9jYXNlIG1hcGJveFxyXG4gICAgICAgIG1hcERpdi5pbnNlcnRCZWZvcmUobWFwQ2FudmFzLCBtYXBEaXYuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XHJcblxyXG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGBtYXBDYW52YXMke2lkfWApO1xyXG4gICAgICAgIHJldHVybiBjYW52YXM7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0Wm9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0Wm9vbSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGdldExuZ0JvdW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRCb3VuZHMoKS5nZXROb3J0aFdlc3QoKS5sbmc7XHJcbiAgICB9XHJcblxyXG4gICAgZ2V0TGF0Qm91bmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldEJvdW5kcygpLmdldE5vcnRoV2VzdCgpLmxhdDtcclxuICAgIH1cclxuXHJcbiAgICBvbkV2ZW50KGV2ZW50c3RyLCBldmVudGZ1bmN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5tYXAub24oZXZlbnRzdHIsIGV2ZW50ZnVuY3Rpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIGxvYWRlcigpIHtcclxuICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgdGhpcy5jcmVhdGVMb2FkZXIodGhpcy5tYXApO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sb2FkZXJEaXYuc3R5bGUuZGlzcGxheSA9PSAnbm9uZScpXHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvYWRlckRpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvYWRlckRpdi5jbGFzc05hbWUuaW5jbHVkZXMoJ19naXNwbGF5aGlkZGVuJykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZSA9IHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheWhpZGRlbig/IVxcUykvZywgJ19naXNwbGF5TG9hZGVyT3V0ZXJEaXYnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZSA9IHRoaXMubG9hZGVyRGl2LmNsYXNzTmFtZS5yZXBsYWNlKC8oPzpefFxccylfZ2lzcGxheUxvYWRlck91dGVyRGl2KD8hXFxTKS9nLCAnX2dpc3BsYXloaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjcmVhdGVMb2FkZXIoKSB7XHJcbiAgICAgICAgY29uc3Qgb3V0ZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBjb25zdCBpbm5lckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGlubmVyRGl2LmNsYXNzTmFtZSA9ICdfZ2lzcGxheWxvYWRlcic7XHJcblxyXG4gICAgICAgIGNvbnN0IG1hcERpdiA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XHJcblxyXG4gICAgICAgIC8qb3V0ZXJEaXYuc3R5bGUgPSAnIG9wYWNpdHk6IDAuNTsgYmFja2dyb3VuZC1jb2xvcjogZ3JleTsganVzdGlmeS1jb250ZW50OiBjZW50ZXI7IGRpc3BsYXk6IGZsZXg7JztcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUuekluZGV4ID0gJzk5OTk5OTk5OSc7Ki9cclxuICAgICAgICBvdXRlckRpdi5jbGFzc05hbWUgPSAnX2dpc3BsYXlMb2FkZXJPdXRlckRpdic7XHJcbiAgICAgICAgb3V0ZXJEaXYuc3R5bGUuaGVpZ2h0ID0gbWFwRGl2Lm9mZnNldEhlaWdodDtcclxuICAgICAgICBvdXRlckRpdi5zdHlsZS53aWR0aCA9IG1hcERpdi5vZmZzZXRXaWR0aDtcclxuICAgICAgICBvdXRlckRpdi5hcHBlbmRDaGlsZChpbm5lckRpdik7XHJcbiAgICAgICAgdGhpcy5sb2FkZXJEaXYgPSBvdXRlckRpdjtcclxuXHJcbiAgICAgICAgbWFwRGl2LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG91dGVyRGl2LCBtYXBEaXYpO1xyXG4gICAgfVxyXG59XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBzcmMvR2lzcGxheS9NYXBzL0JHTWFwV3JhcHBlci5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBR0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 6 */
/* unknown exports provided */
/* all exports used */
/*!****************************************!*\
  !*** ./src/Gisplay/Maps/Choropleth.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.Choropleth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Choropleth implementation 06/03\r\n */\nvar Choropleth = exports.Choropleth = function (_Map) {\n    _inherits(Choropleth, _Map);\n\n    function Choropleth(bgmap, geometry, options) {\n        _classCallCheck(this, Choropleth);\n\n        var _this = _possibleConstructorReturn(this, (Choropleth.__proto__ || Object.getPrototypeOf(Choropleth)).call(this, bgmap, geometry, options));\n\n        _this.aesthetics = new Array();\n        _this.geometry = geometry;\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.type = 'CP';\n        maps.push(_this);\n        _this.initialize();\n        /*return this;*/\n        return _this;\n    }\n\n    _createClass(Choropleth, [{\n        key: 'draw',\n        value: function draw() {\n            //console.log(\"Choropleth drawaaa() called\");\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawTriangles(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            //console.log(\"Choropleth buildLegend() called\");\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPolygonRow(this.aesthetics[a], this);\n            }\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            //console.log(\"Choropleth defaults() called\");\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = ['white', 'yellow', 'orange', 'red'];\n                    options.numberOfClasses = 4;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return Choropleth;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0Nob3JvcGxldGguanM/ZjhjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXAgfSBmcm9tICcuL01hcCc7XHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcblxyXG4vKipcclxuICogQ2hvcm9wbGV0aCBpbXBsZW1lbnRhdGlvbiAwNi8wM1xyXG4gKi9cclxuZXhwb3J0IGNsYXNzIENob3JvcGxldGggZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5hZXN0aGV0aWNzID0gbmV3IEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMubG9hZE9wdGlvbnMob3B0aW9ucywgYmdtYXApO1xyXG4gICAgICAgIHRoaXMuaWQgPSBtYXBjb3VudCsrO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDUCc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIC8qcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDaG9yb3BsZXRoIGRyYXdhYWEoKSBjYWxsZWRcIik7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmFlc3RoZXRpY3NbaV0uZW5hYmxlZCA9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdUcmlhbmdsZXModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRyYXdCb3JkZXJzKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJDaG9yb3BsZXRoIGJ1aWxkTGVnZW5kKCkgY2FsbGVkXCIpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGEgaW4gdGhpcy5hZXN0aGV0aWNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVnZW5kLmluc2VydFBvbHlnb25Sb3codGhpcy5hZXN0aGV0aWNzW2FdLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0TGVnZW5kKHRoaXMubWFwKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWZhdWx0cyhkZWZhdWx0aWQpIHtcclxuICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ2hvcm9wbGV0aCBkZWZhdWx0cygpIGNhbGxlZFwiKTtcclxuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XHJcbiAgICAgICAgc3dpdGNoIChkZWZhdWx0aWQpIHtcclxuICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvclNjaGVtZSA9IFsnd2hpdGUnLCAneWVsbG93JywgJ29yYW5nZScsICdyZWQnXTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubnVtYmVyT2ZDbGFzc2VzID0gNDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQ2hvcm9wbGV0aC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFVQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 7 */
/* unknown exports provided */
/* all exports used */
/*!************************************!*\
  !*** ./src/Gisplay/Maps/DotMap.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.DotMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * DotMap implemenetation\r\n */\nvar DotMap = exports.DotMap = function (_Map) {\n    _inherits(DotMap, _Map);\n\n    function DotMap(bgmap, geometry, options) {\n        _classCallCheck(this, DotMap);\n\n        var _this = _possibleConstructorReturn(this, (DotMap.__proto__ || Object.getPrototypeOf(DotMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.type = 'DM';\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        maps.push(_this);\n        _this.initialize();\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(DotMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            for (var a in this.aesthetics) {\n                this.legend.insertPointRow(this.aesthetics[a], this);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid, useroptions) {\n            //@TODO useroptions not used\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    break;\n            }\n            options.numberOfClasses = 1;\n            return options;\n        }\n    }]);\n\n    return DotMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0RvdE1hcC5qcz84OTMxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7TWFwfSBmcm9tICcuL01hcCc7XHJcbmltcG9ydCB7TGVnZW5kfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIERvdE1hcCBpbXBsZW1lbmV0YXRpb25cclxuICovXHJcbmV4cG9ydCBjbGFzcyBEb3RNYXAgZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdETSc7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgIC8qICByZXR1cm4gdGhpczsqL1xyXG4gICAgfVxyXG5cclxuICAgIGRyYXcoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZXN0aGV0aWNzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1BvaW50cyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGEgaW4gdGhpcy5hZXN0aGV0aWNzKVxyXG4gICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQb2ludFJvdyh0aGlzLmFlc3RoZXRpY3NbYV0sIHRoaXMpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkLCB1c2Vyb3B0aW9ucykgeyAvL0BUT0RPIHVzZXJvcHRpb25zIG5vdCB1c2VkXHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbXCIjNDQwMTU0XCIsIFwiIzQ0MDI1NlwiLCBcIiM0NTA0NTdcIiwgXCIjNDUwNTU5XCIsIFwiIzQ2MDc1YVwiLCBcIiM0NjA4NWNcIiwgXCIjNDYwYTVkXCIsIFwiIzQ2MGI1ZVwiLCBcIiM0NzBkNjBcIiwgXCIjNDcwZTYxXCIsIFwiIzQ3MTA2M1wiLCBcIiM0NzExNjRcIiwgXCIjNDcxMzY1XCIsIFwiIzQ4MTQ2N1wiLCBcIiM0ODE2NjhcIiwgXCIjNDgxNzY5XCIsIFwiIzQ4MTg2YVwiLCBcIiM0ODFhNmNcIiwgXCIjNDgxYjZkXCIsIFwiIzQ4MWM2ZVwiLCBcIiM0ODFkNmZcIiwgXCIjNDgxZjcwXCIsIFwiIzQ4MjA3MVwiLCBcIiM0ODIxNzNcIiwgXCIjNDgyMzc0XCIsIFwiIzQ4MjQ3NVwiLCBcIiM0ODI1NzZcIiwgXCIjNDgyNjc3XCIsIFwiIzQ4Mjg3OFwiLCBcIiM0ODI5NzlcIiwgXCIjNDcyYTdhXCIsIFwiIzQ3MmM3YVwiLCBcIiM0NzJkN2JcIiwgXCIjNDcyZTdjXCIsIFwiIzQ3MmY3ZFwiLCBcIiM0NjMwN2VcIiwgXCIjNDYzMjdlXCIsIFwiIzQ2MzM3ZlwiLCBcIiM0NjM0ODBcIiwgXCIjNDUzNTgxXCIsIFwiIzQ1Mzc4MVwiLCBcIiM0NTM4ODJcIiwgXCIjNDQzOTgzXCIsIFwiIzQ0M2E4M1wiLCBcIiM0NDNiODRcIiwgXCIjNDMzZDg0XCIsIFwiIzQzM2U4NVwiLCBcIiM0MjNmODVcIiwgXCIjNDI0MDg2XCIsIFwiIzQyNDE4NlwiLCBcIiM0MTQyODdcIiwgXCIjNDE0NDg3XCIsIFwiIzQwNDU4OFwiLCBcIiM0MDQ2ODhcIiwgXCIjM2Y0Nzg4XCIsIFwiIzNmNDg4OVwiLCBcIiMzZTQ5ODlcIiwgXCIjM2U0YTg5XCIsIFwiIzNlNGM4YVwiLCBcIiMzZDRkOGFcIiwgXCIjM2Q0ZThhXCIsIFwiIzNjNGY4YVwiLCBcIiMzYzUwOGJcIiwgXCIjM2I1MThiXCIsIFwiIzNiNTI4YlwiLCBcIiMzYTUzOGJcIiwgXCIjM2E1NDhjXCIsIFwiIzM5NTU4Y1wiLCBcIiMzOTU2OGNcIiwgXCIjMzg1ODhjXCIsIFwiIzM4NTk4Y1wiLCBcIiMzNzVhOGNcIiwgXCIjMzc1YjhkXCIsIFwiIzM2NWM4ZFwiLCBcIiMzNjVkOGRcIiwgXCIjMzU1ZThkXCIsIFwiIzM1NWY4ZFwiLCBcIiMzNDYwOGRcIiwgXCIjMzQ2MThkXCIsIFwiIzMzNjI4ZFwiLCBcIiMzMzYzOGRcIiwgXCIjMzI2NDhlXCIsIFwiIzMyNjU4ZVwiLCBcIiMzMTY2OGVcIiwgXCIjMzE2NzhlXCIsIFwiIzMxNjg4ZVwiLCBcIiMzMDY5OGVcIiwgXCIjMzA2YThlXCIsIFwiIzJmNmI4ZVwiLCBcIiMyZjZjOGVcIiwgXCIjMmU2ZDhlXCIsIFwiIzJlNmU4ZVwiLCBcIiMyZTZmOGVcIiwgXCIjMmQ3MDhlXCIsIFwiIzJkNzE4ZVwiLCBcIiMyYzcxOGVcIiwgXCIjMmM3MjhlXCIsIFwiIzJjNzM4ZVwiLCBcIiMyYjc0OGVcIiwgXCIjMmI3NThlXCIsIFwiIzJhNzY4ZVwiLCBcIiMyYTc3OGVcIiwgXCIjMmE3ODhlXCIsIFwiIzI5Nzk4ZVwiLCBcIiMyOTdhOGVcIiwgXCIjMjk3YjhlXCIsIFwiIzI4N2M4ZVwiLCBcIiMyODdkOGVcIiwgXCIjMjc3ZThlXCIsIFwiIzI3N2Y4ZVwiLCBcIiMyNzgwOGVcIiwgXCIjMjY4MThlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjU4MzhlXCIsIFwiIzI1ODQ4ZVwiLCBcIiMyNTg1OGVcIiwgXCIjMjQ4NjhlXCIsIFwiIzI0ODc4ZVwiLCBcIiMyMzg4OGVcIiwgXCIjMjM4OThlXCIsIFwiIzIzOGE4ZFwiLCBcIiMyMjhiOGRcIiwgXCIjMjI4YzhkXCIsIFwiIzIyOGQ4ZFwiLCBcIiMyMThlOGRcIiwgXCIjMjE4ZjhkXCIsIFwiIzIxOTA4ZFwiLCBcIiMyMTkxOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkzOGNcIiwgXCIjMWY5NDhjXCIsIFwiIzFmOTU4YlwiLCBcIiMxZjk2OGJcIiwgXCIjMWY5NzhiXCIsIFwiIzFmOTg4YlwiLCBcIiMxZjk5OGFcIiwgXCIjMWY5YThhXCIsIFwiIzFlOWI4YVwiLCBcIiMxZTljODlcIiwgXCIjMWU5ZDg5XCIsIFwiIzFmOWU4OVwiLCBcIiMxZjlmODhcIiwgXCIjMWZhMDg4XCIsIFwiIzFmYTE4OFwiLCBcIiMxZmExODdcIiwgXCIjMWZhMjg3XCIsIFwiIzIwYTM4NlwiLCBcIiMyMGE0ODZcIiwgXCIjMjFhNTg1XCIsIFwiIzIxYTY4NVwiLCBcIiMyMmE3ODVcIiwgXCIjMjJhODg0XCIsIFwiIzIzYTk4M1wiLCBcIiMyNGFhODNcIiwgXCIjMjVhYjgyXCIsIFwiIzI1YWM4MlwiLCBcIiMyNmFkODFcIiwgXCIjMjdhZDgxXCIsIFwiIzI4YWU4MFwiLCBcIiMyOWFmN2ZcIiwgXCIjMmFiMDdmXCIsIFwiIzJjYjE3ZVwiLCBcIiMyZGIyN2RcIiwgXCIjMmViMzdjXCIsIFwiIzJmYjQ3Y1wiLCBcIiMzMWI1N2JcIiwgXCIjMzJiNjdhXCIsIFwiIzM0YjY3OVwiLCBcIiMzNWI3NzlcIiwgXCIjMzdiODc4XCIsIFwiIzM4Yjk3N1wiLCBcIiMzYWJhNzZcIiwgXCIjM2JiYjc1XCIsIFwiIzNkYmM3NFwiLCBcIiMzZmJjNzNcIiwgXCIjNDBiZDcyXCIsIFwiIzQyYmU3MVwiLCBcIiM0NGJmNzBcIiwgXCIjNDZjMDZmXCIsIFwiIzQ4YzE2ZVwiLCBcIiM0YWMxNmRcIiwgXCIjNGNjMjZjXCIsIFwiIzRlYzM2YlwiLCBcIiM1MGM0NmFcIiwgXCIjNTJjNTY5XCIsIFwiIzU0YzU2OFwiLCBcIiM1NmM2NjdcIiwgXCIjNThjNzY1XCIsIFwiIzVhYzg2NFwiLCBcIiM1Y2M4NjNcIiwgXCIjNWVjOTYyXCIsIFwiIzYwY2E2MFwiLCBcIiM2M2NiNWZcIiwgXCIjNjVjYjVlXCIsIFwiIzY3Y2M1Y1wiLCBcIiM2OWNkNWJcIiwgXCIjNmNjZDVhXCIsIFwiIzZlY2U1OFwiLCBcIiM3MGNmNTdcIiwgXCIjNzNkMDU2XCIsIFwiIzc1ZDA1NFwiLCBcIiM3N2QxNTNcIiwgXCIjN2FkMTUxXCIsIFwiIzdjZDI1MFwiLCBcIiM3ZmQzNGVcIiwgXCIjODFkMzRkXCIsIFwiIzg0ZDQ0YlwiLCBcIiM4NmQ1NDlcIiwgXCIjODlkNTQ4XCIsIFwiIzhiZDY0NlwiLCBcIiM4ZWQ2NDVcIiwgXCIjOTBkNzQzXCIsIFwiIzkzZDc0MVwiLCBcIiM5NWQ4NDBcIiwgXCIjOThkODNlXCIsIFwiIzliZDkzY1wiLCBcIiM5ZGQ5M2JcIiwgXCIjYTBkYTM5XCIsIFwiI2EyZGEzN1wiLCBcIiNhNWRiMzZcIiwgXCIjYThkYjM0XCIsIFwiI2FhZGMzMlwiLCBcIiNhZGRjMzBcIiwgXCIjYjBkZDJmXCIsIFwiI2IyZGQyZFwiLCBcIiNiNWRlMmJcIiwgXCIjYjhkZTI5XCIsIFwiI2JhZGUyOFwiLCBcIiNiZGRmMjZcIiwgXCIjYzBkZjI1XCIsIFwiI2MyZGYyM1wiLCBcIiNjNWUwMjFcIiwgXCIjYzhlMDIwXCIsIFwiI2NhZTExZlwiLCBcIiNjZGUxMWRcIiwgXCIjZDBlMTFjXCIsIFwiI2QyZTIxYlwiLCBcIiNkNWUyMWFcIiwgXCIjZDhlMjE5XCIsIFwiI2RhZTMxOVwiLCBcIiNkZGUzMThcIiwgXCIjZGZlMzE4XCIsIFwiI2UyZTQxOFwiLCBcIiNlNWU0MTlcIiwgXCIjZTdlNDE5XCIsIFwiI2VhZTUxYVwiLCBcIiNlY2U1MWJcIiwgXCIjZWZlNTFjXCIsIFwiI2YxZTUxZFwiLCBcIiNmNGU2MWVcIiwgXCIjZjZlNjIwXCIsIFwiI2Y4ZTYyMVwiLCBcIiNmYmU3MjNcIiwgXCIjZmRlNzI1XCJdO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuY29sb3JTY2hlbWUgPSBbJ3B1cnBsZScsICdvcmFuZ2UnLCAnYmx1ZScsICd5ZWxsb3cnLCAncGluaycsICdncmVlbicsICdyZWQnLCAnbmF2eSddO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsYXNzZXMgPSAxO1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvRG90TWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7OztBQUNBOzs7QUFHQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 8 */
/* unknown exports provided */
/* all exports used */
/*!**************************!*\
  !*** ./src/gisplayv2.js ***!
  \**************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Gisplay = __webpack_require__(/*! ./Gisplay/Gisplay */ 2);\n\nmodule.exports = {\n\n    /** #########################CHOROPLETH MAPS################################# */\n    //Choropleth\n    createBGMap: function createBGMap() {\n        console.log(\"Start gisplayv2. TESTE workflow2.\");\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChoropleth: function startChoropleth() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            colorScheme: [\"white\", \"yellow\", \"orange\", \"red\"],\n            numberOfClasses: 4,\n            attr: 'f3',\n            legendTitle: 'Fatals'\n        };\n        //var data = new Array();\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            //new Choropleth(map, null,options);\n\n            var data = JSON.parse(reader.result);\n            //console.log(data);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n\n            /* console.log(window.map)\r\n             console.log(map)*/\n            gisplay.makeChoropleth(window.map, data, options);\n            console.log(\"tempo gisplay: \" + (Date.now() - datareadtimestamp) / 1000 + \" segundos\");\n            console.log(\"tempo total: \" + (Date.now() - time) / 1000 + \" segundos\");\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    createBGMapChorocromatic: function createBGMapChorocromatic() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.streets').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChorocromatic: function startChorocromatic() {\n        var gisplay = new _Gisplay.Gisplay();\n        var options = {\n            attr: 'f2',\n            legendTitle: \"Most Frequent Crime\"\n        };\n\n        var time = Date.now();\n        console.log(\"starting Chorocromatic Map...\");\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            var datareadtimestamp = Date.now();\n            console.log(\"tempo de leitura do ficheiro: \" + (datareadtimestamp - time) / 1000 + \" segundos\");\n            gisplay.makeChorochromaticMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################DOT MAPS################################# */\n    //DOT MAP Example 1\n    createBGMapDotMap: function createBGMapDotMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startDotMap1: function startDotMap1() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 1...\");\n\n        var options = {\n            colorScheme: [\"red\", \"green\"],\n            attr: 'f1',\n            legendTitle: \"Alcohol\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    //DOT MAP Example 2\n    startDotMap2: function startDotMap2() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Dot Map 2...\");\n\n        var options = {\n            colorScheme: [\"blue\", \"red\"],\n            maxPointSize: 100,\n            numberOfClasses: 2,\n            classBreaksMethod: \"k-means\",\n            minPointSize: 1,\n            attr: 'f2',\n            legendTitle: \"Fatals\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeDotMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** #########################CHANGE MAPS################################# */\n    //Change map Example\n    createBGMapChangeMap: function createBGMapChangeMap() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startChangeMap: function startChangeMap() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Change Map 1...\");\n\n        var options = {\n            colorScheme: [\"green\", \"red\"],\n            minuend: 'f6',\n            subtrahend: 'f2',\n            alpha: 1,\n            legendTitle: \"Evoluo entre 2009 e 2013\"\n        };\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeChangeMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    },\n\n    /** ########################PROP. SYMBOLS MAPS########################### */\n    createBGPSymbols: function createBGPSymbols() {\n        L.mapbox.accessToken = 'pk.eyJ1IjoibG9sYXNkIiwiYSI6ImNpbmxsZDJkejAwOHR2Zm0yZHVwOWV1ejEifQ.SJ6CupBlW0gPic0n-HgY6w';\n        window.map = L.mapbox.map('map', 'mapbox.dark').setView([49.36855556, -81.66371667], 4);\n    },\n\n    startPSymbols: function startPSymbols() {\n        var gisplay = new _Gisplay.Gisplay();\n        console.log(\"starting Proportional Symbols...\");\n        var options = {\n            maxPointSize: 100,\n            minPointSize: 5,\n            attr: 'f1',\n            alpha: 1.0,\n            numberOfLegendItems: 3,\n            legendTitle: \"Accidents\"\n        };\n\n        var time = Date.now();\n\n        var reader = new FileReader();\n        reader.onloadend = function () {\n            var data = JSON.parse(reader.result);\n            gisplay.makeProportionalSymbolsMap(map, data, options);\n        };\n        reader.readAsText(document.getElementById(\"file\").files[0]);\n    }\n\n}; /**\r\n    * This file is the entry point for the Gisplay API\r\n    *///# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvZ2lzcGxheXYyLmpzPzVlMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIFRoaXMgZmlsZSBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIHRoZSBHaXNwbGF5IEFQSVxyXG4gKi9cclxuaW1wb3J0IHsgR2lzcGxheSB9IGZyb20gJy4vR2lzcGxheS9HaXNwbGF5J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNDSE9ST1BMRVRIIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8vQ2hvcm9wbGV0aFxyXG4gICAgY3JlYXRlQkdNYXA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlN0YXJ0IGdpc3BsYXl2Mi4gVEVTVEUgd29ya2Zsb3cyLlwiKTtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LnN0cmVldHMnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0Q2hvcm9wbGV0aDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgY29sb3JTY2hlbWU6IFtcIndoaXRlXCIsIFwieWVsbG93XCIsIFwib3JhbmdlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBudW1iZXJPZkNsYXNzZXM6IDQsXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMycsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiAnRmF0YWxzJ1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy92YXIgZGF0YSA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy9uZXcgQ2hvcm9wbGV0aChtYXAsIG51bGwsb3B0aW9ucyk7XHJcblxyXG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UocmVhZGVyLnJlc3VsdCk7XHJcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgICAgIHZhciBkYXRhcmVhZHRpbWVzdGFtcCA9IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGVtcG8gZGUgbGVpdHVyYSBkbyBmaWNoZWlybzogXCIgKyAoZGF0YXJlYWR0aW1lc3RhbXAgLSB0aW1lKSAvIDEwMDAgKyBcIiBzZWd1bmRvc1wiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIGNvbnNvbGUubG9nKHdpbmRvdy5tYXApXHJcbiAgICAgICAgICAgICBjb25zb2xlLmxvZyhtYXApKi9cclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hvcm9wbGV0aCh3aW5kb3cubWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJ0ZW1wbyBnaXNwbGF5OiBcIiArIChEYXRlLm5vdygpIC0gZGF0YXJlYWR0aW1lc3RhbXApIC8gMTAwMCArIFwiIHNlZ3VuZG9zXCIpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIHRvdGFsOiBcIiArIChEYXRlLm5vdygpIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGNyZWF0ZUJHTWFwQ2hvcm9jcm9tYXRpYzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIEwubWFwYm94LmFjY2Vzc1Rva2VuID0gJ3BrLmV5SjFJam9pYkc5c1lYTmtJaXdpWVNJNkltTnBibXhzWkRKa2VqQXdPSFIyWm0weVpIVndPV1YxZWpFaWZRLlNKNkN1cEJsVzBnUGljMG4tSGdZNncnO1xyXG4gICAgICAgIHdpbmRvdy5tYXAgPSBMLm1hcGJveC5tYXAoJ21hcCcsICdtYXBib3guc3RyZWV0cycpLnNldFZpZXcoWzQ5LjM2ODU1NTU2LCAtODEuNjYzNzE2NjddLCA0KTtcclxuICAgIH0sXHJcblxyXG4gICAgc3RhcnRDaG9yb2Nyb21hdGljOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGdpc3BsYXkgPSBuZXcgR2lzcGxheSgpO1xyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBhdHRyOiAnZjInLFxyXG4gICAgICAgICAgICBsZWdlbmRUaXRsZTogXCJNb3N0IEZyZXF1ZW50IENyaW1lXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBDaG9yb2Nyb21hdGljIE1hcC4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICB2YXIgZGF0YXJlYWR0aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcInRlbXBvIGRlIGxlaXR1cmEgZG8gZmljaGVpcm86IFwiICsgKGRhdGFyZWFkdGltZXN0YW1wIC0gdGltZSkgLyAxMDAwICsgXCIgc2VndW5kb3NcIik7XHJcbiAgICAgICAgICAgIGdpc3BsYXkubWFrZUNob3JvY2hyb21hdGljTWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjRE9UIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIC8vRE9UIE1BUCBFeGFtcGxlIDFcclxuICAgIGNyZWF0ZUJHTWFwRG90TWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5kYXJrJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydERvdE1hcDE6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBEb3QgTWFwIDEuLi5cIik7XHJcblxyXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjb2xvclNjaGVtZTogW1wicmVkXCIsIFwiZ3JlZW5cIl0sXHJcbiAgICAgICAgICAgIGF0dHI6ICdmMScsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIkFsY29ob2xcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlRG90TWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vRE9UIE1BUCBFeGFtcGxlIDJcclxuICAgIHN0YXJ0RG90TWFwMjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIERvdCBNYXAgMi4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJibHVlXCIsIFwicmVkXCJdLFxyXG4gICAgICAgICAgICBtYXhQb2ludFNpemU6IDEwMCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZDbGFzc2VzOiAyLFxyXG4gICAgICAgICAgICBjbGFzc0JyZWFrc01ldGhvZDogXCJrLW1lYW5zXCIsXHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZTogMSxcclxuICAgICAgICAgICAgYXR0cjogJ2YyJyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiRmF0YWxzXCJcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHJlYWRlci5yZXN1bHQpO1xyXG4gICAgICAgICAgICBnaXNwbGF5Lm1ha2VEb3RNYXAobWFwLCBkYXRhLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVhZGVyLnJlYWRBc1RleHQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmaWxlXCIpLmZpbGVzWzBdKTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqICMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNDSEFOR0UgTUFQUyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG4gICAgLy9DaGFuZ2UgbWFwIEV4YW1wbGVcclxuICAgIGNyZWF0ZUJHTWFwQ2hhbmdlTWFwOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTC5tYXBib3guYWNjZXNzVG9rZW4gPSAncGsuZXlKMUlqb2liRzlzWVhOa0lpd2lZU0k2SW1OcGJteHNaREprZWpBd09IUjJabTB5WkhWd09XVjFlakVpZlEuU0o2Q3VwQmxXMGdQaWMwbi1IZ1k2dyc7XHJcbiAgICAgICAgd2luZG93Lm1hcCA9IEwubWFwYm94Lm1hcCgnbWFwJywgJ21hcGJveC5kYXJrJykuc2V0VmlldyhbNDkuMzY4NTU1NTYsIC04MS42NjM3MTY2N10sIDQpO1xyXG4gICAgfSxcclxuXHJcbiAgICBzdGFydENoYW5nZU1hcDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBnaXNwbGF5ID0gbmV3IEdpc3BsYXkoKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInN0YXJ0aW5nIENoYW5nZSBNYXAgMS4uLlwiKTtcclxuXHJcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGNvbG9yU2NoZW1lOiBbXCJncmVlblwiLCBcInJlZFwiXSxcclxuICAgICAgICAgICAgbWludWVuZDogJ2Y2JyxcclxuICAgICAgICAgICAgc3VidHJhaGVuZDogJ2YyJyxcclxuICAgICAgICAgICAgYWxwaGE6IDEsXHJcbiAgICAgICAgICAgIGxlZ2VuZFRpdGxlOiBcIkV2b2x1w6fDo28gZW50cmUgMjAwOSBlIDIwMTNcIlxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlQ2hhbmdlTWFwKG1hcCwgZGF0YSwgb3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmlsZVwiKS5maWxlc1swXSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKiAjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNQUk9QLiBTWU1CT0xTIE1BUFMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMgKi9cclxuICAgIGNyZWF0ZUJHUFN5bWJvbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMLm1hcGJveC5hY2Nlc3NUb2tlbiA9ICdway5leUoxSWpvaWJHOXNZWE5rSWl3aVlTSTZJbU5wYm14c1pESmtlakF3T0hSMlptMHlaSFZ3T1dWMWVqRWlmUS5TSjZDdXBCbFcwZ1BpYzBuLUhnWTZ3JztcclxuICAgICAgICB3aW5kb3cubWFwID0gTC5tYXBib3gubWFwKCdtYXAnLCAnbWFwYm94LmRhcmsnKS5zZXRWaWV3KFs0OS4zNjg1NTU1NiwgLTgxLjY2MzcxNjY3XSwgNCk7XHJcbiAgICB9LFxyXG5cclxuICAgIHN0YXJ0UFN5bWJvbHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZ2lzcGxheSA9IG5ldyBHaXNwbGF5KCk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJzdGFydGluZyBQcm9wb3J0aW9uYWwgU3ltYm9scy4uLlwiKTtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgbWF4UG9pbnRTaXplOiAxMDAsXHJcbiAgICAgICAgICAgIG1pblBvaW50U2l6ZTogNSxcclxuICAgICAgICAgICAgYXR0cjogJ2YxJyxcclxuICAgICAgICAgICAgYWxwaGE6IDEuMCxcclxuICAgICAgICAgICAgbnVtYmVyT2ZMZWdlbmRJdGVtczogMyxcclxuICAgICAgICAgICAgbGVnZW5kVGl0bGU6IFwiQWNjaWRlbnRzXCJcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XHJcblxyXG4gICAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShyZWFkZXIucmVzdWx0KTtcclxuICAgICAgICAgICAgZ2lzcGxheS5tYWtlUHJvcG9ydGlvbmFsU3ltYm9sc01hcChtYXAsIGRhdGEsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWFkZXIucmVhZEFzVGV4dChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZpbGVcIikuZmlsZXNbMF0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKiogIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI0hFQVQgTUFQUyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyAqL1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gc3JjL2dpc3BsYXl2Mi5qcyJdLCJtYXBwaW5ncyI6Ijs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdktBOzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 9 */
/* unknown exports provided */
/* all exports used */
/*!***************************************!*\
  !*** ./src/Gisplay/Maps/ChangeMap.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChangeMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Aesthetic = __webpack_require__(/*! ../Aesthetic */ 3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * ChangeMap implementation 07/03\r\n */\nvar ChangeMap = exports.ChangeMap = function (_Map) {\n    _inherits(ChangeMap, _Map);\n\n    function ChangeMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChangeMap);\n\n        var _this = _possibleConstructorReturn(this, (ChangeMap.__proto__ || Object.getPrototypeOf(ChangeMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.attr = \"change\";\n        _this.loadOptions(options, bgmap);\n        _this.id = mapcount++;\n        _this.attr = \"change\"; //@Rui Duplicate?\n        _this.type = 'CM';\n        maps.push(_this);\n        _this.initialize();\n\n        /*  return this;*/\n        return _this;\n    }\n\n    _createClass(ChangeMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            for (var i = 0; i < this.aesthetics.length; i++) {\n                if (this.aesthetics[i].enabled == true) {\n                    this.drawContinuousPolygons(this.aesthetics[i]);\n                }\n                this.drawBorders(this.aesthetics[i]);\n            }\n        }\n    }, {\n        key: 'preProcessData',\n        value: function preProcessData(geojson, numberOf, algorithm, colorscheme) {\n            var aesarray = [];\n            var values = [];\n            var breaks = void 0;\n            //var fcolor;\n            for (var g = 0; g < geojson.features.length && (this.maxfeatures == undefined || g < this.maxfeatures); g++) {\n                if (typeof geojson.features[g].properties[this.minuend] == 'number' && geojson.features[g].properties[this.minuend] != null && typeof geojson.features[g].properties[this.subtrahend] == 'number' && geojson.features[g].properties[this.subtrahend] != null) {\n                    this.max = Math.max(this.max, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                    this.min = Math.min(this.min, geojson.features[g].properties[this.minuend] - geojson.features[g].properties[this.subtrahend]);\n                }\n            }\n            breaks = [this.min, this.max];\n            this.fcolor = chroma.scale(colorscheme);\n            var aes = new _Aesthetic.Aesthetic(0, this.attr, this.fcolor, [0, 0, 0, 1], null, [breaks[0], breaks[1]]);\n            aes.outer = true;\n            aesarray.push(aes);\n\n            this.aesthetics = aesarray;\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            this.legend.insertGradient(this, this.min, 0, this.max);\n            this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults() {\n            var options = {};\n            return options;\n        }\n    }]);\n\n    return ChangeMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvR2lzcGxheS9NYXBzL0NoYW5nZU1hcC5qcz9lMTQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcCB9IGZyb20gJy4vTWFwJztcclxuaW1wb3J0IHsgTGVnZW5kIH0gZnJvbSAnLi4vTGVnZW5kJztcclxuaW1wb3J0IHsgQWVzdGhldGljIH0gZnJvbSAnLi4vQWVzdGhldGljJztcclxuXHJcbi8qKlxyXG4gKiBDaGFuZ2VNYXAgaW1wbGVtZW50YXRpb24gMDcvMDNcclxuICovXHJcbmV4cG9ydCBjbGFzcyBDaGFuZ2VNYXAgZXh0ZW5kcyBNYXAge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKGJnbWFwLCBnZW9tZXRyeSwgb3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuYXR0ciA9IFwiY2hhbmdlXCI7XHJcbiAgICAgICAgdGhpcy5sb2FkT3B0aW9ucyhvcHRpb25zLCBiZ21hcCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy5hdHRyID0gXCJjaGFuZ2VcIjsvL0BSdWkgRHVwbGljYXRlP1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDTSc7XHJcbiAgICAgICAgbWFwcy5wdXNoKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xyXG5cclxuICAgICAgICAvKiAgcmV0dXJuIHRoaXM7Ki9cclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWVzdGhldGljcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Q29udGludW91c1BvbHlnb25zKHRoaXMuYWVzdGhldGljc1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5kcmF3Qm9yZGVycyh0aGlzLmFlc3RoZXRpY3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcmVQcm9jZXNzRGF0YShnZW9qc29uLCBudW1iZXJPZiwgYWxnb3JpdGhtLCBjb2xvcnNjaGVtZSkge1xyXG4gICAgICAgIGNvbnN0IGFlc2FycmF5ID0gW107XHJcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW107XHJcbiAgICAgICAgbGV0IGJyZWFrcztcclxuICAgICAgICAvL3ZhciBmY29sb3I7XHJcbiAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCAmJiAodGhpcy5tYXhmZWF0dXJlcyA9PSB1bmRlZmluZWQgfHwgZyA8IHRoaXMubWF4ZmVhdHVyZXMpOyBnKyspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAhPSBudWxsICYmIHR5cGVvZiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSA9PSAnbnVtYmVyJyAmJiBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5zdWJ0cmFoZW5kXSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXMubWF4LCBnZW9qc29uLmZlYXR1cmVzW2ddLnByb3BlcnRpZXNbdGhpcy5taW51ZW5kXSAtIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLnN1YnRyYWhlbmRdKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubWluID0gTWF0aC5taW4odGhpcy5taW4sIGdlb2pzb24uZmVhdHVyZXNbZ10ucHJvcGVydGllc1t0aGlzLm1pbnVlbmRdIC0gZ2VvanNvbi5mZWF0dXJlc1tnXS5wcm9wZXJ0aWVzW3RoaXMuc3VidHJhaGVuZF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrcyA9IFt0aGlzLm1pbiwgdGhpcy5tYXhdO1xyXG4gICAgICAgIHRoaXMuZmNvbG9yID0gY2hyb21hLnNjYWxlKGNvbG9yc2NoZW1lKTtcclxuICAgICAgICBjb25zdCBhZXMgPSBuZXcgQWVzdGhldGljKDAsIHRoaXMuYXR0ciwgdGhpcy5mY29sb3IsIFswLCAwLCAwLCAxXSwgbnVsbCwgW2JyZWFrc1swXSwgYnJlYWtzWzFdXSk7XHJcbiAgICAgICAgYWVzLm91dGVyID0gdHJ1ZTtcclxuICAgICAgICBhZXNhcnJheS5wdXNoKGFlcyk7XHJcblxyXG4gICAgICAgIHRoaXMuYWVzdGhldGljcyA9IGFlc2FycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIGJ1aWxkTGVnZW5kKCkge1xyXG4gICAgICAgIHRoaXMubGVnZW5kID0gbmV3IExlZ2VuZCh0aGlzLmlkLCB0aGlzLmxlZ2VuZFRpdGxlKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRHcmFkaWVudCh0aGlzLCB0aGlzLm1pbiwgMCwgdGhpcy5tYXgpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zO1xyXG4gICAgfVxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQ2hhbmdlTWFwLmpzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWkE7QUFhQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 10 */
/* unknown exports provided */
/* all exports used */
/*!****************************************************!*\
  !*** ./src/Gisplay/Maps/ProportionalSymbolsMap.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ProportionalSymbolsMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Map2 = __webpack_require__(/*! ./Map */ 1);\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\r\n * Proportional Symbols Map implementation.\r\n */\nvar ProportionalSymbolsMap = exports.ProportionalSymbolsMap = function (_Map) {\n    _inherits(ProportionalSymbolsMap, _Map);\n\n    function ProportionalSymbolsMap(bgmap, geometry, options) {\n        _classCallCheck(this, ProportionalSymbolsMap);\n\n        var _this = _possibleConstructorReturn(this, (ProportionalSymbolsMap.__proto__ || Object.getPrototypeOf(ProportionalSymbolsMap)).call(this, bgmap, geometry, options));\n\n        _this.geometry = geometry;\n        _this.aesthetics = new Array();\n        _this.legend; //@Rui TODO WUT\n        _this.annotations = new Array();\n        _this.map = bgmap;\n        _this.id = mapcount++;\n        _this.type = 'PS';\n        _this.loadOptions(options, bgmap);\n        _this.dynamic = options.sizeByClass == undefined ? true : !options.sizeByClass;\n        if (_this.dynamic == true) {\n            _this.maxpointsize = options.maxPointSize == undefined ? 10.0 : parseFloat(options.maxPointSize);\n            _this.minpointsize = options.minPointSize == undefined ? 1.0 : parseFloat(options.minPointSize);\n        }\n        maps.push(_this);\n        _this.initialize();\n        return _this;\n    }\n\n    _createClass(ProportionalSymbolsMap, [{\n        key: 'draw',\n        value: function draw() {\n            this.clear();\n            if (this.dynamic == false) for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (this.aesthetics[i].enabled == true) this.drawPoints(this.aesthetics[i]);\n            } else {\n                for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                    if (this.aesthetics[i].enabled == true) this.drawProporcionalPoints(this.aesthetics[i]);\n                }\n            }\n        }\n    }, {\n        key: 'buildLegend',\n        value: function buildLegend() {\n            this.legend = new _Legend.Legend(this.id, this.legendTitle);\n            if (this.aesthetics.length == 1) this.legend.insertProportionalSymbols(this.aesthetics[0], this, this.numberOfLegendItems);else for (var i = this.aesthetics.length - 1; i >= 0; i--) {\n                if (i == 0) this.legend.insertProportionalSymbols(this.aesthetics[i], this, 2);else this.legend.insertProportionalSymbols(this.aesthetics[i], this, 1);\n            }this.legend.insertLegend(this.map);\n        }\n    }, {\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.maxPointSize = 60;\n                    options.minPointSize = 5;\n                    options.colorScheme = ['green', 'red', 'blue'];\n                    options.numberOfClasses = 1;\n                    break;\n                default:\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ProportionalSymbolsMap;\n}(_Map2.Map);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9Qcm9wb3J0aW9uYWxTeW1ib2xzTWFwLmpzPzgyNjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi9NYXAnO1xyXG5pbXBvcnQgeyBMZWdlbmQgfSBmcm9tICcuLi9MZWdlbmQnO1xyXG5cclxuLyoqXHJcbiAqIFByb3BvcnRpb25hbCBTeW1ib2xzIE1hcCBpbXBsZW1lbnRhdGlvbi5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBQcm9wb3J0aW9uYWxTeW1ib2xzTWFwIGV4dGVuZHMgTWFwIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuICAgICAgICB0aGlzLmFlc3RoZXRpY3MgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLmxlZ2VuZDsgLy9AUnVpIFRPRE8gV1VUXHJcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9ucyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMubWFwID0gYmdtYXA7XHJcbiAgICAgICAgdGhpcy5pZCA9IG1hcGNvdW50Kys7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ1BTJztcclxuICAgICAgICB0aGlzLmxvYWRPcHRpb25zKG9wdGlvbnMsIGJnbWFwKTtcclxuICAgICAgICB0aGlzLmR5bmFtaWMgPSBvcHRpb25zLnNpemVCeUNsYXNzID09IHVuZGVmaW5lZCA/IHRydWUgOiAhb3B0aW9ucy5zaXplQnlDbGFzcztcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IHRydWUpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhwb2ludHNpemUgPSBvcHRpb25zLm1heFBvaW50U2l6ZSA9PSB1bmRlZmluZWQgPyAxMC4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1heFBvaW50U2l6ZSk7XHJcbiAgICAgICAgICAgIHRoaXMubWlucG9pbnRzaXplID0gb3B0aW9ucy5taW5Qb2ludFNpemUgPT0gdW5kZWZpbmVkID8gMS4wIDogcGFyc2VGbG9hdChvcHRpb25zLm1pblBvaW50U2l6ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1hcHMucHVzaCh0aGlzKTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcclxuICAgIH1cclxuXHJcbiAgICBkcmF3KCkge1xyXG4gICAgICAgIHRoaXMuY2xlYXIoKTtcclxuICAgICAgICBpZiAodGhpcy5keW5hbWljID09IGZhbHNlKVxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5hZXN0aGV0aWNzW2ldLmVuYWJsZWQgPT0gdHJ1ZSlcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdQcm9wb3JjaW9uYWxQb2ludHModGhpcy5hZXN0aGV0aWNzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBidWlsZExlZ2VuZCgpIHtcclxuICAgICAgICB0aGlzLmxlZ2VuZCA9IG5ldyBMZWdlbmQodGhpcy5pZCwgdGhpcy5sZWdlbmRUaXRsZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYWVzdGhldGljcy5sZW5ndGggPT0gMSlcclxuICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbMF0sIHRoaXMsIHRoaXMubnVtYmVyT2ZMZWdlbmRJdGVtcyk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5hZXN0aGV0aWNzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxyXG4gICAgICAgICAgICAgICAgaWYgKGkgPT0gMClcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZ2VuZC5pbnNlcnRQcm9wb3J0aW9uYWxTeW1ib2xzKHRoaXMuYWVzdGhldGljc1tpXSwgdGhpcywgMik7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWdlbmQuaW5zZXJ0UHJvcG9ydGlvbmFsU3ltYm9scyh0aGlzLmFlc3RoZXRpY3NbaV0sIHRoaXMsIDEpO1xyXG4gICAgICAgIHRoaXMubGVnZW5kLmluc2VydExlZ2VuZCh0aGlzLm1hcCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVmYXVsdHMoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xyXG4gICAgICAgIHN3aXRjaCAoZGVmYXVsdGlkKSB7XHJcbiAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4UG9pbnRTaXplID0gNjA7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1pblBvaW50U2l6ZSA9IDU7XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydncmVlbicsICdyZWQnLCAnYmx1ZSddO1xyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5udW1iZXJPZkNsYXNzZXMgPSAxO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcblxyXG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvUHJvcG9ydGlvbmFsU3ltYm9sc01hcC5qcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7Ozs7QUFDQTs7O0FBR0E7OztBQUVBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFpQkE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUlBO0FBREE7QUFNQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTs7OzsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 11 */
/* unknown exports provided */
/* all exports used */
/*!***********************************************!*\
  !*** ./src/Gisplay/Maps/ChorochromaticMap.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.ChorochromaticMap = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Legend = __webpack_require__(/*! ../Legend */ 0);\n\nvar _Choropleth2 = __webpack_require__(/*! ./Choropleth */ 6);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*import { Map } from './Map';*/\n\n\n/**\r\n * Chorochormatic Map implemenetation.\r\n */\nvar ChorochromaticMap = exports.ChorochromaticMap = function (_Choropleth) {\n    _inherits(ChorochromaticMap, _Choropleth);\n\n    function ChorochromaticMap(bgmap, geometry, options) {\n        _classCallCheck(this, ChorochromaticMap);\n\n        return _possibleConstructorReturn(this, (ChorochromaticMap.__proto__ || Object.getPrototypeOf(ChorochromaticMap)).call(this, bgmap, geometry, options));\n    }\n\n    _createClass(ChorochromaticMap, [{\n        key: 'defaults',\n        value: function defaults(defaultid) {\n            var options = {};\n            switch (defaultid) {\n                case 1:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n                case 2:\n                    options.colorScheme = ['purple', 'orange', 'blue', 'yellow', 'pink', 'green', 'red', 'navy'];\n                    break;\n                default:\n                    options.colorScheme = [\"#440154\", \"#440256\", \"#450457\", \"#450559\", \"#46075a\", \"#46085c\", \"#460a5d\", \"#460b5e\", \"#470d60\", \"#470e61\", \"#471063\", \"#471164\", \"#471365\", \"#481467\", \"#481668\", \"#481769\", \"#48186a\", \"#481a6c\", \"#481b6d\", \"#481c6e\", \"#481d6f\", \"#481f70\", \"#482071\", \"#482173\", \"#482374\", \"#482475\", \"#482576\", \"#482677\", \"#482878\", \"#482979\", \"#472a7a\", \"#472c7a\", \"#472d7b\", \"#472e7c\", \"#472f7d\", \"#46307e\", \"#46327e\", \"#46337f\", \"#463480\", \"#453581\", \"#453781\", \"#453882\", \"#443983\", \"#443a83\", \"#443b84\", \"#433d84\", \"#433e85\", \"#423f85\", \"#424086\", \"#424186\", \"#414287\", \"#414487\", \"#404588\", \"#404688\", \"#3f4788\", \"#3f4889\", \"#3e4989\", \"#3e4a89\", \"#3e4c8a\", \"#3d4d8a\", \"#3d4e8a\", \"#3c4f8a\", \"#3c508b\", \"#3b518b\", \"#3b528b\", \"#3a538b\", \"#3a548c\", \"#39558c\", \"#39568c\", \"#38588c\", \"#38598c\", \"#375a8c\", \"#375b8d\", \"#365c8d\", \"#365d8d\", \"#355e8d\", \"#355f8d\", \"#34608d\", \"#34618d\", \"#33628d\", \"#33638d\", \"#32648e\", \"#32658e\", \"#31668e\", \"#31678e\", \"#31688e\", \"#30698e\", \"#306a8e\", \"#2f6b8e\", \"#2f6c8e\", \"#2e6d8e\", \"#2e6e8e\", \"#2e6f8e\", \"#2d708e\", \"#2d718e\", \"#2c718e\", \"#2c728e\", \"#2c738e\", \"#2b748e\", \"#2b758e\", \"#2a768e\", \"#2a778e\", \"#2a788e\", \"#29798e\", \"#297a8e\", \"#297b8e\", \"#287c8e\", \"#287d8e\", \"#277e8e\", \"#277f8e\", \"#27808e\", \"#26818e\", \"#26828e\", \"#26828e\", \"#25838e\", \"#25848e\", \"#25858e\", \"#24868e\", \"#24878e\", \"#23888e\", \"#23898e\", \"#238a8d\", \"#228b8d\", \"#228c8d\", \"#228d8d\", \"#218e8d\", \"#218f8d\", \"#21908d\", \"#21918c\", \"#20928c\", \"#20928c\", \"#20938c\", \"#1f948c\", \"#1f958b\", \"#1f968b\", \"#1f978b\", \"#1f988b\", \"#1f998a\", \"#1f9a8a\", \"#1e9b8a\", \"#1e9c89\", \"#1e9d89\", \"#1f9e89\", \"#1f9f88\", \"#1fa088\", \"#1fa188\", \"#1fa187\", \"#1fa287\", \"#20a386\", \"#20a486\", \"#21a585\", \"#21a685\", \"#22a785\", \"#22a884\", \"#23a983\", \"#24aa83\", \"#25ab82\", \"#25ac82\", \"#26ad81\", \"#27ad81\", \"#28ae80\", \"#29af7f\", \"#2ab07f\", \"#2cb17e\", \"#2db27d\", \"#2eb37c\", \"#2fb47c\", \"#31b57b\", \"#32b67a\", \"#34b679\", \"#35b779\", \"#37b878\", \"#38b977\", \"#3aba76\", \"#3bbb75\", \"#3dbc74\", \"#3fbc73\", \"#40bd72\", \"#42be71\", \"#44bf70\", \"#46c06f\", \"#48c16e\", \"#4ac16d\", \"#4cc26c\", \"#4ec36b\", \"#50c46a\", \"#52c569\", \"#54c568\", \"#56c667\", \"#58c765\", \"#5ac864\", \"#5cc863\", \"#5ec962\", \"#60ca60\", \"#63cb5f\", \"#65cb5e\", \"#67cc5c\", \"#69cd5b\", \"#6ccd5a\", \"#6ece58\", \"#70cf57\", \"#73d056\", \"#75d054\", \"#77d153\", \"#7ad151\", \"#7cd250\", \"#7fd34e\", \"#81d34d\", \"#84d44b\", \"#86d549\", \"#89d548\", \"#8bd646\", \"#8ed645\", \"#90d743\", \"#93d741\", \"#95d840\", \"#98d83e\", \"#9bd93c\", \"#9dd93b\", \"#a0da39\", \"#a2da37\", \"#a5db36\", \"#a8db34\", \"#aadc32\", \"#addc30\", \"#b0dd2f\", \"#b2dd2d\", \"#b5de2b\", \"#b8de29\", \"#bade28\", \"#bddf26\", \"#c0df25\", \"#c2df23\", \"#c5e021\", \"#c8e020\", \"#cae11f\", \"#cde11d\", \"#d0e11c\", \"#d2e21b\", \"#d5e21a\", \"#d8e219\", \"#dae319\", \"#dde318\", \"#dfe318\", \"#e2e418\", \"#e5e419\", \"#e7e419\", \"#eae51a\", \"#ece51b\", \"#efe51c\", \"#f1e51d\", \"#f4e61e\", \"#f6e620\", \"#f8e621\", \"#fbe723\", \"#fde725\"];\n                    break;\n            }\n            return options;\n        }\n    }]);\n\n    return ChorochromaticMap;\n}(_Choropleth2.Choropleth);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vc3JjL0dpc3BsYXkvTWFwcy9DaG9yb2Nocm9tYXRpY01hcC5qcz80NGQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qaW1wb3J0IHsgTWFwIH0gZnJvbSAnLi9NYXAnOyovXHJcbmltcG9ydCB7IExlZ2VuZCB9IGZyb20gJy4uL0xlZ2VuZCc7XHJcbmltcG9ydCB7IENob3JvcGxldGggfSBmcm9tICcuL0Nob3JvcGxldGgnO1xyXG5cclxuLyoqXHJcbiAqIENob3JvY2hvcm1hdGljIE1hcCBpbXBsZW1lbmV0YXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgQ2hvcm9jaHJvbWF0aWNNYXAgZXh0ZW5kcyBDaG9yb3BsZXRoIHtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihiZ21hcCwgZ2VvbWV0cnksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIGRlZmF1bHRzKGRlZmF1bHRpZCkge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcclxuICAgICAgICBzd2l0Y2ggKGRlZmF1bHRpZCkge1xyXG4gICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gW1wiIzQ0MDE1NFwiLCBcIiM0NDAyNTZcIiwgXCIjNDUwNDU3XCIsIFwiIzQ1MDU1OVwiLCBcIiM0NjA3NWFcIiwgXCIjNDYwODVjXCIsIFwiIzQ2MGE1ZFwiLCBcIiM0NjBiNWVcIiwgXCIjNDcwZDYwXCIsIFwiIzQ3MGU2MVwiLCBcIiM0NzEwNjNcIiwgXCIjNDcxMTY0XCIsIFwiIzQ3MTM2NVwiLCBcIiM0ODE0NjdcIiwgXCIjNDgxNjY4XCIsIFwiIzQ4MTc2OVwiLCBcIiM0ODE4NmFcIiwgXCIjNDgxYTZjXCIsIFwiIzQ4MWI2ZFwiLCBcIiM0ODFjNmVcIiwgXCIjNDgxZDZmXCIsIFwiIzQ4MWY3MFwiLCBcIiM0ODIwNzFcIiwgXCIjNDgyMTczXCIsIFwiIzQ4MjM3NFwiLCBcIiM0ODI0NzVcIiwgXCIjNDgyNTc2XCIsIFwiIzQ4MjY3N1wiLCBcIiM0ODI4NzhcIiwgXCIjNDgyOTc5XCIsIFwiIzQ3MmE3YVwiLCBcIiM0NzJjN2FcIiwgXCIjNDcyZDdiXCIsIFwiIzQ3MmU3Y1wiLCBcIiM0NzJmN2RcIiwgXCIjNDYzMDdlXCIsIFwiIzQ2MzI3ZVwiLCBcIiM0NjMzN2ZcIiwgXCIjNDYzNDgwXCIsIFwiIzQ1MzU4MVwiLCBcIiM0NTM3ODFcIiwgXCIjNDUzODgyXCIsIFwiIzQ0Mzk4M1wiLCBcIiM0NDNhODNcIiwgXCIjNDQzYjg0XCIsIFwiIzQzM2Q4NFwiLCBcIiM0MzNlODVcIiwgXCIjNDIzZjg1XCIsIFwiIzQyNDA4NlwiLCBcIiM0MjQxODZcIiwgXCIjNDE0Mjg3XCIsIFwiIzQxNDQ4N1wiLCBcIiM0MDQ1ODhcIiwgXCIjNDA0Njg4XCIsIFwiIzNmNDc4OFwiLCBcIiMzZjQ4ODlcIiwgXCIjM2U0OTg5XCIsIFwiIzNlNGE4OVwiLCBcIiMzZTRjOGFcIiwgXCIjM2Q0ZDhhXCIsIFwiIzNkNGU4YVwiLCBcIiMzYzRmOGFcIiwgXCIjM2M1MDhiXCIsIFwiIzNiNTE4YlwiLCBcIiMzYjUyOGJcIiwgXCIjM2E1MzhiXCIsIFwiIzNhNTQ4Y1wiLCBcIiMzOTU1OGNcIiwgXCIjMzk1NjhjXCIsIFwiIzM4NTg4Y1wiLCBcIiMzODU5OGNcIiwgXCIjMzc1YThjXCIsIFwiIzM3NWI4ZFwiLCBcIiMzNjVjOGRcIiwgXCIjMzY1ZDhkXCIsIFwiIzM1NWU4ZFwiLCBcIiMzNTVmOGRcIiwgXCIjMzQ2MDhkXCIsIFwiIzM0NjE4ZFwiLCBcIiMzMzYyOGRcIiwgXCIjMzM2MzhkXCIsIFwiIzMyNjQ4ZVwiLCBcIiMzMjY1OGVcIiwgXCIjMzE2NjhlXCIsIFwiIzMxNjc4ZVwiLCBcIiMzMTY4OGVcIiwgXCIjMzA2OThlXCIsIFwiIzMwNmE4ZVwiLCBcIiMyZjZiOGVcIiwgXCIjMmY2YzhlXCIsIFwiIzJlNmQ4ZVwiLCBcIiMyZTZlOGVcIiwgXCIjMmU2ZjhlXCIsIFwiIzJkNzA4ZVwiLCBcIiMyZDcxOGVcIiwgXCIjMmM3MThlXCIsIFwiIzJjNzI4ZVwiLCBcIiMyYzczOGVcIiwgXCIjMmI3NDhlXCIsIFwiIzJiNzU4ZVwiLCBcIiMyYTc2OGVcIiwgXCIjMmE3NzhlXCIsIFwiIzJhNzg4ZVwiLCBcIiMyOTc5OGVcIiwgXCIjMjk3YThlXCIsIFwiIzI5N2I4ZVwiLCBcIiMyODdjOGVcIiwgXCIjMjg3ZDhlXCIsIFwiIzI3N2U4ZVwiLCBcIiMyNzdmOGVcIiwgXCIjMjc4MDhlXCIsIFwiIzI2ODE4ZVwiLCBcIiMyNjgyOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI1ODM4ZVwiLCBcIiMyNTg0OGVcIiwgXCIjMjU4NThlXCIsIFwiIzI0ODY4ZVwiLCBcIiMyNDg3OGVcIiwgXCIjMjM4ODhlXCIsIFwiIzIzODk4ZVwiLCBcIiMyMzhhOGRcIiwgXCIjMjI4YjhkXCIsIFwiIzIyOGM4ZFwiLCBcIiMyMjhkOGRcIiwgXCIjMjE4ZThkXCIsIFwiIzIxOGY4ZFwiLCBcIiMyMTkwOGRcIiwgXCIjMjE5MThjXCIsIFwiIzIwOTI4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MzhjXCIsIFwiIzFmOTQ4Y1wiLCBcIiMxZjk1OGJcIiwgXCIjMWY5NjhiXCIsIFwiIzFmOTc4YlwiLCBcIiMxZjk4OGJcIiwgXCIjMWY5OThhXCIsIFwiIzFmOWE4YVwiLCBcIiMxZTliOGFcIiwgXCIjMWU5Yzg5XCIsIFwiIzFlOWQ4OVwiLCBcIiMxZjllODlcIiwgXCIjMWY5Zjg4XCIsIFwiIzFmYTA4OFwiLCBcIiMxZmExODhcIiwgXCIjMWZhMTg3XCIsIFwiIzFmYTI4N1wiLCBcIiMyMGEzODZcIiwgXCIjMjBhNDg2XCIsIFwiIzIxYTU4NVwiLCBcIiMyMWE2ODVcIiwgXCIjMjJhNzg1XCIsIFwiIzIyYTg4NFwiLCBcIiMyM2E5ODNcIiwgXCIjMjRhYTgzXCIsIFwiIzI1YWI4MlwiLCBcIiMyNWFjODJcIiwgXCIjMjZhZDgxXCIsIFwiIzI3YWQ4MVwiLCBcIiMyOGFlODBcIiwgXCIjMjlhZjdmXCIsIFwiIzJhYjA3ZlwiLCBcIiMyY2IxN2VcIiwgXCIjMmRiMjdkXCIsIFwiIzJlYjM3Y1wiLCBcIiMyZmI0N2NcIiwgXCIjMzFiNTdiXCIsIFwiIzMyYjY3YVwiLCBcIiMzNGI2NzlcIiwgXCIjMzViNzc5XCIsIFwiIzM3Yjg3OFwiLCBcIiMzOGI5NzdcIiwgXCIjM2FiYTc2XCIsIFwiIzNiYmI3NVwiLCBcIiMzZGJjNzRcIiwgXCIjM2ZiYzczXCIsIFwiIzQwYmQ3MlwiLCBcIiM0MmJlNzFcIiwgXCIjNDRiZjcwXCIsIFwiIzQ2YzA2ZlwiLCBcIiM0OGMxNmVcIiwgXCIjNGFjMTZkXCIsIFwiIzRjYzI2Y1wiLCBcIiM0ZWMzNmJcIiwgXCIjNTBjNDZhXCIsIFwiIzUyYzU2OVwiLCBcIiM1NGM1NjhcIiwgXCIjNTZjNjY3XCIsIFwiIzU4Yzc2NVwiLCBcIiM1YWM4NjRcIiwgXCIjNWNjODYzXCIsIFwiIzVlYzk2MlwiLCBcIiM2MGNhNjBcIiwgXCIjNjNjYjVmXCIsIFwiIzY1Y2I1ZVwiLCBcIiM2N2NjNWNcIiwgXCIjNjljZDViXCIsIFwiIzZjY2Q1YVwiLCBcIiM2ZWNlNThcIiwgXCIjNzBjZjU3XCIsIFwiIzczZDA1NlwiLCBcIiM3NWQwNTRcIiwgXCIjNzdkMTUzXCIsIFwiIzdhZDE1MVwiLCBcIiM3Y2QyNTBcIiwgXCIjN2ZkMzRlXCIsIFwiIzgxZDM0ZFwiLCBcIiM4NGQ0NGJcIiwgXCIjODZkNTQ5XCIsIFwiIzg5ZDU0OFwiLCBcIiM4YmQ2NDZcIiwgXCIjOGVkNjQ1XCIsIFwiIzkwZDc0M1wiLCBcIiM5M2Q3NDFcIiwgXCIjOTVkODQwXCIsIFwiIzk4ZDgzZVwiLCBcIiM5YmQ5M2NcIiwgXCIjOWRkOTNiXCIsIFwiI2EwZGEzOVwiLCBcIiNhMmRhMzdcIiwgXCIjYTVkYjM2XCIsIFwiI2E4ZGIzNFwiLCBcIiNhYWRjMzJcIiwgXCIjYWRkYzMwXCIsIFwiI2IwZGQyZlwiLCBcIiNiMmRkMmRcIiwgXCIjYjVkZTJiXCIsIFwiI2I4ZGUyOVwiLCBcIiNiYWRlMjhcIiwgXCIjYmRkZjI2XCIsIFwiI2MwZGYyNVwiLCBcIiNjMmRmMjNcIiwgXCIjYzVlMDIxXCIsIFwiI2M4ZTAyMFwiLCBcIiNjYWUxMWZcIiwgXCIjY2RlMTFkXCIsIFwiI2QwZTExY1wiLCBcIiNkMmUyMWJcIiwgXCIjZDVlMjFhXCIsIFwiI2Q4ZTIxOVwiLCBcIiNkYWUzMTlcIiwgXCIjZGRlMzE4XCIsIFwiI2RmZTMxOFwiLCBcIiNlMmU0MThcIiwgXCIjZTVlNDE5XCIsIFwiI2U3ZTQxOVwiLCBcIiNlYWU1MWFcIiwgXCIjZWNlNTFiXCIsIFwiI2VmZTUxY1wiLCBcIiNmMWU1MWRcIiwgXCIjZjRlNjFlXCIsIFwiI2Y2ZTYyMFwiLCBcIiNmOGU2MjFcIiwgXCIjZmJlNzIzXCIsIFwiI2ZkZTcyNVwiXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICBvcHRpb25zLmNvbG9yU2NoZW1lID0gWydwdXJwbGUnLCAnb3JhbmdlJywgJ2JsdWUnLCAneWVsbG93JywgJ3BpbmsnLCAnZ3JlZW4nLCAncmVkJywgJ25hdnknXTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5jb2xvclNjaGVtZSA9IFtcIiM0NDAxNTRcIiwgXCIjNDQwMjU2XCIsIFwiIzQ1MDQ1N1wiLCBcIiM0NTA1NTlcIiwgXCIjNDYwNzVhXCIsIFwiIzQ2MDg1Y1wiLCBcIiM0NjBhNWRcIiwgXCIjNDYwYjVlXCIsIFwiIzQ3MGQ2MFwiLCBcIiM0NzBlNjFcIiwgXCIjNDcxMDYzXCIsIFwiIzQ3MTE2NFwiLCBcIiM0NzEzNjVcIiwgXCIjNDgxNDY3XCIsIFwiIzQ4MTY2OFwiLCBcIiM0ODE3NjlcIiwgXCIjNDgxODZhXCIsIFwiIzQ4MWE2Y1wiLCBcIiM0ODFiNmRcIiwgXCIjNDgxYzZlXCIsIFwiIzQ4MWQ2ZlwiLCBcIiM0ODFmNzBcIiwgXCIjNDgyMDcxXCIsIFwiIzQ4MjE3M1wiLCBcIiM0ODIzNzRcIiwgXCIjNDgyNDc1XCIsIFwiIzQ4MjU3NlwiLCBcIiM0ODI2NzdcIiwgXCIjNDgyODc4XCIsIFwiIzQ4Mjk3OVwiLCBcIiM0NzJhN2FcIiwgXCIjNDcyYzdhXCIsIFwiIzQ3MmQ3YlwiLCBcIiM0NzJlN2NcIiwgXCIjNDcyZjdkXCIsIFwiIzQ2MzA3ZVwiLCBcIiM0NjMyN2VcIiwgXCIjNDYzMzdmXCIsIFwiIzQ2MzQ4MFwiLCBcIiM0NTM1ODFcIiwgXCIjNDUzNzgxXCIsIFwiIzQ1Mzg4MlwiLCBcIiM0NDM5ODNcIiwgXCIjNDQzYTgzXCIsIFwiIzQ0M2I4NFwiLCBcIiM0MzNkODRcIiwgXCIjNDMzZTg1XCIsIFwiIzQyM2Y4NVwiLCBcIiM0MjQwODZcIiwgXCIjNDI0MTg2XCIsIFwiIzQxNDI4N1wiLCBcIiM0MTQ0ODdcIiwgXCIjNDA0NTg4XCIsIFwiIzQwNDY4OFwiLCBcIiMzZjQ3ODhcIiwgXCIjM2Y0ODg5XCIsIFwiIzNlNDk4OVwiLCBcIiMzZTRhODlcIiwgXCIjM2U0YzhhXCIsIFwiIzNkNGQ4YVwiLCBcIiMzZDRlOGFcIiwgXCIjM2M0ZjhhXCIsIFwiIzNjNTA4YlwiLCBcIiMzYjUxOGJcIiwgXCIjM2I1MjhiXCIsIFwiIzNhNTM4YlwiLCBcIiMzYTU0OGNcIiwgXCIjMzk1NThjXCIsIFwiIzM5NTY4Y1wiLCBcIiMzODU4OGNcIiwgXCIjMzg1OThjXCIsIFwiIzM3NWE4Y1wiLCBcIiMzNzViOGRcIiwgXCIjMzY1YzhkXCIsIFwiIzM2NWQ4ZFwiLCBcIiMzNTVlOGRcIiwgXCIjMzU1ZjhkXCIsIFwiIzM0NjA4ZFwiLCBcIiMzNDYxOGRcIiwgXCIjMzM2MjhkXCIsIFwiIzMzNjM4ZFwiLCBcIiMzMjY0OGVcIiwgXCIjMzI2NThlXCIsIFwiIzMxNjY4ZVwiLCBcIiMzMTY3OGVcIiwgXCIjMzE2ODhlXCIsIFwiIzMwNjk4ZVwiLCBcIiMzMDZhOGVcIiwgXCIjMmY2YjhlXCIsIFwiIzJmNmM4ZVwiLCBcIiMyZTZkOGVcIiwgXCIjMmU2ZThlXCIsIFwiIzJlNmY4ZVwiLCBcIiMyZDcwOGVcIiwgXCIjMmQ3MThlXCIsIFwiIzJjNzE4ZVwiLCBcIiMyYzcyOGVcIiwgXCIjMmM3MzhlXCIsIFwiIzJiNzQ4ZVwiLCBcIiMyYjc1OGVcIiwgXCIjMmE3NjhlXCIsIFwiIzJhNzc4ZVwiLCBcIiMyYTc4OGVcIiwgXCIjMjk3OThlXCIsIFwiIzI5N2E4ZVwiLCBcIiMyOTdiOGVcIiwgXCIjMjg3YzhlXCIsIFwiIzI4N2Q4ZVwiLCBcIiMyNzdlOGVcIiwgXCIjMjc3ZjhlXCIsIFwiIzI3ODA4ZVwiLCBcIiMyNjgxOGVcIiwgXCIjMjY4MjhlXCIsIFwiIzI2ODI4ZVwiLCBcIiMyNTgzOGVcIiwgXCIjMjU4NDhlXCIsIFwiIzI1ODU4ZVwiLCBcIiMyNDg2OGVcIiwgXCIjMjQ4NzhlXCIsIFwiIzIzODg4ZVwiLCBcIiMyMzg5OGVcIiwgXCIjMjM4YThkXCIsIFwiIzIyOGI4ZFwiLCBcIiMyMjhjOGRcIiwgXCIjMjI4ZDhkXCIsIFwiIzIxOGU4ZFwiLCBcIiMyMThmOGRcIiwgXCIjMjE5MDhkXCIsIFwiIzIxOTE4Y1wiLCBcIiMyMDkyOGNcIiwgXCIjMjA5MjhjXCIsIFwiIzIwOTM4Y1wiLCBcIiMxZjk0OGNcIiwgXCIjMWY5NThiXCIsIFwiIzFmOTY4YlwiLCBcIiMxZjk3OGJcIiwgXCIjMWY5ODhiXCIsIFwiIzFmOTk4YVwiLCBcIiMxZjlhOGFcIiwgXCIjMWU5YjhhXCIsIFwiIzFlOWM4OVwiLCBcIiMxZTlkODlcIiwgXCIjMWY5ZTg5XCIsIFwiIzFmOWY4OFwiLCBcIiMxZmEwODhcIiwgXCIjMWZhMTg4XCIsIFwiIzFmYTE4N1wiLCBcIiMxZmEyODdcIiwgXCIjMjBhMzg2XCIsIFwiIzIwYTQ4NlwiLCBcIiMyMWE1ODVcIiwgXCIjMjFhNjg1XCIsIFwiIzIyYTc4NVwiLCBcIiMyMmE4ODRcIiwgXCIjMjNhOTgzXCIsIFwiIzI0YWE4M1wiLCBcIiMyNWFiODJcIiwgXCIjMjVhYzgyXCIsIFwiIzI2YWQ4MVwiLCBcIiMyN2FkODFcIiwgXCIjMjhhZTgwXCIsIFwiIzI5YWY3ZlwiLCBcIiMyYWIwN2ZcIiwgXCIjMmNiMTdlXCIsIFwiIzJkYjI3ZFwiLCBcIiMyZWIzN2NcIiwgXCIjMmZiNDdjXCIsIFwiIzMxYjU3YlwiLCBcIiMzMmI2N2FcIiwgXCIjMzRiNjc5XCIsIFwiIzM1Yjc3OVwiLCBcIiMzN2I4NzhcIiwgXCIjMzhiOTc3XCIsIFwiIzNhYmE3NlwiLCBcIiMzYmJiNzVcIiwgXCIjM2RiYzc0XCIsIFwiIzNmYmM3M1wiLCBcIiM0MGJkNzJcIiwgXCIjNDJiZTcxXCIsIFwiIzQ0YmY3MFwiLCBcIiM0NmMwNmZcIiwgXCIjNDhjMTZlXCIsIFwiIzRhYzE2ZFwiLCBcIiM0Y2MyNmNcIiwgXCIjNGVjMzZiXCIsIFwiIzUwYzQ2YVwiLCBcIiM1MmM1NjlcIiwgXCIjNTRjNTY4XCIsIFwiIzU2YzY2N1wiLCBcIiM1OGM3NjVcIiwgXCIjNWFjODY0XCIsIFwiIzVjYzg2M1wiLCBcIiM1ZWM5NjJcIiwgXCIjNjBjYTYwXCIsIFwiIzYzY2I1ZlwiLCBcIiM2NWNiNWVcIiwgXCIjNjdjYzVjXCIsIFwiIzY5Y2Q1YlwiLCBcIiM2Y2NkNWFcIiwgXCIjNmVjZTU4XCIsIFwiIzcwY2Y1N1wiLCBcIiM3M2QwNTZcIiwgXCIjNzVkMDU0XCIsIFwiIzc3ZDE1M1wiLCBcIiM3YWQxNTFcIiwgXCIjN2NkMjUwXCIsIFwiIzdmZDM0ZVwiLCBcIiM4MWQzNGRcIiwgXCIjODRkNDRiXCIsIFwiIzg2ZDU0OVwiLCBcIiM4OWQ1NDhcIiwgXCIjOGJkNjQ2XCIsIFwiIzhlZDY0NVwiLCBcIiM5MGQ3NDNcIiwgXCIjOTNkNzQxXCIsIFwiIzk1ZDg0MFwiLCBcIiM5OGQ4M2VcIiwgXCIjOWJkOTNjXCIsIFwiIzlkZDkzYlwiLCBcIiNhMGRhMzlcIiwgXCIjYTJkYTM3XCIsIFwiI2E1ZGIzNlwiLCBcIiNhOGRiMzRcIiwgXCIjYWFkYzMyXCIsIFwiI2FkZGMzMFwiLCBcIiNiMGRkMmZcIiwgXCIjYjJkZDJkXCIsIFwiI2I1ZGUyYlwiLCBcIiNiOGRlMjlcIiwgXCIjYmFkZTI4XCIsIFwiI2JkZGYyNlwiLCBcIiNjMGRmMjVcIiwgXCIjYzJkZjIzXCIsIFwiI2M1ZTAyMVwiLCBcIiNjOGUwMjBcIiwgXCIjY2FlMTFmXCIsIFwiI2NkZTExZFwiLCBcIiNkMGUxMWNcIiwgXCIjZDJlMjFiXCIsIFwiI2Q1ZTIxYVwiLCBcIiNkOGUyMTlcIiwgXCIjZGFlMzE5XCIsIFwiI2RkZTMxOFwiLCBcIiNkZmUzMThcIiwgXCIjZTJlNDE4XCIsIFwiI2U1ZTQxOVwiLCBcIiNlN2U0MTlcIiwgXCIjZWFlNTFhXCIsIFwiI2VjZTUxYlwiLCBcIiNlZmU1MWNcIiwgXCIjZjFlNTFkXCIsIFwiI2Y0ZTYxZVwiLCBcIiNmNmU2MjBcIiwgXCIjZjhlNjIxXCIsIFwiI2ZiZTcyM1wiLCBcIiNmZGU3MjVcIl07XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XHJcbiAgICB9XHJcbn1cclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHNyYy9HaXNwbGF5L01hcHMvQ2hvcm9jaHJvbWF0aWNNYXAuanMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUhBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTs7O0FBRUE7QUFBQTtBQUNBO0FBREE7QUFFQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBQ0E7Ozs7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ })
/******/ ]);