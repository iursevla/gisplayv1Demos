<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../../">
  <title data-ice="title">src/Gisplay/Maps/Map.js | Gisplay API Documentation API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Gisplay</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Aesthetic.js~Aesthetic.html">Aesthetic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Feature.js~Feature.html">Feature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Gisplay.js~Gisplay.html">Gisplay</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Legend.js~Legend.html">Legend</a></span></span></li>
<li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">Gisplay/Maps</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/BGMapWrapper.js~BGMapWrapper.html">BGMapWrapper</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/ChangeMap.js~ChangeMap.html">ChangeMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/ChorochromaticMap.js~ChorochromaticMap.html">ChorochromaticMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Choropleth.js~Choropleth.html">Choropleth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/DotMap.js~DotMap.html">DotMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/Map.js~Map.html">Map</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Gisplay/Maps/ProportionalSymbolsMap.js~ProportionalSymbolsMap.html">ProportionalSymbolsMap</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Gisplay/Maps/Map.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import { BGMapWrapper } from &apos;./BGMapWrapper&apos;;
import { Aesthetic } from &apos;../Aesthetic&apos;;

/** 
 * ES5 libraries can be used either with 
 * 1)import if they are just functions or in the case of rtree and ktree a 
 * webpack loader is needed &quot;script-loader&quot;&quot; can do that.
 * 2) Added as &lt;script&gt; tag on index.html file
 * The former as choosen.
import chroma from &apos;../../lib/chroma.min&apos;;
import earcut from &apos;../../lib/earcut&apos;
import {PolygonLookup} from &apos;../../lib/rtree&apos;;
*/

/**
 * This class contains the Map class which represents the current map.
 * Each map has a group of functions available.
 */
export class Map {

    constructor(type, geometry, options) {
        console.log(&quot;Map constructor called -&gt; super()&quot;)
        /* return this;*/ //@TODO Remove isnt doing anything? or is it saving the 3 parameters?
    }

    program() {
        this._webgl.program = this._webgl.gl.createProgram();
        this._webgl.heatmapProgram = [];
        this._webgl.heatmapProgram[0] = this._webgl.gl.createProgram();
        this._webgl.heatmapProgram[1] = this._webgl.gl.createProgram();

        const source_code = this.generateShaders();

        const vertex_shader = this.shader(this._webgl.gl.VERTEX_SHADER, source_code.vertex, this._webgl);
        const fragment_shader = this.shader(this._webgl.gl.FRAGMENT_SHADER, source_code.fragment, this._webgl);

        this._webgl.gl.attachShader(this._webgl.program, vertex_shader);
        this._webgl.gl.attachShader(this._webgl.program, fragment_shader);

        this._webgl.gl.linkProgram(this._webgl.program);
        this._webgl.gl.useProgram(this._webgl.program);
    }


    shader(type, source_code, _webgl) { //Added HERE by Rui
        var shader = _webgl.gl.createShader(type);

        _webgl.gl.shaderSource(shader, source_code);
        _webgl.gl.compileShader(shader);

        console.log(&quot;shader &quot; + (type.valueOf() == 35633 ? &quot;vertex&quot; : &quot;fragment&quot;) + &quot;: &quot; + _webgl.gl.getShaderInfoLog(shader));

        return shader;
    }

    generateShaders() { //Added HERE by Rui @TODO Refactor to use ES6 `` instead of +=
        //general

        let vertexSourceCode = &quot; attribute vec4 vertexCoord; &quot;;
        vertexSourceCode += &quot;\n	attribute float aPointSize; &quot;;
        vertexSourceCode += &quot;\n	uniform mat4 projection; &quot;;
        vertexSourceCode += &quot;\n	attribute float a_opacity; &quot;;
        vertexSourceCode += &quot;\n	varying float v_opacity; &quot;;
        //vertexSourceCode+= &quot;\n	varying vec4 u_color; &quot; ; //delete
        vertexSourceCode += &quot;\n	void main() {&quot;;
        vertexSourceCode += &quot;\n		gl_Position = (projection * vertexCoord); &quot;;
        vertexSourceCode += &quot;\n		gl_PointSize = aPointSize; v_opacity = a_opacity; &quot;;
        vertexSourceCode += &quot;\n}&quot;;

        let fragmentSourceCode = &quot;precision mediump float;&quot;;
        fragmentSourceCode += &quot;\n		uniform vec4 u_color;&quot;;//uniform
        fragmentSourceCode += &quot;\n		varying float v_opacity; &quot;;
        fragmentSourceCode += &quot;\n 		uniform float isPoint;&quot;;
        fragmentSourceCode += &quot;\n		void main(){&quot;;
        fragmentSourceCode += &quot;\n			float border = 0.5;&quot;;
        fragmentSourceCode += &quot;\n			float radius = 0.5;&quot;;
        fragmentSourceCode += &quot;\n			float centerDist = length(gl_PointCoord - 0.5);&quot;;
        fragmentSourceCode += &quot;\n			float alpha;&quot;;
        fragmentSourceCode += &quot;\n			if (u_color[3] == -1.0){&quot;;   //unnecessary??
        fragmentSourceCode += &quot;\n				alpha =  v_opacity * step(centerDist, radius);&quot;;//unnecessary??
        fragmentSourceCode += &quot;\n			}&quot;;//unnecessary??
        fragmentSourceCode += &quot;\n			else{&quot;;//unnecessary??
        fragmentSourceCode += &quot;\n				alpha =  u_color[3] * step(centerDist, radius);&quot;;
        fragmentSourceCode += &quot;\n			}&quot;;//unnecessary??
        fragmentSourceCode += &quot;\n			if(isPoint == 1.0 ){&quot;;
        fragmentSourceCode += &quot;\n			if (alpha &lt; 0.1) discard;&quot;;
        fragmentSourceCode += &quot;\n				gl_FragColor = vec4(u_color[0], u_color[1], u_color[2], alpha);}&quot;;
        fragmentSourceCode += &quot;\n 			else&quot;;
        fragmentSourceCode += &quot;\n				gl_FragColor = vec4(u_color[0], u_color[1], u_color[2], u_color[3]);&quot;;
        fragmentSourceCode += &quot;\n		}&quot;;

        return { vertex: vertexSourceCode, fragment: fragmentSourceCode };
    }

    addAesthetic(aes) {
        this.aesthetics.push(aes);
    }

    setAesthetic(id, aes) {
        for (let i = 0; i &lt; aesthetics.length; i++) {
            if (id == aesthetics[i].id) {
                aesthetics[i] = aes;
                break;
            }
        }
    }

    buildLegend() {
        const mapCanvas = document.getElementById(`mapCanvas${this.id}`);
        const legendDiv = document.createElement(&apos;div&apos;);
        legendDiv.id = `legendDiv${this.id}`;
        legendDiv.style.position = &apos;absolute&apos;;
        legendDiv.style.backgroundColor = &apos;white&apos;;
        //legendDiv.style.height = 200;//(mapCanvas.height / 10);
        legendDiv.style.width = 250;//(mapCanvas.width / 10);
        legendDiv.style.bottom = 20;
        legendDiv.style.right = 0;
        legendDiv.style.borderColor = &apos;black&apos;;
        legendDiv.style.border = &apos;solid&apos;;

        const table = document.createElement(&apos;table&apos;);
        const thvalue = document.createElement(&apos;th&apos;);
        const thcolor = document.createElement(&apos;th&apos;);
        //thvalue.style.width = 125;
        table.style.zIndex = &quot;2000&quot;;
        thcolor.style.width = 100;
        table.appendChild(thcolor);
        table.appendChild(thvalue);


        for (const currentaes of this.aesthetics) {
            //if(currentaes._features.length &gt; 0 || currentaes._allFeatures.length &gt; 0){
            const row = document.createElement(&apos;tr&apos;);
            const value = document.createElement(&apos;td&apos;);
            const color = document.createElement(&apos;td&apos;);
            const ptext = document.createElement(&apos;p&apos;);
            let text;
            if (typeof currentaes.range[0] === &apos;number&apos;)
                text = document.createTextNode(`[${currentaes.range[0]}, ${currentaes.range[1]}[`);
            else
                text = document.createTextNode(currentaes.range[0]);
            ptext.appendChild(text);
            value.appendChild(ptext);

            const colorDiv = document.createElement(&apos;div&apos;);
            colorDiv.style.position = &apos;relative&apos;;
            const rgbc = `rgba(${currentaes.fillColor[0]},${currentaes.fillColor[1]},${currentaes.fillColor[2]},${currentaes.fillColor[3]})`;
            //console.log(rgbc);
            colorDiv.style[&apos;backgroundColor&apos;] = rgbc;
            colorDiv.style.height = 25;//(mapCanvas.height / 10);
            colorDiv.style.width = 80;//(mapCanvas.width / 10);



            color.appendChild(colorDiv);

            row.appendChild(color);
            row.appendChild(value);

            table.appendChild(row);
            //}
        }

        legendDiv.appendChild(table);
        this.map.getContainer().appendChild(legendDiv);
    }

    preProcessData(geojson, numberOf, algorithm, colorscheme) {

        const aesarray = [];
        const values = [];
        const strings = [];
        let breaks;
        let fcolor;
        for (let g = 0; g &lt; geojson.features.length &amp;&amp; (this.maxfeatures == undefined || g &lt; this.maxfeatures); g++) {
            if (geojson.features[g].properties[this.attr] != null &amp;&amp; typeof geojson.features[g].properties[this.attr] == &apos;number&apos;) {
                values.push(geojson.features[g].properties[this.attr]);
                this.max = Math.max(this.max, geojson.features[g].properties[this.attr]);
                this.min = Math.min(this.min, geojson.features[g].properties[this.attr]);
            }
            else
                if (!strings.includes(geojson.features[g].properties[this.attr]))
                    strings.push(geojson.features[g].properties[this.attr]);
        }
        if (values.length &gt; 0) {//quantitative
            if (this.breaks == undefined) {
                if (numberOf &gt; 1)
                    breaks = this.calcClassBreaks(values, algorithm, numberOf);
                else
                    breaks = [this.min, this.max];
            }
            else {
                breaks = this.breaks;
            }
            if (breaks.length &gt; 2) {
                fcolor = chroma.scale(colorscheme).colors(breaks.length - 1);
                for (var i = 0; i &lt; breaks.length - 1; i++) {
                    var color = chroma(fcolor[i]).rgb();
                    if (i != breaks.length - 2) {
                        var aes = new Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);
                    }
                    else {
                        var aes = new Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[i], breaks[i + 1]]);
                        aes.outer = true;
                    }
                    aesarray.push(aes);
                }
            }
            else {
                color = chroma(colorscheme[0]).rgb();
                var aes = new Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha], [0, 0, 0, 1], null, [breaks[0], breaks[1]]);
                aes.outer = true;
                aesarray.push(aes);
            }
        }

        else {//qualitative
            if (strings.length &gt; 0) {
                breaks = strings;
                if (typeof colorscheme === &apos;string&apos;) {//string
                    fcolor = chroma.scale(colorscheme).colors(breaks.length);
                }
                else { //array
                    fcolor = chroma.scale(colorscheme).colors(breaks.length);
                }
                for (var i = 0; i &lt; breaks.length; i++) {
                    var color = chroma(fcolor[i]).rgb();
                    var aes = new Aesthetic(i, this.attr, [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), 1], [0, 0, 0, 1], null, [strings[i]]);
                    aesarray.push(aes);
                }
            }
        }

        this.aesthetics = aesarray;
        //return aesarray;
    }

    calcClassBreaks(values, algorithm, numberOf) {
        let breaks;
        switch (algorithm) {
            case &apos;equidistant&apos;:
                breaks = chroma.limits(values, &apos;e&apos;, numberOf);
                break;

            case &apos;quantile&apos;:
                breaks = chroma.limits(values, &apos;q&apos;, numberOf);
                break;

            case &apos;k-means&apos;:
                breaks = chroma.limits(values, &apos;k&apos;, numberOf);
                break;

            default:
                breaks = chroma.limits(values, &apos;q&apos;, numberOf);
                break;
        }
        return breaks;
    }

    insertFeature(id, properties, triangles, borders, points) {
        let flag = false;
        for (let i = 0; i &lt; this.aesthetics.length; i++) {
            if (this.aesthetics[i].checkProperty(properties[this.aesthetics[i].getAttr()]) == true) {
                this.aesthetics[i].addFeature(id, properties, triangles, borders, points);
                flag = true;
            }
        }
        if (!flag) {
            //TODO
            //console.log(&quot;TODO: feature does not fit into any of the aesthetics defined.\n Value: &quot; + properties[this.attr]);
        }
    }

    insertGroupedFeature(idaes, triangles, borders, points) {
        this.aesthetics[idaes].addGroupedFeature(null, triangles, borders, points);
    }

    draw() {
        alert(&quot;draw() not implemented&quot;);
    }

    processPolygon(polygon) {

        if (polygon.geometry.type == &quot;Polygon&quot;) {
            var outsidepolygon = polygon.geometry.coordinates[0];

            var insidepolygons = [];
            for (var k = 1; k &lt; polygon.geometry.coordinates.length; k++) {
                //todo inside polygon
                //insidepolygons.push(polygon.geometry.coordinates[i][k]);
            }
            var tempVerts = new Array();
            for (var out = 0; out &lt; outsidepolygon.length - 1; out++) {
                tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);
                _vertexcount += (outsidepolygon.length + 1) / 2;
                //console.log(&quot;lon: &quot; + outsidepolygon[out][0] + &quot; lat: &quot; + outsidepolygon[out][1]);
            }



            var triangles_vert = earcut(tempVerts);
            _tricount += (triangles_vert.length / 3);
            polyarray.push({ triangles: triangles_vert, vertex: tempVerts });
        }



        else if (polygon.geometry.type == &quot;MultiPolygon&quot;) {
            var polyarray = [];
            for (let i = 0; i &lt; polygon.geometry.coordinates.length; i++) {

                var outsidepolygon = polygon.geometry.coordinates[i][0];

                var insidepolygons = [];
                for (var k = 1; k &lt; polygon.geometry.coordinates[i].length; k++) {
                    //todo inside polygon
                    insidepolygons.push(polygon.geometry.coordinates[i][k]);
                }
                var tempVerts = new Array();
                _vertexcount += outsidepolygon.length;
                for (var out = 0; out &lt; outsidepolygon.length - 1; out++) {
                    tempVerts.push(outsidepolygon[out][0], outsidepolygon[out][1]);

                    //console.log(&quot;lon: &quot; + outsidepolygon[out][0] + &quot; lat: &quot; + outsidepolygon[out][1]);
                }



                var triangles_vert = earcut(tempVerts);

                //var temp = earcut.flatten(polygon.geometry.coordinates[i]);
                //var triangles_vert = earcut(temp.vertices, temp.holes, temp.dimensions);
                _tricount += (triangles_vert.length / 3);
                polyarray.push({ triangles: triangles_vert, vertex: tempVerts });
                //console.log(polyarray);
            }


            return polyarray;
        }

    }

    processData(geojson) {
        this.loadGeoJSON(geojson);
    }

    createAndInsertFeature(id, geometry, properties) {
        const gl = this._webgl.gl;
        if (this.minuend != undefined &amp;&amp; this.subtrahend != undefined &amp;&amp; typeof properties[this.minuend] == &apos;number&apos;
            &amp;&amp; properties[this.subtrahend] != undefined &amp;&amp; typeof properties[this.subtrahend] == &apos;number&apos;
            &amp;&amp; properties[this.subtrahend] != undefined) {
            properties[this.attr] = properties[this.minuend] - properties[this.subtrahend];
        }

        if (geometry.type == &quot;Polygon&quot; || geometry.type == &quot;MultiPolygon&quot;) {
            this.hasPolygons = true;
            const polygons = this.processPolygon({ geometry, properties });

            const currentBorders = [];
            const currentTriangles = [];
            const bufferT = [];
            const bufferB = [];

            for (let j = 0; j &lt; polygons.length; j++) {
                const trianglespolygon = polygons[j].triangles;
                const border = polygons[j].vertex;
                currentTriangles[j] = new Array();
                currentBorders[j] = new Array();
                for (let h = 0; h &lt; trianglespolygon.length; h++) {
                    var pixel = this.latLongToPixelXY(border[trianglespolygon[h] * 2], border[trianglespolygon[h] * 2 + 1]);
                    currentTriangles[j].push(pixel.x, pixel.y);

                    if (h == trianglespolygon.length - 1) {
                        bufferT.push(gl.createBuffer());

                        var vertArray = new Float32Array(currentTriangles[j]);

                        gl.fsize = vertArray.BYTES_PER_ELEMENT;
                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferT[j]);
                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

                        bufferT[j].itemSize = 2;
                        bufferT[j].numItems = vertArray.length / 2;
                    }
                }


                for (var y = 0; y &lt; border.length; y += 2) {
                    var pixel = this.latLongToPixelXY(border[y], border[y + 1]);
                    currentBorders[j].push(pixel.x, pixel.y);

                    if (y == border.length - 2) {
                        bufferB.push(gl.createBuffer());

                        var vertArray = new Float32Array(currentBorders[j]);

                        gl.fsize = vertArray.BYTES_PER_ELEMENT;
                        gl.bindBuffer(gl.ARRAY_BUFFER, bufferB[j]);
                        gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

                        bufferB[j].itemSize = 2;
                        bufferB[j].numItems = vertArray.length / 2;
                    }
                }

            }
            //polygon
            this.insertFeature(id, properties, bufferT, bufferB, []);

        }

        else if (geometry.type == &quot;Point&quot; &amp;&amp; this.dynamic == true) {
            //dum
            const currentPoints = [];
            currentPoints[0] = new Array();
            var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);
            currentPoints[0].push(pixel.x, pixel.y);
            const bufferP = [];
            bufferP.push(gl.createBuffer());

            var vertArray = new Float32Array(currentPoints[0]);

            gl.fsize = vertArray.BYTES_PER_ELEMENT;
            gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);
            gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

            bufferP[0].itemSize = 2;
            bufferP[0].numItems = vertArray.length / 2;

            this.insertFeature(id, properties, [], [], bufferP);

            if (this.treepoints == null || this.treepoints == undefined) this.treepoints = [];
            this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties });


        }

        else if (geometry.type == &quot;Point&quot; &amp;&amp; this.dynamic == false) {
            //debugger;
            var pixel = this.latLongToPixelXY(geometry.coordinates[0], geometry.coordinates[1]);
            if (this.tempPoints == null || this.tempPoints == undefined) {
                this.tempPoints = new Array();
                for (let a = 0; a &lt; this.aesthetics.length; a++) {
                    this.tempPoints[a] = [];
                }
            }

            const aesarrays = this.fitFeature(properties);
            for (var y = 0; y &lt; aesarrays.length; y++) {
                this.tempPoints[aesarrays[y]].push(pixel.x, pixel.y);
            }

            if (this.treepoints == null) this.treepoints = [];
            this.treepoints.push({ lon: geometry.coordinates[0], lat: geometry.coordinates[1], properties });


        }


    }

    buildTrees(geojson) {
        const gl = this._webgl.gl;
        if (this.tempPoints != null) {
            for (let t = 0; t &lt; this.tempPoints.length; t++) {
                if (this.tempPoints[t].length &gt; 0) {
                    const bufferP = [];
                    bufferP.push(gl.createBuffer());

                    const vertArray = new Float32Array(this.tempPoints[t]);

                    gl.fsize = vertArray.BYTES_PER_ELEMENT;
                    gl.bindBuffer(gl.ARRAY_BUFFER, bufferP[0]);
                    gl.bufferData(gl.ARRAY_BUFFER, vertArray, gl.STATIC_DRAW);

                    bufferP[0].itemSize = 2;
                    bufferP[0].numItems = vertArray.length / 2;
                    this.insertGroupedFeature(t, [], [], bufferP);
                }
            }

        }
        //console.log(geojson)
        if (this.treepoints != null)
            this.kdtree = new kdTree(this.treepoints, (a, b) =&gt; (a.lon - b.lon) ** 2 + (a.lat - b.lat) ** 2, [&quot;lon&quot;, &quot;lat&quot;, &quot;properties&quot;]);
        if (this.hasPolygons == true)
            this.rtree = new PolygonLookup(geojson);
    }

    loadGeoJSON(geojson) {
        for (let g = 0; g &lt; geojson.features.length &amp;&amp; (this.maxfeatures == undefined || g &lt; this.maxfeatures); g++) {
            geojson.features[g].properties[&apos;_gisplayid&apos;] = g;
            const geometry = geojson.features[g].geometry;
            const properties = geojson.features[g].properties;
            this.createAndInsertFeature(g, geometry, properties);
        }
        this.buildTrees(geojson);

    }

    createCanvas() {
        const canvas = this.map.createCanvas(this.id);

        //init webgl properties
        this._webgl = {
            gl: null,
            program: null,
            projection: null
        };

        this._webgl.gl = canvas.getContext(&quot;webgl&quot;);
        this._webgl.projection = new Float32Array(16);
        this._webgl.projection.set([2 / canvas.width, 0, 0, 0, 0, -2 / canvas.height, 0, 0, 0, 0, 0, 0, -1, 1, 0, 1]);

        this._webgl.gl.viewport(0, 0, this.map.getContainer().offsetWidth, this.map.getContainer().offsetHeight);
        this._webgl.gl.disable(this._webgl.gl.DEPTH_TEST);
    }

    getNumberOfFeatures() {
        let count = 0;
        for (let i = 0; i &lt; this.aesthetics.length; i++) {
            count += this.aesthetics[i]._features.length;
        }
        return count;
    }

    scaleProjection(matrix, scaleX, scaleY) {
        // scaling x and y, which is just scaling first two rows of matrix
        matrix[0] *= scaleX;
        matrix[1] *= scaleX;
        matrix[2] *= scaleX;
        matrix[3] *= scaleX;

        matrix[4] *= scaleY;
        matrix[5] *= scaleY;
        matrix[6] *= scaleY;
        matrix[7] *= scaleY;
    }

    translateProjection(matrix, tx, ty) {
        // translation is in last row of matrix
        matrix[12] += matrix[0] * tx + matrix[4] * ty;
        matrix[13] += matrix[1] * tx + matrix[5] * ty;
        matrix[14] += matrix[2] * tx + matrix[6] * ty;
        matrix[15] += matrix[3] * tx + matrix[7] * ty;
    }

    latLongToPixelXY(longitude, latitude) {
        const pi_180 = Math.PI / 180.0;
        const pi_4 = Math.PI * 4;
        const sinLatitude = Math.sin(latitude * pi_180);
        const pixelY = (0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (pi_4)) * 256;
        const pixelX = ((longitude + 180) / 360) * 256;

        const pixel = { x: pixelX, y: pixelY };

        return pixel;
    }

    clear() {
        const gl = this._webgl.gl;
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.disable(gl.DEPTH_TEST);
    }

    drawTriangles(aes) {
        const gl = this._webgl.gl;
        if (gl == null) return;
        const matrixProjection = new Float32Array(16);

        //gl.clear(gl.COLOR_BUFFER_BIT);
        //gl.disable(gl.DEPTH_TEST);

        //gl.enable(gl.BLEND);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);


        const currentZoom = this.map.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);

        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);

        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);

        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);

        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        gl.uniform1f(isPointLocation, 0.0);



        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);


        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);



        /** 
         * 
         *  Draw Polygons&apos; Interior
         *  **/
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        //console.log(&quot;Numero de Buffers: &quot;, buffers.length);

        gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);




        for (let i = 0; i &lt; aes._features.length; i++) {
            for (let y = 0; y &lt; aes._features[i]._triangles.length; y++) {

                gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);

                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                //gl.enableVertexAttribArray(vertexColorLocation);



                gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);
            }
        }
    }

    drawBorders(aes) {
        const gl = this._webgl.gl;
        if (gl == null) return;
        const matrixProjection = new Float32Array(16);

        //gl.clear(gl.COLOR_BUFFER_BIT);
        //gl.disable(gl.DEPTH_TEST);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const currentZoom = this.map.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);

        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);

        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);

        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);

        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);


        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);

        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        gl.uniform1f(isPointLocation, 0.0);


        /** 
         * 
         *  Draw Polygons&apos; Interior
         *  **/
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        //console.log(&quot;Numero de Buffers: &quot;, buffers.length);

        gl.uniform4f(vertexColorLocation, aes.strokeColor[0] / 255, aes.strokeColor[1] / 255, aes.strokeColor[2] / 255, aes.strokeColor[3]);

        for (let i = 0; i &lt; aes._features.length; i++) {
            for (let y = 0; y &lt; aes._features[i]._borders.length; y++) {

                gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._borders[y]);

                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                //gl.enableVertexAttribArray(vertexColorLocation);



                gl.drawArrays(gl.LINE_LOOP, 0, aes._features[i]._borders[y].numItems);
            }
        }


    }

    drawPoints(aes) {


        const gl = this._webgl.gl;
        if (gl == null) return;
        const matrixProjection = new Float32Array(16);


        //gl.clear(gl.COLOR_BUFFER_BIT);
        //gl.disable(gl.DEPTH_TEST);

        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const currentZoom = this.map.getZoom();
        const pointSize = Math.max(currentZoom - 4.0 + aes.pointSize, aes.pointSize);

        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);

        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);

        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);

        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);


        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);

        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        gl.uniform1f(isPointLocation, 1.0);

        /** 
         * 
         *  Draw Polygons&apos; Interior
         *  **/
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        //console.log(&quot;Numero de Buffers: &quot;, buffers.length);

        gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, aes.fillColor[3]);









        for (var i = 0; i &lt; aes._features.length &amp;&amp; this.dynamic == true; i++) {
            for (var y = 0; y &lt; aes._features[i]._points.length; y++) {

                gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);

                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                //gl.enableVertexAttribArray(vertexColorLocation);



                gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);
                //1);
            }
        }


        for (var i = 0; this.dynamic == false &amp;&amp; aes._allFeatures != null &amp;&amp; i &lt; aes._allFeatures.length; i++) {
            for (var y = 0; y &lt; aes._allFeatures[i]._points.length; y++) {

                gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[i]._points[y]);

                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                //gl.enableVertexAttribArray(vertexColorLocation);



                gl.drawArrays(gl.POINTS, 0, aes._allFeatures[i]._points[y].numItems);
                //gl.drawArrays(gl.TRIANGLE_STRIP, 0, aes._allFeatures[i]._points[y].numItems-2);	
                //1);
            }
        }




    }

    drawContinuousPolygons(aes) {

        const gl = this._webgl.gl;
        if (gl == null) return;
        const matrixProjection = new Float32Array(16);

        //gl.clear(gl.COLOR_BUFFER_BIT);
        //gl.disable(gl.DEPTH_TEST);

        //gl.enable(gl.BLEND);
        //gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);


        const currentZoom = this.map.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);

        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);

        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);

        const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
        gl.vertexAttrib1f(vertexSizeLocation, pointSize);

        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        gl.uniform1f(isPointLocation, 0.0);



        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);


        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);



        /** 
         * 
         *  Draw Polygons&apos; Interior
         *  **/
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        //console.log(&quot;Numero de Buffers: &quot;, buffers.length);






        for (let i = 0; i &lt; aes._features.length; i++) {
            let ucolor;
            let color;
            const diff = aes._features[i]._properties[this.attr];
            if (diff == 0)
                color = aes.fillColor(0.5).rgb();
            else {
                if (diff &gt; 0) {
                    color = aes.fillColor(0.5 + diff / this.max / 2).rgb();


                } else {
                    color = aes.fillColor(0.5 - diff / this.min / 2).rgb();
                }

            }
            ucolor = [Math.round(color[0]), Math.round(color[1]), Math.round(color[2]), this.alpha];

            gl.uniform4f(vertexColorLocation, ucolor[0] / 255, ucolor[1] / 255, ucolor[2] / 255, this.alpha);
            for (let y = 0; y &lt; aes._features[i]._triangles.length; y++) {

                gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._triangles[y]);

                gl.enableVertexAttribArray(vertexCoordLocation);
                gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                //gl.enableVertexAttribArray(vertexColorLocation);



                gl.drawArrays(gl.TRIANGLES, 0, aes._features[i]._triangles[y].numItems);
            }
        }


    }

    drawProporcionalPoints(aes) {

        const gl = this._webgl.gl;
        if (gl == null) return;
        const matrixProjection = new Float32Array(16);



        gl.enable(gl.BLEND);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

        const currentZoom = this.map.getZoom();


        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);

        const projectionLocation = gl.getUniformLocation(this._webgl.program, &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);



        const vertexCoordLocation = gl.getAttribLocation(this._webgl.program, &apos;vertexCoord&apos;);


        const vertexColorLocation = gl.getUniformLocation(this._webgl.program, &quot;u_color&quot;);

        const isPointLocation = gl.getUniformLocation(this._webgl.program, &apos;isPoint&apos;);
        gl.uniform1f(isPointLocation, 1.0);

        /** 
         * 
         *  Draw Polygons&apos; Interior
         *  **/
        const fsize = Float32Array.BYTES_PER_ELEMENT;
        //console.log(&quot;Numero de Buffers: &quot;, buffers.length);

        gl.uniform4f(vertexColorLocation, aes.fillColor[0] / 255, aes.fillColor[1] / 255, aes.fillColor[2] / 255, this.alpha);










        if (this.dynamic == true) {
            for (const i in aes._features) {
                for (const y in aes._features[i]._points) {

                    gl.bindBuffer(gl.ARRAY_BUFFER, aes._features[i]._points[y]);
                    const propvalue = parseFloat(aes._features[i]._properties[this.attr]);
                    const temppointsize = ((this.maxpointsize - this.minpointsize) / (this.max - this.min)) * (propvalue - this.min);
                    const pointSize = Math.max(currentZoom - 4.0 + temppointsize * currentZoom / 4, 2);
                    const vertexSizeLocation = gl.getAttribLocation(this._webgl.program, &apos;aPointSize&apos;);
                    gl.vertexAttrib1f(vertexSizeLocation, pointSize);

                    gl.enableVertexAttribArray(vertexCoordLocation);
                    gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 2, 0);
                    //gl.vertexAttribPointer(vertexColorLocation, 4, gl.FLOAT, false, fsize * 6, fsize * 2);
                    //gl.enableVertexAttribArray(vertexColorLocation);



                    gl.drawArrays(gl.POINTS, 0, aes._features[i]._points[y].numItems);
                    //1);
                }
            }
        }
    }

    initialize() {
        this.max = null;
        this.min = null;
        this.createCanvas();
        this.program();
        let mappos;
        for (let i = 0; i &lt; maps.length; i++)
            if (maps[i].id == this.id)
                mappos = i;
        this.map.onEvent(&apos;move&apos;, () =&gt; {
            console.log(&quot;@Rui: mudar o profiling do window para outra coisa?&quot;)
            if (window.profiling == true)
                var start = Date.now();
            maps[mappos].draw();
            if (window.profiling == true) {
                const end = Date.now();
                window.console.log(`Tempo de processamento de Zoom/Pan (segundos):${(end - start) / 1000}`);
            }
        }
        );

        this.setupOnclick(mappos);
    }

    setupOnclick(mappos) {
        console.log(&quot;@Rui: profiling mudar de window para? | Rtree e KdTree&quot;)
        maps[mappos].map.onEvent(&apos;click&apos;, e =&gt; {
            if (window.profiling == true)
                var start = Date.now();
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;

            if (maps[mappos].rtree != undefined) {
                var bool = maps[0].rtree.search(lon, lat);
                if (bool == undefined)
                    return;
                else {
                    //console.log
                    var s = &quot;&quot;;
                    var first = true;
                    if (maps[mappos].showPropertiesOnClick != null) {
                        for (var i = 0; i &lt; maps[mappos].showPropertiesOnClick.length; i += 2) {
                            if (first) {
                                s += `${maps[mappos].showPropertiesOnClick[i + 1]}: ${bool.properties[maps[mappos].showPropertiesOnClick[i]]}`;
                                first = false;
                            }
                            else {
                                s += `\n${maps[mappos].showPropertiesOnClick[i + 1]}: ${bool.properties[maps[mappos].showPropertiesOnClick[i]]}`;
                            }

                        }
                    }
                    else {

                        var keys = Object.keys(bool.properties);

                        for (var i = 0; i &lt; keys.length; i++) {
                            if (keys[i] != &quot;_gisplayid&quot;) {
                                if (first) {
                                    s += `${keys[i]}: ${bool.properties[keys[i]]}`;
                                    first = false;
                                }
                                else {
                                    s += `\n${keys[i]}: ${bool.properties[keys[i]]}`;
                                }
                            }
                        }
                    }
                    if (maps[mappos].interactive == true)
                        alert(s);//todo
                    if (maps[mappos].mapOnClickCall != undefined &amp;&amp; maps[mappos].mapOnClickCall != null)
                        maps[mappos].mapOnClickCall(bool);
                }
            }
            if (maps[mappos].kdtree != undefined) {

                const nearest = maps[mappos].kdtree.nearest({ lat, lon }, 1, 128 / ((2 ** (map.getZoom() * 2))));
                if (nearest.length &lt;= 0)
                    return;
                else {
                    var bool = nearest[0][0];
                    //console.log
                    var s = &quot;&quot;;
                    var first = true;
                    if (maps[mappos].showPropertiesOnClick != null) {
                        for (var i = 0; i &lt; maps[mappos].showPropertiesOnClick.length; i += 2) {
                            if (first) {
                                s += `${maps[mappos].showPropertiesOnClick[i + 1]}: ${bool.properties[maps[mappos].showPropertiesOnClick[i]]}`;
                                first = false;
                            }
                            else {
                                s += `\n${maps[mappos].showPropertiesOnClick[i + 1]}: ${bool.properties[maps[mappos].showPropertiesOnClick[i]]}`;
                            }

                        }
                    }
                    else {

                        var keys = Object.keys(bool.properties);

                        for (var i = 0; i &lt; keys.length; i++) {
                            if (keys[i] != &quot;_gisplayid&quot;) {
                                if (first) {
                                    s += `${keys[i]}: ${bool.properties[keys[i]]}`;
                                    first = false;
                                }
                                else {
                                    s += `\n${keys[i]}: ${bool.properties[keys[i]]}`;
                                }
                            }
                        }
                    }
                    if (maps[mappos].interactive == true)
                        alert(s);
                    if (maps[mappos].mapOnClickCall != undefined &amp;&amp; maps[mappos].mapOnClickCall != null)
                        maps[mappos].mapOnClickCall(bool);
                }
            }

            if (window.profiling == true) {
                const end = Date.now();
                window.console.log(`Tempo de processamento de um click (segundos): ${(end - start) / 1000}`);
            }
        });

    }

    fitFeature(properties) {
        const result = [];
        for (let a = 0; a &lt; this.aesthetics.length; a++) {
            if (this.aesthetics[a].checkProperty(properties[this.aesthetics[a].getAttr()]) == true)
                result.push(a);
        }
        return result;
    }

    loadOptions(options, bgmap) {
        if (options.customMapService == true)
            this.map = bgmap;
        else
            this.map = new BGMapWrapper(bgmap);
        if (options.loader != false)
            this.loader();

        if (options.showPropertiesOnClick == true) {
            this.showPropertiesOnClick = null;
            //append on bgmap object
        }
        else if (options.showPropertiesOnClick == false) {
            //nada
        }
        else if (options.showPropertiesOnClick != undefined) {
            this.showPropertiesOnClick = options.showPropertiesOnClick;
        }
        this.alpha = options.alpha != undefined ? options.alpha : 0.8;
        this.interactive = options.interactive == undefined ? true : !options.interactive;
        this.attr = options.attr;
        this.dynamic = options.memorySaver == undefined ? false : !options.memorySaver;
        this.maxfeatures = options.maxFeatures;
        this.breaks = options.classBreaks;
        this.colorscheme = options.colorScheme;
        this.numberofclasses = options.numberOfClasses;
        this.algorithm = options.classBreaksMethod;
        this.legendOnClickCall = options.legendOnClickFunction;
        this.mapOnClickCall = options.mapOnClickFunction;
        this.minuend = options.minuend;
        this.subtrahend = options.subtrahend;
        this.legendTitle = options.legendTitle != undefined ? options.legendTitle : (this.attr != undefined ? this.attr : `${this.minuend} - ${this.subtrahend}`);
        this.numberOfLegendItems = options.numberOfLegendItems != undefined ? options.numberOfLegendItems : 2;
    }

    loader() {
        this.map.loader();
    }

    drawHeatPoints(aes) {
        const gl = this._webgl.gl;

        if (gl == null) return;
        gl.useProgram(this._webgl.heatmapProgram[0]);
        const matrixProjection = new Float32Array(16);

        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.enable(gl.BLEND);

        gl.blendFunc(gl.ONE, gl.ONE);

        const currentZoom = map.getZoom();
        const pointSize = Math.max(currentZoom - 5.0, 1.0);

        matrixProjection.set(this._webgl.projection);

        const scale = 2 ** currentZoom;
        this.scaleProjection(matrixProjection, scale, scale);

        const offset = this.latLongToPixelXY(this.map.getLngBound(), this.map.getLatBound());
        this.translateProjection(matrixProjection, -offset.x, -offset.y);


        const projectionLocation = gl.getUniformLocation(this._webgl.heatmapProgram[0], &apos;projection&apos;);
        gl.uniformMatrix4fv(projectionLocation, false, matrixProjection);


        const vertexCoordLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], &apos;position&apos;);
        const deltaLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], &apos;delta&apos;);
        const intensityLoc = gl.getAttribLocation(this._webgl.heatmapProgram[0], &apos;intensity&apos;);
        const vertexSizeLocation = gl.getAttribLocation(this._webgl.heatmapProgram[0], &apos;aPointSize&apos;);

        gl.vertexAttrib1f(vertexSizeLocation, pointSize);

        gl.enableVertexAttribArray(vertexCoordLocation);
        gl.enableVertexAttribArray(deltaLocation);
        gl.enableVertexAttribArray(intensityLoc);



        const fsize = Float32Array.BYTES_PER_ELEMENT;

        gl.bindBuffer(gl.ARRAY_BUFFER, aes._allFeatures[0]._points[0]);
        gl.vertexAttribPointer(vertexCoordLocation, 2, gl.FLOAT, false, fsize * 8, 0 * 2);
        gl.vertexAttribPointer(deltaLocation, 2, gl.FLOAT, false, fsize * 8, 2 * 4);
        gl.vertexAttribPointer(intensityLoc, 4, gl.FLOAT, false, fsize * 8, 4 * 4);



        console.log(aes._allFeatures[0]._points[0].numItems);
        gl.drawArrays(gl.TRIANGLES, 0, aes._allFeatures[0]._points[0].numItems);


        gl.useProgram(this._webgl.heatmapProgram[1]);

        gl.disable(gl.BLEND);

        //console.log(&quot;fase 1 concluida&quot;);

        const canvas = document.getElementById(`mapCanvas${this.id}`);



        const source = gl.createTexture();

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, source);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);

        function isPowerOf2(value) {
            return (value &amp; (value - 1)) == 0;
        };

        function steupTextureFilteringAndMips(width, height, gl) {
            if (isPowerOf2(width) &amp;&amp; isPowerOf2(height)) {
                // the dimensions are power of 2 so generate mips and turn on 
                // tri-linear filtering.
                gl.generateMipmap(gl.TEXTURE_2D);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            } else {
                // at least one of the dimensions is not a power of 2 so set the filtering
                // so WebGL will render it.
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
        };



        steupTextureFilteringAndMips(canvas.width, canvas.height, gl);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        const vertices = new Float32Array([1, 1, -1, 1, -1, -1, 1, 1, -1, -1, 1, -1]);
        const buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(this._webgl.heatmapProgram[1], &apos;position&apos;);
        const sourceLoc = gl.getUniformLocation(this._webgl.heatmapProgram[1], &apos;source&apos;);
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        gl.uniform1i(sourceLoc, 0);
        gl.drawArrays(gl.TRIANGLES, 0, 6);


        gl.disableVertexAttribArray(positionLoc);
        //defaults to general program
        //console.log(&quot;fase 2 concluida&quot;);
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this._webgl.gl.useProgram(this._webgl.program);
    }

    getNumberOfPolygons() {
        let count = 0;
        for (let i = 0; i &lt; this.aesthetics.length; i++) {
            for (let z = 0; z &lt; this.aesthetics[i]._features.length; z++) {
                count += this.aesthetics[i]._features[z]._triangles.length;
            }
        }
        return count;
    }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
